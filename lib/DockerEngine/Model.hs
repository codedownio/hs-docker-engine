{-
   Docker Engine API

   The Engine API is an HTTP API served by Docker Engine. It is the API the Docker client uses to communicate with the Engine, so everything the Docker client can do can be done with the API.  Most of the client's commands map directly to API endpoints (e.g. `docker ps` is `GET /containers/json`). The notable exception is running containers, which consists of several API calls.  # Errors  The API uses standard HTTP status codes to indicate the success or failure of the API call. The body of the response will be JSON in the following format:  ``` {   \"message\": \"page not found\" } ```  # Versioning  The API is usually changed in each release of Docker, so API calls are versioned to ensure that clients don't break.  For Docker Engine 1.13, the API version is 1.25. To lock to this version, you prefix the URL with `/v1.25`. For example, calling `/info` is the same as calling `/v1.25/info`.  Engine releases in the near future should support this version of the API, so your client will continue to work even if it is talking to a newer Engine.  In previous versions of Docker, it was possible to access the API without providing a version. This behaviour is now deprecated will be removed in a future version of Docker.  The API uses an open schema model, which means server may add extra properties to responses. Likewise, the server will ignore any extra query parameters and request body properties. When you write clients, you need to ignore additional properties in responses to ensure they do not break when talking to newer Docker daemons.  This documentation is for version 1.25 of the API, which was introduced with Docker 1.13. Use this table to find documentation for previous versions of the API:  Docker version  | API version | Changes ----------------|-------------|--------- 1.12.x | [1.24](https://docs.docker.com/engine/api/v1.24/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-24-api-changes) 1.11.x | [1.23](https://docs.docker.com/engine/api/v1.23/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-23-api-changes) 1.10.x | [1.22](https://docs.docker.com/engine/api/v1.22/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-22-api-changes) 1.9.x | [1.21](https://docs.docker.com/engine/api/v1.21/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-21-api-changes) 1.8.x | [1.20](https://docs.docker.com/engine/api/v1.20/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-20-api-changes) 1.7.x | [1.19](https://docs.docker.com/engine/api/v1.19/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-19-api-changes) 1.6.x | [1.18](https://docs.docker.com/engine/api/v1.18/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-18-api-changes)  # Authentication  Authentication for registries is handled client side. The client has to send authentication details to various endpoints that need to communicate with registries, such as `POST /images/(name)/push`. These are sent as `X-Registry-Auth` header as a Base64 encoded (JSON) string with the following structure:  ``` {   \"username\": \"string\",   \"password\": \"string\",   \"email\": \"string\",   \"serveraddress\": \"string\" } ```  The `serveraddress` is a domain/IP without a protocol. Throughout this structure, double quotes are required.  If you have already got an identity token from the [`/auth` endpoint](#operation/SystemAuth), you can just pass this instead of credentials:  ``` {   \"identitytoken\": \"9cbaf023786cd7...\" } ``` 

   OpenAPI spec version: 2.0
   Docker Engine API API version: 1.25
   Generated by Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
-}

{-|
Module : DockerEngine.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module DockerEngine.Model where

import DockerEngine.Core
import DockerEngine.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Data, Typeable)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Text (Text)
import Prelude (($), (.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Models


-- ** AuthConfig
-- | AuthConfig
data AuthConfig = AuthConfig
  { authConfigUsername :: !(Maybe Text) -- ^ "username"
  , authConfigPassword :: !(Maybe Text) -- ^ "password"
  , authConfigEmail :: !(Maybe Text) -- ^ "email"
  , authConfigServeraddress :: !(Maybe Text) -- ^ "serveraddress"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AuthConfig
instance A.FromJSON AuthConfig where
  parseJSON = A.withObject "AuthConfig" $ \o ->
    AuthConfig
      <$> (o .:? "username")
      <*> (o .:? "password")
      <*> (o .:? "email")
      <*> (o .:? "serveraddress")

-- | ToJSON AuthConfig
instance A.ToJSON AuthConfig where
  toJSON AuthConfig {..} =
   _omitNulls
      [ "username" .= authConfigUsername
      , "password" .= authConfigPassword
      , "email" .= authConfigEmail
      , "serveraddress" .= authConfigServeraddress
      ]


-- | Construct a value of type 'AuthConfig' (by applying it's required fields, if any)
mkAuthConfig
  :: AuthConfig
mkAuthConfig =
  AuthConfig
  { authConfigUsername = Nothing
  , authConfigPassword = Nothing
  , authConfigEmail = Nothing
  , authConfigServeraddress = Nothing
  }

-- ** Body
-- | Body
-- Describes a permission accepted by the user upon installing the plugin.
data Body = Body
  { bodyName :: !(Maybe Text) -- ^ "Name"
  , bodyDescription :: !(Maybe Text) -- ^ "Description"
  , bodyValue :: !(Maybe [Text]) -- ^ "Value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Body
instance A.FromJSON Body where
  parseJSON = A.withObject "Body" $ \o ->
    Body
      <$> (o .:? "Name")
      <*> (o .:? "Description")
      <*> (o .:? "Value")

-- | ToJSON Body
instance A.ToJSON Body where
  toJSON Body {..} =
   _omitNulls
      [ "Name" .= bodyName
      , "Description" .= bodyDescription
      , "Value" .= bodyValue
      ]


-- | Construct a value of type 'Body' (by applying it's required fields, if any)
mkBody
  :: Body
mkBody =
  Body
  { bodyName = Nothing
  , bodyDescription = Nothing
  , bodyValue = Nothing
  }

-- ** Body1
-- | Body1
data Body1 = Body1
  { body1ListenAddr :: !(Maybe Text) -- ^ "ListenAddr" - Listen address used for inter-manager communication, as well as determining the networking interface used for the VXLAN Tunnel Endpoint (VTEP). This can either be an address/port combination in the form &#x60;192.168.1.1:4567&#x60;, or an interface followed by a port number, like &#x60;eth0:4567&#x60;. If the port number is omitted, the default swarm listening port is used.
  , body1AdvertiseAddr :: !(Maybe Text) -- ^ "AdvertiseAddr" - Externally reachable address advertised to other nodes. This can either be an address/port combination in the form &#x60;192.168.1.1:4567&#x60;, or an interface followed by a port number, like &#x60;eth0:4567&#x60;. If the port number is omitted, the port number from the listen address is used. If &#x60;AdvertiseAddr&#x60; is not specified, it will be automatically detected when possible.
  , body1ForceNewCluster :: !(Maybe Bool) -- ^ "ForceNewCluster" - Force creation of a new swarm.
  , body1Spec :: !(Maybe SwarmSpec) -- ^ "Spec"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Body1
instance A.FromJSON Body1 where
  parseJSON = A.withObject "Body1" $ \o ->
    Body1
      <$> (o .:? "ListenAddr")
      <*> (o .:? "AdvertiseAddr")
      <*> (o .:? "ForceNewCluster")
      <*> (o .:? "Spec")

-- | ToJSON Body1
instance A.ToJSON Body1 where
  toJSON Body1 {..} =
   _omitNulls
      [ "ListenAddr" .= body1ListenAddr
      , "AdvertiseAddr" .= body1AdvertiseAddr
      , "ForceNewCluster" .= body1ForceNewCluster
      , "Spec" .= body1Spec
      ]


-- | Construct a value of type 'Body1' (by applying it's required fields, if any)
mkBody1
  :: Body1
mkBody1 =
  Body1
  { body1ListenAddr = Nothing
  , body1AdvertiseAddr = Nothing
  , body1ForceNewCluster = Nothing
  , body1Spec = Nothing
  }

-- ** Body2
-- | Body2
data Body2 = Body2
  { body2ListenAddr :: !(Maybe Text) -- ^ "ListenAddr" - Listen address used for inter-manager communication if the node gets promoted to manager, as well as determining the networking interface used for the VXLAN Tunnel Endpoint (VTEP).
  , body2AdvertiseAddr :: !(Maybe Text) -- ^ "AdvertiseAddr" - Externally reachable address advertised to other nodes. This can either be an address/port combination in the form &#x60;192.168.1.1:4567&#x60;, or an interface followed by a port number, like &#x60;eth0:4567&#x60;. If the port number is omitted, the port number from the listen address is used. If &#x60;AdvertiseAddr&#x60; is not specified, it will be automatically detected when possible.
  , body2RemoteAddrs :: !(Maybe Text) -- ^ "RemoteAddrs" - Addresses of manager nodes already participating in the swarm.
  , body2JoinToken :: !(Maybe Text) -- ^ "JoinToken" - Secret token for joining this swarm.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Body2
instance A.FromJSON Body2 where
  parseJSON = A.withObject "Body2" $ \o ->
    Body2
      <$> (o .:? "ListenAddr")
      <*> (o .:? "AdvertiseAddr")
      <*> (o .:? "RemoteAddrs")
      <*> (o .:? "JoinToken")

-- | ToJSON Body2
instance A.ToJSON Body2 where
  toJSON Body2 {..} =
   _omitNulls
      [ "ListenAddr" .= body2ListenAddr
      , "AdvertiseAddr" .= body2AdvertiseAddr
      , "RemoteAddrs" .= body2RemoteAddrs
      , "JoinToken" .= body2JoinToken
      ]


-- | Construct a value of type 'Body2' (by applying it's required fields, if any)
mkBody2
  :: Body2
mkBody2 =
  Body2
  { body2ListenAddr = Nothing
  , body2AdvertiseAddr = Nothing
  , body2RemoteAddrs = Nothing
  , body2JoinToken = Nothing
  }

-- ** Body3
-- | Body3
data Body3 = Body3
  { body3UnlockKey :: !(Maybe Text) -- ^ "UnlockKey" - The swarm&#39;s unlock key.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Body3
instance A.FromJSON Body3 where
  parseJSON = A.withObject "Body3" $ \o ->
    Body3
      <$> (o .:? "UnlockKey")

-- | ToJSON Body3
instance A.ToJSON Body3 where
  toJSON Body3 {..} =
   _omitNulls
      [ "UnlockKey" .= body3UnlockKey
      ]


-- | Construct a value of type 'Body3' (by applying it's required fields, if any)
mkBody3
  :: Body3
mkBody3 =
  Body3
  { body3UnlockKey = Nothing
  }

-- ** BuildInfo
-- | BuildInfo
data BuildInfo = BuildInfo
  { buildInfoId :: !(Maybe Text) -- ^ "id"
  , buildInfoStream :: !(Maybe Text) -- ^ "stream"
  , buildInfoError :: !(Maybe Text) -- ^ "error"
  , buildInfoErrorDetail :: !(Maybe ErrorDetail) -- ^ "errorDetail"
  , buildInfoStatus :: !(Maybe Text) -- ^ "status"
  , buildInfoProgress :: !(Maybe Text) -- ^ "progress"
  , buildInfoProgressDetail :: !(Maybe ProgressDetail) -- ^ "progressDetail"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BuildInfo
instance A.FromJSON BuildInfo where
  parseJSON = A.withObject "BuildInfo" $ \o ->
    BuildInfo
      <$> (o .:? "id")
      <*> (o .:? "stream")
      <*> (o .:? "error")
      <*> (o .:? "errorDetail")
      <*> (o .:? "status")
      <*> (o .:? "progress")
      <*> (o .:? "progressDetail")

-- | ToJSON BuildInfo
instance A.ToJSON BuildInfo where
  toJSON BuildInfo {..} =
   _omitNulls
      [ "id" .= buildInfoId
      , "stream" .= buildInfoStream
      , "error" .= buildInfoError
      , "errorDetail" .= buildInfoErrorDetail
      , "status" .= buildInfoStatus
      , "progress" .= buildInfoProgress
      , "progressDetail" .= buildInfoProgressDetail
      ]


-- | Construct a value of type 'BuildInfo' (by applying it's required fields, if any)
mkBuildInfo
  :: BuildInfo
mkBuildInfo =
  BuildInfo
  { buildInfoId = Nothing
  , buildInfoStream = Nothing
  , buildInfoError = Nothing
  , buildInfoErrorDetail = Nothing
  , buildInfoStatus = Nothing
  , buildInfoProgress = Nothing
  , buildInfoProgressDetail = Nothing
  }

-- ** ClusterInfo
-- | ClusterInfo
data ClusterInfo = ClusterInfo
  { clusterInfoId :: !(Maybe Text) -- ^ "ID" - The ID of the swarm.
  , clusterInfoVersion :: !(Maybe NodeVersion) -- ^ "Version"
  , clusterInfoCreatedAt :: !(Maybe Text) -- ^ "CreatedAt"
  , clusterInfoUpdatedAt :: !(Maybe Text) -- ^ "UpdatedAt"
  , clusterInfoSpec :: !(Maybe SwarmSpec) -- ^ "Spec"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ClusterInfo
instance A.FromJSON ClusterInfo where
  parseJSON = A.withObject "ClusterInfo" $ \o ->
    ClusterInfo
      <$> (o .:? "ID")
      <*> (o .:? "Version")
      <*> (o .:? "CreatedAt")
      <*> (o .:? "UpdatedAt")
      <*> (o .:? "Spec")

-- | ToJSON ClusterInfo
instance A.ToJSON ClusterInfo where
  toJSON ClusterInfo {..} =
   _omitNulls
      [ "ID" .= clusterInfoId
      , "Version" .= clusterInfoVersion
      , "CreatedAt" .= clusterInfoCreatedAt
      , "UpdatedAt" .= clusterInfoUpdatedAt
      , "Spec" .= clusterInfoSpec
      ]


-- | Construct a value of type 'ClusterInfo' (by applying it's required fields, if any)
mkClusterInfo
  :: ClusterInfo
mkClusterInfo =
  ClusterInfo
  { clusterInfoId = Nothing
  , clusterInfoVersion = Nothing
  , clusterInfoCreatedAt = Nothing
  , clusterInfoUpdatedAt = Nothing
  , clusterInfoSpec = Nothing
  }

-- ** Config
-- | Config
-- Configuration for a container that is portable between hosts
data Config = Config
  { configHostname :: !(Maybe Text) -- ^ "Hostname" - The hostname to use for the container, as a valid RFC 1123 hostname.
  , configDomainname :: !(Maybe Text) -- ^ "Domainname" - The domain name to use for the container.
  , configUser :: !(Maybe Text) -- ^ "User" - The user that commands are run as inside the container.
  , configAttachStdin :: !(Maybe Bool) -- ^ "AttachStdin" - Whether to attach to &#x60;stdin&#x60;.
  , configAttachStdout :: !(Maybe Bool) -- ^ "AttachStdout" - Whether to attach to &#x60;stdout&#x60;.
  , configAttachStderr :: !(Maybe Bool) -- ^ "AttachStderr" - Whether to attach to &#x60;stderr&#x60;.
  , configExposedPorts :: !(Maybe (Map.Map String A.Value)) -- ^ "ExposedPorts" - An object mapping ports to an empty object in the form:  &#x60;{\&quot;&lt;port&gt;/&lt;tcp|udp&gt;\&quot;: {}}&#x60; 
  , configTty :: !(Maybe Bool) -- ^ "Tty" - Attach standard streams to a TTY, including &#x60;stdin&#x60; if it is not closed.
  , configOpenStdin :: !(Maybe Bool) -- ^ "OpenStdin" - Open &#x60;stdin&#x60;
  , configStdinOnce :: !(Maybe Bool) -- ^ "StdinOnce" - Close &#x60;stdin&#x60; after one attached client disconnects
  , configEnv :: !(Maybe [Text]) -- ^ "Env" - A list of environment variables to set inside the container in the form &#x60;[\&quot;VAR&#x3D;value\&quot;, ...]&#x60; 
  , configHealthcheck :: !(Maybe ConfigHealthcheck) -- ^ "Healthcheck"
  , configArgsEscaped :: !(Maybe Bool) -- ^ "ArgsEscaped" - Command is already escaped (Windows only)
  , configImage :: !(Maybe Text) -- ^ "Image" - The name of the image to use when creating the container
  , configVolumes :: !(Maybe ConfigVolumes) -- ^ "Volumes"
  , configWorkingDir :: !(Maybe Text) -- ^ "WorkingDir" - The working directory for commands to run in.
  , configNetworkDisabled :: !(Maybe Bool) -- ^ "NetworkDisabled" - Disable networking for the container.
  , configMacAddress :: !(Maybe Text) -- ^ "MacAddress" - MAC address of the container.
  , configOnBuild :: !(Maybe [Text]) -- ^ "OnBuild" - &#x60;ONBUILD&#x60; metadata that were defined in the image&#39;s &#x60;Dockerfile&#x60;.
  , configLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  , configStopSignal :: !(Maybe Text) -- ^ "StopSignal" - Signal to stop a container as a string or unsigned integer.
  , configStopTimeout :: !(Maybe Int) -- ^ "StopTimeout" - Timeout to stop a container in seconds.
  , configShell :: !(Maybe [Text]) -- ^ "Shell" - Shell for when &#x60;RUN&#x60;, &#x60;CMD&#x60;, and &#x60;ENTRYPOINT&#x60; uses a shell.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Config
instance A.FromJSON Config where
  parseJSON = A.withObject "Config" $ \o ->
    Config
      <$> (o .:? "Hostname")
      <*> (o .:? "Domainname")
      <*> (o .:? "User")
      <*> (o .:? "AttachStdin")
      <*> (o .:? "AttachStdout")
      <*> (o .:? "AttachStderr")
      <*> (o .:? "ExposedPorts")
      <*> (o .:? "Tty")
      <*> (o .:? "OpenStdin")
      <*> (o .:? "StdinOnce")
      <*> (o .:? "Env")
      <*> (o .:? "Healthcheck")
      <*> (o .:? "ArgsEscaped")
      <*> (o .:? "Image")
      <*> (o .:? "Volumes")
      <*> (o .:? "WorkingDir")
      <*> (o .:? "NetworkDisabled")
      <*> (o .:? "MacAddress")
      <*> (o .:? "OnBuild")
      <*> (o .:? "Labels")
      <*> (o .:? "StopSignal")
      <*> (o .:? "StopTimeout")
      <*> (o .:? "Shell")

-- | ToJSON Config
instance A.ToJSON Config where
  toJSON Config {..} =
   _omitNulls
      [ "Hostname" .= configHostname
      , "Domainname" .= configDomainname
      , "User" .= configUser
      , "AttachStdin" .= configAttachStdin
      , "AttachStdout" .= configAttachStdout
      , "AttachStderr" .= configAttachStderr
      , "ExposedPorts" .= configExposedPorts
      , "Tty" .= configTty
      , "OpenStdin" .= configOpenStdin
      , "StdinOnce" .= configStdinOnce
      , "Env" .= configEnv
      , "Healthcheck" .= configHealthcheck
      , "ArgsEscaped" .= configArgsEscaped
      , "Image" .= configImage
      , "Volumes" .= configVolumes
      , "WorkingDir" .= configWorkingDir
      , "NetworkDisabled" .= configNetworkDisabled
      , "MacAddress" .= configMacAddress
      , "OnBuild" .= configOnBuild
      , "Labels" .= configLabels
      , "StopSignal" .= configStopSignal
      , "StopTimeout" .= configStopTimeout
      , "Shell" .= configShell
      ]


-- | Construct a value of type 'Config' (by applying it's required fields, if any)
mkConfig
  :: Config
mkConfig =
  Config
  { configHostname = Nothing
  , configDomainname = Nothing
  , configUser = Nothing
  , configAttachStdin = Nothing
  , configAttachStdout = Nothing
  , configAttachStderr = Nothing
  , configExposedPorts = Nothing
  , configTty = Nothing
  , configOpenStdin = Nothing
  , configStdinOnce = Nothing
  , configEnv = Nothing
  , configHealthcheck = Nothing
  , configArgsEscaped = Nothing
  , configImage = Nothing
  , configVolumes = Nothing
  , configWorkingDir = Nothing
  , configNetworkDisabled = Nothing
  , configMacAddress = Nothing
  , configOnBuild = Nothing
  , configLabels = Nothing
  , configStopSignal = Nothing
  , configStopTimeout = Nothing
  , configShell = Nothing
  }

-- ** ConfigHealthcheck
-- | ConfigHealthcheck
-- A test to perform to check that the container is healthy.
data ConfigHealthcheck = ConfigHealthcheck
  { configHealthcheckTest :: !(Maybe [Text]) -- ^ "Test" - The test to perform. Possible values are:  - &#x60;{}&#x60; inherit healthcheck from image or parent image - &#x60;{\&quot;NONE\&quot;}&#x60; disable healthcheck - &#x60;{\&quot;CMD\&quot;, args...}&#x60; exec arguments directly - &#x60;{\&quot;CMD-SHELL\&quot;, command}&#x60; run command with system&#39;s default shell 
  , configHealthcheckInterval :: !(Maybe Int) -- ^ "Interval" - The time to wait between checks in nanoseconds. 0 means inherit.
  , configHealthcheckTimeout :: !(Maybe Int) -- ^ "Timeout" - The time to wait before considering the check to have hung. 0 means inherit.
  , configHealthcheckRetries :: !(Maybe Int) -- ^ "Retries" - The number of consecutive failures needed to consider a container as unhealthy. 0 means inherit.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConfigHealthcheck
instance A.FromJSON ConfigHealthcheck where
  parseJSON = A.withObject "ConfigHealthcheck" $ \o ->
    ConfigHealthcheck
      <$> (o .:? "Test")
      <*> (o .:? "Interval")
      <*> (o .:? "Timeout")
      <*> (o .:? "Retries")

-- | ToJSON ConfigHealthcheck
instance A.ToJSON ConfigHealthcheck where
  toJSON ConfigHealthcheck {..} =
   _omitNulls
      [ "Test" .= configHealthcheckTest
      , "Interval" .= configHealthcheckInterval
      , "Timeout" .= configHealthcheckTimeout
      , "Retries" .= configHealthcheckRetries
      ]


-- | Construct a value of type 'ConfigHealthcheck' (by applying it's required fields, if any)
mkConfigHealthcheck
  :: ConfigHealthcheck
mkConfigHealthcheck =
  ConfigHealthcheck
  { configHealthcheckTest = Nothing
  , configHealthcheckInterval = Nothing
  , configHealthcheckTimeout = Nothing
  , configHealthcheckRetries = Nothing
  }

-- ** ConfigVolumes
-- | ConfigVolumes
-- An object mapping mount point paths inside the container to empty objects.
data ConfigVolumes = ConfigVolumes
  { configVolumesAdditionalProperties :: !(Maybe A.Value) -- ^ "additionalProperties"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConfigVolumes
instance A.FromJSON ConfigVolumes where
  parseJSON = A.withObject "ConfigVolumes" $ \o ->
    ConfigVolumes
      <$> (o .:? "additionalProperties")

-- | ToJSON ConfigVolumes
instance A.ToJSON ConfigVolumes where
  toJSON ConfigVolumes {..} =
   _omitNulls
      [ "additionalProperties" .= configVolumesAdditionalProperties
      ]


-- | Construct a value of type 'ConfigVolumes' (by applying it's required fields, if any)
mkConfigVolumes
  :: ConfigVolumes
mkConfigVolumes =
  ConfigVolumes
  { configVolumesAdditionalProperties = Nothing
  }

-- ** Container
-- | Container
data Container = Container
  { containerContainer :: !(Maybe Text) -- ^ "Container" - The ID or name of the container to connect to the network.
  , containerEndpointConfig :: !(Maybe EndpointSettings) -- ^ "EndpointConfig"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Container
instance A.FromJSON Container where
  parseJSON = A.withObject "Container" $ \o ->
    Container
      <$> (o .:? "Container")
      <*> (o .:? "EndpointConfig")

-- | ToJSON Container
instance A.ToJSON Container where
  toJSON Container {..} =
   _omitNulls
      [ "Container" .= containerContainer
      , "EndpointConfig" .= containerEndpointConfig
      ]


-- | Construct a value of type 'Container' (by applying it's required fields, if any)
mkContainer
  :: Container
mkContainer =
  Container
  { containerContainer = Nothing
  , containerEndpointConfig = Nothing
  }

-- ** Container1
-- | Container1
data Container1 = Container1
  { container1Container :: !(Maybe Text) -- ^ "Container" - The ID or name of the container to disconnect from the network.
  , container1Force :: !(Maybe Bool) -- ^ "Force" - Force the container to disconnect from the network.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Container1
instance A.FromJSON Container1 where
  parseJSON = A.withObject "Container1" $ \o ->
    Container1
      <$> (o .:? "Container")
      <*> (o .:? "Force")

-- | ToJSON Container1
instance A.ToJSON Container1 where
  toJSON Container1 {..} =
   _omitNulls
      [ "Container" .= container1Container
      , "Force" .= container1Force
      ]


-- | Construct a value of type 'Container1' (by applying it's required fields, if any)
mkContainer1
  :: Container1
mkContainer1 =
  Container1
  { container1Container = Nothing
  , container1Force = Nothing
  }

-- ** ContainerSummary
-- | ContainerSummary
data ContainerSummary = ContainerSummary
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContainerSummary
instance A.FromJSON ContainerSummary where
  parseJSON = A.withObject "ContainerSummary" $ \o ->
    pure ContainerSummary
      

-- | ToJSON ContainerSummary
instance A.ToJSON ContainerSummary where
  toJSON ContainerSummary  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'ContainerSummary' (by applying it's required fields, if any)
mkContainerSummary
  :: ContainerSummary
mkContainerSummary =
  ContainerSummary
  { 
  }

-- ** ContainerSummaryInner
-- | ContainerSummaryInner
data ContainerSummaryInner = ContainerSummaryInner
  { containerSummaryInnerId :: !(Maybe Text) -- ^ "Id" - The ID of this container
  , containerSummaryInnerNames :: !(Maybe [Text]) -- ^ "Names" - The names that this container has been given
  , containerSummaryInnerImage :: !(Maybe Text) -- ^ "Image" - The name of the image used when creating this container
  , containerSummaryInnerImageId :: !(Maybe Text) -- ^ "ImageID" - The ID of the image that this container was created from
  , containerSummaryInnerCommand :: !(Maybe Text) -- ^ "Command" - Command to run when starting the container
  , containerSummaryInnerCreated :: !(Maybe Integer) -- ^ "Created" - When the container was created
  , containerSummaryInnerPorts :: !(Maybe [Port]) -- ^ "Ports" - The ports exposed by this container
  , containerSummaryInnerSizeRw :: !(Maybe Integer) -- ^ "SizeRw" - The size of files that have been created or changed by this container
  , containerSummaryInnerSizeRootFs :: !(Maybe Integer) -- ^ "SizeRootFs" - The total size of all the files in this container
  , containerSummaryInnerLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  , containerSummaryInnerState :: !(Maybe Text) -- ^ "State" - The state of this container (e.g. &#x60;Exited&#x60;)
  , containerSummaryInnerStatus :: !(Maybe Text) -- ^ "Status" - Additional human-readable status of this container (e.g. &#x60;Exit 0&#x60;)
  , containerSummaryInnerHostConfig :: !(Maybe ContainerSummaryInnerHostConfig) -- ^ "HostConfig"
  , containerSummaryInnerNetworkSettings :: !(Maybe ContainerSummaryInnerNetworkSettings) -- ^ "NetworkSettings"
  , containerSummaryInnerMounts :: !(Maybe [Mount]) -- ^ "Mounts"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContainerSummaryInner
instance A.FromJSON ContainerSummaryInner where
  parseJSON = A.withObject "ContainerSummaryInner" $ \o ->
    ContainerSummaryInner
      <$> (o .:? "Id")
      <*> (o .:? "Names")
      <*> (o .:? "Image")
      <*> (o .:? "ImageID")
      <*> (o .:? "Command")
      <*> (o .:? "Created")
      <*> (o .:? "Ports")
      <*> (o .:? "SizeRw")
      <*> (o .:? "SizeRootFs")
      <*> (o .:? "Labels")
      <*> (o .:? "State")
      <*> (o .:? "Status")
      <*> (o .:? "HostConfig")
      <*> (o .:? "NetworkSettings")
      <*> (o .:? "Mounts")

-- | ToJSON ContainerSummaryInner
instance A.ToJSON ContainerSummaryInner where
  toJSON ContainerSummaryInner {..} =
   _omitNulls
      [ "Id" .= containerSummaryInnerId
      , "Names" .= containerSummaryInnerNames
      , "Image" .= containerSummaryInnerImage
      , "ImageID" .= containerSummaryInnerImageId
      , "Command" .= containerSummaryInnerCommand
      , "Created" .= containerSummaryInnerCreated
      , "Ports" .= containerSummaryInnerPorts
      , "SizeRw" .= containerSummaryInnerSizeRw
      , "SizeRootFs" .= containerSummaryInnerSizeRootFs
      , "Labels" .= containerSummaryInnerLabels
      , "State" .= containerSummaryInnerState
      , "Status" .= containerSummaryInnerStatus
      , "HostConfig" .= containerSummaryInnerHostConfig
      , "NetworkSettings" .= containerSummaryInnerNetworkSettings
      , "Mounts" .= containerSummaryInnerMounts
      ]


-- | Construct a value of type 'ContainerSummaryInner' (by applying it's required fields, if any)
mkContainerSummaryInner
  :: ContainerSummaryInner
mkContainerSummaryInner =
  ContainerSummaryInner
  { containerSummaryInnerId = Nothing
  , containerSummaryInnerNames = Nothing
  , containerSummaryInnerImage = Nothing
  , containerSummaryInnerImageId = Nothing
  , containerSummaryInnerCommand = Nothing
  , containerSummaryInnerCreated = Nothing
  , containerSummaryInnerPorts = Nothing
  , containerSummaryInnerSizeRw = Nothing
  , containerSummaryInnerSizeRootFs = Nothing
  , containerSummaryInnerLabels = Nothing
  , containerSummaryInnerState = Nothing
  , containerSummaryInnerStatus = Nothing
  , containerSummaryInnerHostConfig = Nothing
  , containerSummaryInnerNetworkSettings = Nothing
  , containerSummaryInnerMounts = Nothing
  }

-- ** ContainerSummaryInnerHostConfig
-- | ContainerSummaryInnerHostConfig
data ContainerSummaryInnerHostConfig = ContainerSummaryInnerHostConfig
  { containerSummaryInnerHostConfigNetworkMode :: !(Maybe Text) -- ^ "NetworkMode"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContainerSummaryInnerHostConfig
instance A.FromJSON ContainerSummaryInnerHostConfig where
  parseJSON = A.withObject "ContainerSummaryInnerHostConfig" $ \o ->
    ContainerSummaryInnerHostConfig
      <$> (o .:? "NetworkMode")

-- | ToJSON ContainerSummaryInnerHostConfig
instance A.ToJSON ContainerSummaryInnerHostConfig where
  toJSON ContainerSummaryInnerHostConfig {..} =
   _omitNulls
      [ "NetworkMode" .= containerSummaryInnerHostConfigNetworkMode
      ]


-- | Construct a value of type 'ContainerSummaryInnerHostConfig' (by applying it's required fields, if any)
mkContainerSummaryInnerHostConfig
  :: ContainerSummaryInnerHostConfig
mkContainerSummaryInnerHostConfig =
  ContainerSummaryInnerHostConfig
  { containerSummaryInnerHostConfigNetworkMode = Nothing
  }

-- ** ContainerSummaryInnerNetworkSettings
-- | ContainerSummaryInnerNetworkSettings
-- A summary of the container's network settings
data ContainerSummaryInnerNetworkSettings = ContainerSummaryInnerNetworkSettings
  { containerSummaryInnerNetworkSettingsNetworks :: !(Maybe (Map.Map String EndpointSettings)) -- ^ "Networks"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContainerSummaryInnerNetworkSettings
instance A.FromJSON ContainerSummaryInnerNetworkSettings where
  parseJSON = A.withObject "ContainerSummaryInnerNetworkSettings" $ \o ->
    ContainerSummaryInnerNetworkSettings
      <$> (o .:? "Networks")

-- | ToJSON ContainerSummaryInnerNetworkSettings
instance A.ToJSON ContainerSummaryInnerNetworkSettings where
  toJSON ContainerSummaryInnerNetworkSettings {..} =
   _omitNulls
      [ "Networks" .= containerSummaryInnerNetworkSettingsNetworks
      ]


-- | Construct a value of type 'ContainerSummaryInnerNetworkSettings' (by applying it's required fields, if any)
mkContainerSummaryInnerNetworkSettings
  :: ContainerSummaryInnerNetworkSettings
mkContainerSummaryInnerNetworkSettings =
  ContainerSummaryInnerNetworkSettings
  { containerSummaryInnerNetworkSettingsNetworks = Nothing
  }

-- ** CreateImageInfo
-- | CreateImageInfo
data CreateImageInfo = CreateImageInfo
  { createImageInfoError :: !(Maybe Text) -- ^ "error"
  , createImageInfoStatus :: !(Maybe Text) -- ^ "status"
  , createImageInfoProgress :: !(Maybe Text) -- ^ "progress"
  , createImageInfoProgressDetail :: !(Maybe ProgressDetail) -- ^ "progressDetail"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateImageInfo
instance A.FromJSON CreateImageInfo where
  parseJSON = A.withObject "CreateImageInfo" $ \o ->
    CreateImageInfo
      <$> (o .:? "error")
      <*> (o .:? "status")
      <*> (o .:? "progress")
      <*> (o .:? "progressDetail")

-- | ToJSON CreateImageInfo
instance A.ToJSON CreateImageInfo where
  toJSON CreateImageInfo {..} =
   _omitNulls
      [ "error" .= createImageInfoError
      , "status" .= createImageInfoStatus
      , "progress" .= createImageInfoProgress
      , "progressDetail" .= createImageInfoProgressDetail
      ]


-- | Construct a value of type 'CreateImageInfo' (by applying it's required fields, if any)
mkCreateImageInfo
  :: CreateImageInfo
mkCreateImageInfo =
  CreateImageInfo
  { createImageInfoError = Nothing
  , createImageInfoStatus = Nothing
  , createImageInfoProgress = Nothing
  , createImageInfoProgressDetail = Nothing
  }

-- ** DeviceMapping
-- | DeviceMapping
-- A device mapping between the host and container
data DeviceMapping = DeviceMapping
  { deviceMappingPathOnHost :: !(Maybe Text) -- ^ "PathOnHost"
  , deviceMappingPathInContainer :: !(Maybe Text) -- ^ "PathInContainer"
  , deviceMappingCgroupPermissions :: !(Maybe Text) -- ^ "CgroupPermissions"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeviceMapping
instance A.FromJSON DeviceMapping where
  parseJSON = A.withObject "DeviceMapping" $ \o ->
    DeviceMapping
      <$> (o .:? "PathOnHost")
      <*> (o .:? "PathInContainer")
      <*> (o .:? "CgroupPermissions")

-- | ToJSON DeviceMapping
instance A.ToJSON DeviceMapping where
  toJSON DeviceMapping {..} =
   _omitNulls
      [ "PathOnHost" .= deviceMappingPathOnHost
      , "PathInContainer" .= deviceMappingPathInContainer
      , "CgroupPermissions" .= deviceMappingCgroupPermissions
      ]


-- | Construct a value of type 'DeviceMapping' (by applying it's required fields, if any)
mkDeviceMapping
  :: DeviceMapping
mkDeviceMapping =
  DeviceMapping
  { deviceMappingPathOnHost = Nothing
  , deviceMappingPathInContainer = Nothing
  , deviceMappingCgroupPermissions = Nothing
  }

-- ** EndpointPortConfig
-- | EndpointPortConfig
data EndpointPortConfig = EndpointPortConfig
  { endpointPortConfigName :: !(Maybe Text) -- ^ "Name"
  , endpointPortConfigProtocol :: !(Maybe E'Type) -- ^ "Protocol"
  , endpointPortConfigTargetPort :: !(Maybe Int) -- ^ "TargetPort" - The port inside the container.
  , endpointPortConfigPublishedPort :: !(Maybe Int) -- ^ "PublishedPort" - The port on the swarm hosts.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EndpointPortConfig
instance A.FromJSON EndpointPortConfig where
  parseJSON = A.withObject "EndpointPortConfig" $ \o ->
    EndpointPortConfig
      <$> (o .:? "Name")
      <*> (o .:? "Protocol")
      <*> (o .:? "TargetPort")
      <*> (o .:? "PublishedPort")

-- | ToJSON EndpointPortConfig
instance A.ToJSON EndpointPortConfig where
  toJSON EndpointPortConfig {..} =
   _omitNulls
      [ "Name" .= endpointPortConfigName
      , "Protocol" .= endpointPortConfigProtocol
      , "TargetPort" .= endpointPortConfigTargetPort
      , "PublishedPort" .= endpointPortConfigPublishedPort
      ]


-- | Construct a value of type 'EndpointPortConfig' (by applying it's required fields, if any)
mkEndpointPortConfig
  :: EndpointPortConfig
mkEndpointPortConfig =
  EndpointPortConfig
  { endpointPortConfigName = Nothing
  , endpointPortConfigProtocol = Nothing
  , endpointPortConfigTargetPort = Nothing
  , endpointPortConfigPublishedPort = Nothing
  }

-- ** EndpointSettings
-- | EndpointSettings
-- Configuration for a network endpoint.
data EndpointSettings = EndpointSettings
  { endpointSettingsIpamConfig :: !(Maybe EndpointSettingsIPAMConfig) -- ^ "IPAMConfig"
  , endpointSettingsLinks :: !(Maybe [Text]) -- ^ "Links"
  , endpointSettingsAliases :: !(Maybe [Text]) -- ^ "Aliases"
  , endpointSettingsNetworkId :: !(Maybe Text) -- ^ "NetworkID"
  , endpointSettingsEndpointId :: !(Maybe Text) -- ^ "EndpointID"
  , endpointSettingsGateway :: !(Maybe Text) -- ^ "Gateway"
  , endpointSettingsIpAddress :: !(Maybe Text) -- ^ "IPAddress"
  , endpointSettingsIpPrefixLen :: !(Maybe Int) -- ^ "IPPrefixLen"
  , endpointSettingsIPv6Gateway :: !(Maybe Text) -- ^ "IPv6Gateway"
  , endpointSettingsGlobalIPv6Address :: !(Maybe Text) -- ^ "GlobalIPv6Address"
  , endpointSettingsGlobalIPv6PrefixLen :: !(Maybe Integer) -- ^ "GlobalIPv6PrefixLen"
  , endpointSettingsMacAddress :: !(Maybe Text) -- ^ "MacAddress"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EndpointSettings
instance A.FromJSON EndpointSettings where
  parseJSON = A.withObject "EndpointSettings" $ \o ->
    EndpointSettings
      <$> (o .:? "IPAMConfig")
      <*> (o .:? "Links")
      <*> (o .:? "Aliases")
      <*> (o .:? "NetworkID")
      <*> (o .:? "EndpointID")
      <*> (o .:? "Gateway")
      <*> (o .:? "IPAddress")
      <*> (o .:? "IPPrefixLen")
      <*> (o .:? "IPv6Gateway")
      <*> (o .:? "GlobalIPv6Address")
      <*> (o .:? "GlobalIPv6PrefixLen")
      <*> (o .:? "MacAddress")

-- | ToJSON EndpointSettings
instance A.ToJSON EndpointSettings where
  toJSON EndpointSettings {..} =
   _omitNulls
      [ "IPAMConfig" .= endpointSettingsIpamConfig
      , "Links" .= endpointSettingsLinks
      , "Aliases" .= endpointSettingsAliases
      , "NetworkID" .= endpointSettingsNetworkId
      , "EndpointID" .= endpointSettingsEndpointId
      , "Gateway" .= endpointSettingsGateway
      , "IPAddress" .= endpointSettingsIpAddress
      , "IPPrefixLen" .= endpointSettingsIpPrefixLen
      , "IPv6Gateway" .= endpointSettingsIPv6Gateway
      , "GlobalIPv6Address" .= endpointSettingsGlobalIPv6Address
      , "GlobalIPv6PrefixLen" .= endpointSettingsGlobalIPv6PrefixLen
      , "MacAddress" .= endpointSettingsMacAddress
      ]


-- | Construct a value of type 'EndpointSettings' (by applying it's required fields, if any)
mkEndpointSettings
  :: EndpointSettings
mkEndpointSettings =
  EndpointSettings
  { endpointSettingsIpamConfig = Nothing
  , endpointSettingsLinks = Nothing
  , endpointSettingsAliases = Nothing
  , endpointSettingsNetworkId = Nothing
  , endpointSettingsEndpointId = Nothing
  , endpointSettingsGateway = Nothing
  , endpointSettingsIpAddress = Nothing
  , endpointSettingsIpPrefixLen = Nothing
  , endpointSettingsIPv6Gateway = Nothing
  , endpointSettingsGlobalIPv6Address = Nothing
  , endpointSettingsGlobalIPv6PrefixLen = Nothing
  , endpointSettingsMacAddress = Nothing
  }

-- ** EndpointSettingsIPAMConfig
-- | EndpointSettingsIPAMConfig
-- IPAM configurations for the endpoint
data EndpointSettingsIPAMConfig = EndpointSettingsIPAMConfig
  { endpointSettingsIPAMConfigIPv4Address :: !(Maybe Text) -- ^ "IPv4Address"
  , endpointSettingsIPAMConfigIPv6Address :: !(Maybe Text) -- ^ "IPv6Address"
  , endpointSettingsIPAMConfigLinkLocalIPs :: !(Maybe [Text]) -- ^ "LinkLocalIPs"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EndpointSettingsIPAMConfig
instance A.FromJSON EndpointSettingsIPAMConfig where
  parseJSON = A.withObject "EndpointSettingsIPAMConfig" $ \o ->
    EndpointSettingsIPAMConfig
      <$> (o .:? "IPv4Address")
      <*> (o .:? "IPv6Address")
      <*> (o .:? "LinkLocalIPs")

-- | ToJSON EndpointSettingsIPAMConfig
instance A.ToJSON EndpointSettingsIPAMConfig where
  toJSON EndpointSettingsIPAMConfig {..} =
   _omitNulls
      [ "IPv4Address" .= endpointSettingsIPAMConfigIPv4Address
      , "IPv6Address" .= endpointSettingsIPAMConfigIPv6Address
      , "LinkLocalIPs" .= endpointSettingsIPAMConfigLinkLocalIPs
      ]


-- | Construct a value of type 'EndpointSettingsIPAMConfig' (by applying it's required fields, if any)
mkEndpointSettingsIPAMConfig
  :: EndpointSettingsIPAMConfig
mkEndpointSettingsIPAMConfig =
  EndpointSettingsIPAMConfig
  { endpointSettingsIPAMConfigIPv4Address = Nothing
  , endpointSettingsIPAMConfigIPv6Address = Nothing
  , endpointSettingsIPAMConfigLinkLocalIPs = Nothing
  }

-- ** EndpointSpec
-- | EndpointSpec
-- Properties that can be configured to access and load balance a service.
data EndpointSpec = EndpointSpec
  { endpointSpecMode :: !(Maybe E'Mode) -- ^ "Mode" - The mode of resolution to use for internal load balancing between tasks.
  , endpointSpecPorts :: !(Maybe [EndpointPortConfig]) -- ^ "Ports" - List of exposed ports that this service is accessible on from the outside. Ports can only be provided if &#x60;vip&#x60; resolution mode is used.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EndpointSpec
instance A.FromJSON EndpointSpec where
  parseJSON = A.withObject "EndpointSpec" $ \o ->
    EndpointSpec
      <$> (o .:? "Mode")
      <*> (o .:? "Ports")

-- | ToJSON EndpointSpec
instance A.ToJSON EndpointSpec where
  toJSON EndpointSpec {..} =
   _omitNulls
      [ "Mode" .= endpointSpecMode
      , "Ports" .= endpointSpecPorts
      ]


-- | Construct a value of type 'EndpointSpec' (by applying it's required fields, if any)
mkEndpointSpec
  :: EndpointSpec
mkEndpointSpec =
  EndpointSpec
  { endpointSpecMode = Nothing
  , endpointSpecPorts = Nothing
  }

-- ** ErrorDetail
-- | ErrorDetail
data ErrorDetail = ErrorDetail
  { errorDetailCode :: !(Maybe Int) -- ^ "code"
  , errorDetailMessage :: !(Maybe Text) -- ^ "message"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ErrorDetail
instance A.FromJSON ErrorDetail where
  parseJSON = A.withObject "ErrorDetail" $ \o ->
    ErrorDetail
      <$> (o .:? "code")
      <*> (o .:? "message")

-- | ToJSON ErrorDetail
instance A.ToJSON ErrorDetail where
  toJSON ErrorDetail {..} =
   _omitNulls
      [ "code" .= errorDetailCode
      , "message" .= errorDetailMessage
      ]


-- | Construct a value of type 'ErrorDetail' (by applying it's required fields, if any)
mkErrorDetail
  :: ErrorDetail
mkErrorDetail =
  ErrorDetail
  { errorDetailCode = Nothing
  , errorDetailMessage = Nothing
  }

-- ** ErrorResponse
-- | ErrorResponse
-- Represents an error.
data ErrorResponse = ErrorResponse
  { errorResponseMessage :: !(Text) -- ^ /Required/ "message" - The error message.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ErrorResponse
instance A.FromJSON ErrorResponse where
  parseJSON = A.withObject "ErrorResponse" $ \o ->
    ErrorResponse
      <$> (o .:  "message")

-- | ToJSON ErrorResponse
instance A.ToJSON ErrorResponse where
  toJSON ErrorResponse {..} =
   _omitNulls
      [ "message" .= errorResponseMessage
      ]


-- | Construct a value of type 'ErrorResponse' (by applying it's required fields, if any)
mkErrorResponse
  :: Text -- ^ 'errorResponseMessage': The error message.
  -> ErrorResponse
mkErrorResponse errorResponseMessage =
  ErrorResponse
  { errorResponseMessage
  }

-- ** ExecConfig
-- | ExecConfig
data ExecConfig = ExecConfig
  { execConfigAttachStdin :: !(Maybe Bool) -- ^ "AttachStdin" - Attach to &#x60;stdin&#x60; of the exec command.
  , execConfigAttachStdout :: !(Maybe Bool) -- ^ "AttachStdout" - Attach to &#x60;stdout&#x60; of the exec command.
  , execConfigAttachStderr :: !(Maybe Bool) -- ^ "AttachStderr" - Attach to &#x60;stderr&#x60; of the exec command.
  , execConfigDetachKeys :: !(Maybe Text) -- ^ "DetachKeys" - Override the key sequence for detaching a container. Format is a single character &#x60;[a-Z]&#x60; or &#x60;ctrl-&lt;value&gt;&#x60; where &#x60;&lt;value&gt;&#x60; is one of: &#x60;a-z&#x60;, &#x60;@&#x60;, &#x60;^&#x60;, &#x60;[&#x60;, &#x60;,&#x60; or &#x60;_&#x60;.
  , execConfigTty :: !(Maybe Bool) -- ^ "Tty" - Allocate a pseudo-TTY.
  , execConfigEnv :: !(Maybe [Text]) -- ^ "Env" - A list of environment variables in the form &#x60;[\&quot;VAR&#x3D;value\&quot;, ...]&#x60;.
  , execConfigCmd :: !(Maybe [Text]) -- ^ "Cmd" - Command to run, as a string or array of strings.
  , execConfigPrivileged :: !(Maybe Bool) -- ^ "Privileged" - Runs the exec process with extended privileges.
  , execConfigUser :: !(Maybe Text) -- ^ "User" - The user, and optionally, group to run the exec process inside the container. Format is one of: &#x60;user&#x60;, &#x60;user:group&#x60;, &#x60;uid&#x60;, or &#x60;uid:gid&#x60;.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExecConfig
instance A.FromJSON ExecConfig where
  parseJSON = A.withObject "ExecConfig" $ \o ->
    ExecConfig
      <$> (o .:? "AttachStdin")
      <*> (o .:? "AttachStdout")
      <*> (o .:? "AttachStderr")
      <*> (o .:? "DetachKeys")
      <*> (o .:? "Tty")
      <*> (o .:? "Env")
      <*> (o .:? "Cmd")
      <*> (o .:? "Privileged")
      <*> (o .:? "User")

-- | ToJSON ExecConfig
instance A.ToJSON ExecConfig where
  toJSON ExecConfig {..} =
   _omitNulls
      [ "AttachStdin" .= execConfigAttachStdin
      , "AttachStdout" .= execConfigAttachStdout
      , "AttachStderr" .= execConfigAttachStderr
      , "DetachKeys" .= execConfigDetachKeys
      , "Tty" .= execConfigTty
      , "Env" .= execConfigEnv
      , "Cmd" .= execConfigCmd
      , "Privileged" .= execConfigPrivileged
      , "User" .= execConfigUser
      ]


-- | Construct a value of type 'ExecConfig' (by applying it's required fields, if any)
mkExecConfig
  :: ExecConfig
mkExecConfig =
  ExecConfig
  { execConfigAttachStdin = Nothing
  , execConfigAttachStdout = Nothing
  , execConfigAttachStderr = Nothing
  , execConfigDetachKeys = Nothing
  , execConfigTty = Nothing
  , execConfigEnv = Nothing
  , execConfigCmd = Nothing
  , execConfigPrivileged = Nothing
  , execConfigUser = Nothing
  }

-- ** ExecStartConfig
-- | ExecStartConfig
data ExecStartConfig = ExecStartConfig
  { execStartConfigDetach :: !(Maybe Bool) -- ^ "Detach" - Detach from the command.
  , execStartConfigTty :: !(Maybe Bool) -- ^ "Tty" - Allocate a pseudo-TTY.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExecStartConfig
instance A.FromJSON ExecStartConfig where
  parseJSON = A.withObject "ExecStartConfig" $ \o ->
    ExecStartConfig
      <$> (o .:? "Detach")
      <*> (o .:? "Tty")

-- | ToJSON ExecStartConfig
instance A.ToJSON ExecStartConfig where
  toJSON ExecStartConfig {..} =
   _omitNulls
      [ "Detach" .= execStartConfigDetach
      , "Tty" .= execStartConfigTty
      ]


-- | Construct a value of type 'ExecStartConfig' (by applying it's required fields, if any)
mkExecStartConfig
  :: ExecStartConfig
mkExecStartConfig =
  ExecStartConfig
  { execStartConfigDetach = Nothing
  , execStartConfigTty = Nothing
  }

-- ** GraphDriver
-- | GraphDriver
-- Information about this container's graph driver.
data GraphDriver = GraphDriver
  { graphDriverName :: !(Maybe Text) -- ^ "Name"
  , graphDriverData :: !(Maybe (Map.Map String Text)) -- ^ "Data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GraphDriver
instance A.FromJSON GraphDriver where
  parseJSON = A.withObject "GraphDriver" $ \o ->
    GraphDriver
      <$> (o .:? "Name")
      <*> (o .:? "Data")

-- | ToJSON GraphDriver
instance A.ToJSON GraphDriver where
  toJSON GraphDriver {..} =
   _omitNulls
      [ "Name" .= graphDriverName
      , "Data" .= graphDriverData
      ]


-- | Construct a value of type 'GraphDriver' (by applying it's required fields, if any)
mkGraphDriver
  :: GraphDriver
mkGraphDriver =
  GraphDriver
  { graphDriverName = Nothing
  , graphDriverData = Nothing
  }

-- ** HostConfigLogConfig
-- | HostConfigLogConfig
-- The logging configuration for this container
data HostConfigLogConfig = HostConfigLogConfig
  { hostConfigLogConfigType :: !(Maybe E'Type3) -- ^ "Type"
  , hostConfigLogConfigConfig :: !(Maybe (Map.Map String Text)) -- ^ "Config"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON HostConfigLogConfig
instance A.FromJSON HostConfigLogConfig where
  parseJSON = A.withObject "HostConfigLogConfig" $ \o ->
    HostConfigLogConfig
      <$> (o .:? "Type")
      <*> (o .:? "Config")

-- | ToJSON HostConfigLogConfig
instance A.ToJSON HostConfigLogConfig where
  toJSON HostConfigLogConfig {..} =
   _omitNulls
      [ "Type" .= hostConfigLogConfigType
      , "Config" .= hostConfigLogConfigConfig
      ]


-- | Construct a value of type 'HostConfigLogConfig' (by applying it's required fields, if any)
mkHostConfigLogConfig
  :: HostConfigLogConfig
mkHostConfigLogConfig =
  HostConfigLogConfig
  { hostConfigLogConfigType = Nothing
  , hostConfigLogConfigConfig = Nothing
  }

-- ** HostConfigPortBindings
-- | HostConfigPortBindings
data HostConfigPortBindings = HostConfigPortBindings
  { hostConfigPortBindingsHostIp :: !(Maybe Text) -- ^ "HostIp" - The host IP address
  , hostConfigPortBindingsHostPort :: !(Maybe Text) -- ^ "HostPort" - The host port number, as a string
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON HostConfigPortBindings
instance A.FromJSON HostConfigPortBindings where
  parseJSON = A.withObject "HostConfigPortBindings" $ \o ->
    HostConfigPortBindings
      <$> (o .:? "HostIp")
      <*> (o .:? "HostPort")

-- | ToJSON HostConfigPortBindings
instance A.ToJSON HostConfigPortBindings where
  toJSON HostConfigPortBindings {..} =
   _omitNulls
      [ "HostIp" .= hostConfigPortBindingsHostIp
      , "HostPort" .= hostConfigPortBindingsHostPort
      ]


-- | Construct a value of type 'HostConfigPortBindings' (by applying it's required fields, if any)
mkHostConfigPortBindings
  :: HostConfigPortBindings
mkHostConfigPortBindings =
  HostConfigPortBindings
  { hostConfigPortBindingsHostIp = Nothing
  , hostConfigPortBindingsHostPort = Nothing
  }

-- ** IPAM
-- | IPAM
data IPAM = IPAM
  { iPAMDriver :: !(Maybe Text) -- ^ "Driver" - Name of the IPAM driver to use.
  , iPAMConfig :: !(Maybe [(Map.Map String Text)]) -- ^ "Config" - List of IPAM configuration options, specified as a map: &#x60;{\&quot;Subnet\&quot;: &lt;CIDR&gt;, \&quot;IPRange\&quot;: &lt;CIDR&gt;, \&quot;Gateway\&quot;: &lt;IP address&gt;, \&quot;AuxAddress\&quot;: &lt;device_name:IP address&gt;}&#x60;
  , iPAMOptions :: !(Maybe [(Map.Map String Text)]) -- ^ "Options" - Driver-specific options, specified as a map.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IPAM
instance A.FromJSON IPAM where
  parseJSON = A.withObject "IPAM" $ \o ->
    IPAM
      <$> (o .:? "Driver")
      <*> (o .:? "Config")
      <*> (o .:? "Options")

-- | ToJSON IPAM
instance A.ToJSON IPAM where
  toJSON IPAM {..} =
   _omitNulls
      [ "Driver" .= iPAMDriver
      , "Config" .= iPAMConfig
      , "Options" .= iPAMOptions
      ]


-- | Construct a value of type 'IPAM' (by applying it's required fields, if any)
mkIPAM
  :: IPAM
mkIPAM =
  IPAM
  { iPAMDriver = Nothing
  , iPAMConfig = Nothing
  , iPAMOptions = Nothing
  }

-- ** IdResponse
-- | IdResponse
-- Response to an API call that returns just an Id
data IdResponse = IdResponse
  { idResponseId :: !(Text) -- ^ /Required/ "Id" - The id of the newly created object.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IdResponse
instance A.FromJSON IdResponse where
  parseJSON = A.withObject "IdResponse" $ \o ->
    IdResponse
      <$> (o .:  "Id")

-- | ToJSON IdResponse
instance A.ToJSON IdResponse where
  toJSON IdResponse {..} =
   _omitNulls
      [ "Id" .= idResponseId
      ]


-- | Construct a value of type 'IdResponse' (by applying it's required fields, if any)
mkIdResponse
  :: Text -- ^ 'idResponseId': The id of the newly created object.
  -> IdResponse
mkIdResponse idResponseId =
  IdResponse
  { idResponseId
  }

-- ** Image
-- | Image
data Image = Image
  { imageId :: !(Maybe Text) -- ^ "Id"
  , imageRepoTags :: !(Maybe [Text]) -- ^ "RepoTags"
  , imageRepoDigests :: !(Maybe [Text]) -- ^ "RepoDigests"
  , imageParent :: !(Maybe Text) -- ^ "Parent"
  , imageComment :: !(Maybe Text) -- ^ "Comment"
  , imageCreated :: !(Maybe Text) -- ^ "Created"
  , imageContainer :: !(Maybe Text) -- ^ "Container"
  , imageContainerConfig :: !(Maybe Config) -- ^ "ContainerConfig"
  , imageDockerVersion :: !(Maybe Text) -- ^ "DockerVersion"
  , imageAuthor :: !(Maybe Text) -- ^ "Author"
  , imageConfig :: !(Maybe Config) -- ^ "Config"
  , imageArchitecture :: !(Maybe Text) -- ^ "Architecture"
  , imageOs :: !(Maybe Text) -- ^ "Os"
  , imageSize :: !(Maybe Integer) -- ^ "Size"
  , imageVirtualSize :: !(Maybe Integer) -- ^ "VirtualSize"
  , imageGraphDriver :: !(Maybe GraphDriver) -- ^ "GraphDriver"
  , imageRootFs :: !(Maybe ImageRootFS) -- ^ "RootFS"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Image
instance A.FromJSON Image where
  parseJSON = A.withObject "Image" $ \o ->
    Image
      <$> (o .:? "Id")
      <*> (o .:? "RepoTags")
      <*> (o .:? "RepoDigests")
      <*> (o .:? "Parent")
      <*> (o .:? "Comment")
      <*> (o .:? "Created")
      <*> (o .:? "Container")
      <*> (o .:? "ContainerConfig")
      <*> (o .:? "DockerVersion")
      <*> (o .:? "Author")
      <*> (o .:? "Config")
      <*> (o .:? "Architecture")
      <*> (o .:? "Os")
      <*> (o .:? "Size")
      <*> (o .:? "VirtualSize")
      <*> (o .:? "GraphDriver")
      <*> (o .:? "RootFS")

-- | ToJSON Image
instance A.ToJSON Image where
  toJSON Image {..} =
   _omitNulls
      [ "Id" .= imageId
      , "RepoTags" .= imageRepoTags
      , "RepoDigests" .= imageRepoDigests
      , "Parent" .= imageParent
      , "Comment" .= imageComment
      , "Created" .= imageCreated
      , "Container" .= imageContainer
      , "ContainerConfig" .= imageContainerConfig
      , "DockerVersion" .= imageDockerVersion
      , "Author" .= imageAuthor
      , "Config" .= imageConfig
      , "Architecture" .= imageArchitecture
      , "Os" .= imageOs
      , "Size" .= imageSize
      , "VirtualSize" .= imageVirtualSize
      , "GraphDriver" .= imageGraphDriver
      , "RootFS" .= imageRootFs
      ]


-- | Construct a value of type 'Image' (by applying it's required fields, if any)
mkImage
  :: Image
mkImage =
  Image
  { imageId = Nothing
  , imageRepoTags = Nothing
  , imageRepoDigests = Nothing
  , imageParent = Nothing
  , imageComment = Nothing
  , imageCreated = Nothing
  , imageContainer = Nothing
  , imageContainerConfig = Nothing
  , imageDockerVersion = Nothing
  , imageAuthor = Nothing
  , imageConfig = Nothing
  , imageArchitecture = Nothing
  , imageOs = Nothing
  , imageSize = Nothing
  , imageVirtualSize = Nothing
  , imageGraphDriver = Nothing
  , imageRootFs = Nothing
  }

-- ** ImageDeleteResponse
-- | ImageDeleteResponse
data ImageDeleteResponse = ImageDeleteResponse
  { imageDeleteResponseUntagged :: !(Maybe Text) -- ^ "Untagged" - The image ID of an image that was untagged
  , imageDeleteResponseDeleted :: !(Maybe Text) -- ^ "Deleted" - The image ID of an image that was deleted
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ImageDeleteResponse
instance A.FromJSON ImageDeleteResponse where
  parseJSON = A.withObject "ImageDeleteResponse" $ \o ->
    ImageDeleteResponse
      <$> (o .:? "Untagged")
      <*> (o .:? "Deleted")

-- | ToJSON ImageDeleteResponse
instance A.ToJSON ImageDeleteResponse where
  toJSON ImageDeleteResponse {..} =
   _omitNulls
      [ "Untagged" .= imageDeleteResponseUntagged
      , "Deleted" .= imageDeleteResponseDeleted
      ]


-- | Construct a value of type 'ImageDeleteResponse' (by applying it's required fields, if any)
mkImageDeleteResponse
  :: ImageDeleteResponse
mkImageDeleteResponse =
  ImageDeleteResponse
  { imageDeleteResponseUntagged = Nothing
  , imageDeleteResponseDeleted = Nothing
  }

-- ** ImageRootFS
-- | ImageRootFS
data ImageRootFS = ImageRootFS
  { imageRootFSType :: !(Maybe Text) -- ^ "Type"
  , imageRootFSLayers :: !(Maybe [Text]) -- ^ "Layers"
  , imageRootFSBaseLayer :: !(Maybe Text) -- ^ "BaseLayer"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ImageRootFS
instance A.FromJSON ImageRootFS where
  parseJSON = A.withObject "ImageRootFS" $ \o ->
    ImageRootFS
      <$> (o .:? "Type")
      <*> (o .:? "Layers")
      <*> (o .:? "BaseLayer")

-- | ToJSON ImageRootFS
instance A.ToJSON ImageRootFS where
  toJSON ImageRootFS {..} =
   _omitNulls
      [ "Type" .= imageRootFSType
      , "Layers" .= imageRootFSLayers
      , "BaseLayer" .= imageRootFSBaseLayer
      ]


-- | Construct a value of type 'ImageRootFS' (by applying it's required fields, if any)
mkImageRootFS
  :: ImageRootFS
mkImageRootFS =
  ImageRootFS
  { imageRootFSType = Nothing
  , imageRootFSLayers = Nothing
  , imageRootFSBaseLayer = Nothing
  }

-- ** ImageSummary
-- | ImageSummary
data ImageSummary = ImageSummary
  { imageSummaryId :: !(Text) -- ^ /Required/ "Id"
  , imageSummaryParentId :: !(Text) -- ^ /Required/ "ParentId"
  , imageSummaryRepoTags :: !([Text]) -- ^ /Required/ "RepoTags"
  , imageSummaryRepoDigests :: !([Text]) -- ^ /Required/ "RepoDigests"
  , imageSummaryCreated :: !(Int) -- ^ /Required/ "Created"
  , imageSummarySize :: !(Int) -- ^ /Required/ "Size"
  , imageSummarySharedSize :: !(Int) -- ^ /Required/ "SharedSize"
  , imageSummaryVirtualSize :: !(Int) -- ^ /Required/ "VirtualSize"
  , imageSummaryLabels :: !((Map.Map String Text)) -- ^ /Required/ "Labels"
  , imageSummaryContainers :: !(Int) -- ^ /Required/ "Containers"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ImageSummary
instance A.FromJSON ImageSummary where
  parseJSON = A.withObject "ImageSummary" $ \o ->
    ImageSummary
      <$> (o .:  "Id")
      <*> (o .:  "ParentId")
      <*> (o .:  "RepoTags")
      <*> (o .:  "RepoDigests")
      <*> (o .:  "Created")
      <*> (o .:  "Size")
      <*> (o .:  "SharedSize")
      <*> (o .:  "VirtualSize")
      <*> (o .:  "Labels")
      <*> (o .:  "Containers")

-- | ToJSON ImageSummary
instance A.ToJSON ImageSummary where
  toJSON ImageSummary {..} =
   _omitNulls
      [ "Id" .= imageSummaryId
      , "ParentId" .= imageSummaryParentId
      , "RepoTags" .= imageSummaryRepoTags
      , "RepoDigests" .= imageSummaryRepoDigests
      , "Created" .= imageSummaryCreated
      , "Size" .= imageSummarySize
      , "SharedSize" .= imageSummarySharedSize
      , "VirtualSize" .= imageSummaryVirtualSize
      , "Labels" .= imageSummaryLabels
      , "Containers" .= imageSummaryContainers
      ]


-- | Construct a value of type 'ImageSummary' (by applying it's required fields, if any)
mkImageSummary
  :: Text -- ^ 'imageSummaryId' 
  -> Text -- ^ 'imageSummaryParentId' 
  -> [Text] -- ^ 'imageSummaryRepoTags' 
  -> [Text] -- ^ 'imageSummaryRepoDigests' 
  -> Int -- ^ 'imageSummaryCreated' 
  -> Int -- ^ 'imageSummarySize' 
  -> Int -- ^ 'imageSummarySharedSize' 
  -> Int -- ^ 'imageSummaryVirtualSize' 
  -> (Map.Map String Text) -- ^ 'imageSummaryLabels' 
  -> Int -- ^ 'imageSummaryContainers' 
  -> ImageSummary
mkImageSummary imageSummaryId imageSummaryParentId imageSummaryRepoTags imageSummaryRepoDigests imageSummaryCreated imageSummarySize imageSummarySharedSize imageSummaryVirtualSize imageSummaryLabels imageSummaryContainers =
  ImageSummary
  { imageSummaryId
  , imageSummaryParentId
  , imageSummaryRepoTags
  , imageSummaryRepoDigests
  , imageSummaryCreated
  , imageSummarySize
  , imageSummarySharedSize
  , imageSummaryVirtualSize
  , imageSummaryLabels
  , imageSummaryContainers
  }

-- ** InlineResponse200
-- | InlineResponse200
data InlineResponse200 = InlineResponse200
  { inlineResponse200Id :: !(Maybe Text) -- ^ "Id" - The ID of the container
  , inlineResponse200Created :: !(Maybe Text) -- ^ "Created" - The time the container was created
  , inlineResponse200Path :: !(Maybe Text) -- ^ "Path" - The path to the command being run
  , inlineResponse200Args :: !(Maybe [Text]) -- ^ "Args" - The arguments to the command being run
  , inlineResponse200State :: !(Maybe InlineResponse200State) -- ^ "State"
  , inlineResponse200Image :: !(Maybe Text) -- ^ "Image" - The container&#39;s image
  , inlineResponse200ResolvConfPath :: !(Maybe Text) -- ^ "ResolvConfPath"
  , inlineResponse200HostnamePath :: !(Maybe Text) -- ^ "HostnamePath"
  , inlineResponse200HostsPath :: !(Maybe Text) -- ^ "HostsPath"
  , inlineResponse200LogPath :: !(Maybe Text) -- ^ "LogPath"
  , inlineResponse200Node :: !(Maybe A.Value) -- ^ "Node" - TODO
  , inlineResponse200Name :: !(Maybe Text) -- ^ "Name"
  , inlineResponse200RestartCount :: !(Maybe Int) -- ^ "RestartCount"
  , inlineResponse200Driver :: !(Maybe Text) -- ^ "Driver"
  , inlineResponse200MountLabel :: !(Maybe Text) -- ^ "MountLabel"
  , inlineResponse200ProcessLabel :: !(Maybe Text) -- ^ "ProcessLabel"
  , inlineResponse200AppArmorProfile :: !(Maybe Text) -- ^ "AppArmorProfile"
  , inlineResponse200ExecIDs :: !(Maybe Text) -- ^ "ExecIDs"
  , inlineResponse200HostConfig :: !(Maybe HostConfig) -- ^ "HostConfig"
  , inlineResponse200GraphDriver :: !(Maybe GraphDriver) -- ^ "GraphDriver"
  , inlineResponse200SizeRw :: !(Maybe Integer) -- ^ "SizeRw" - The size of files that have been created or changed by this container.
  , inlineResponse200SizeRootFs :: !(Maybe Integer) -- ^ "SizeRootFs" - The total size of all the files in this container.
  , inlineResponse200Mounts :: !(Maybe [MountPoint]) -- ^ "Mounts"
  , inlineResponse200Config :: !(Maybe Config) -- ^ "Config"
  , inlineResponse200NetworkSettings :: !(Maybe NetworkConfig) -- ^ "NetworkSettings"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse200
instance A.FromJSON InlineResponse200 where
  parseJSON = A.withObject "InlineResponse200" $ \o ->
    InlineResponse200
      <$> (o .:? "Id")
      <*> (o .:? "Created")
      <*> (o .:? "Path")
      <*> (o .:? "Args")
      <*> (o .:? "State")
      <*> (o .:? "Image")
      <*> (o .:? "ResolvConfPath")
      <*> (o .:? "HostnamePath")
      <*> (o .:? "HostsPath")
      <*> (o .:? "LogPath")
      <*> (o .:? "Node")
      <*> (o .:? "Name")
      <*> (o .:? "RestartCount")
      <*> (o .:? "Driver")
      <*> (o .:? "MountLabel")
      <*> (o .:? "ProcessLabel")
      <*> (o .:? "AppArmorProfile")
      <*> (o .:? "ExecIDs")
      <*> (o .:? "HostConfig")
      <*> (o .:? "GraphDriver")
      <*> (o .:? "SizeRw")
      <*> (o .:? "SizeRootFs")
      <*> (o .:? "Mounts")
      <*> (o .:? "Config")
      <*> (o .:? "NetworkSettings")

-- | ToJSON InlineResponse200
instance A.ToJSON InlineResponse200 where
  toJSON InlineResponse200 {..} =
   _omitNulls
      [ "Id" .= inlineResponse200Id
      , "Created" .= inlineResponse200Created
      , "Path" .= inlineResponse200Path
      , "Args" .= inlineResponse200Args
      , "State" .= inlineResponse200State
      , "Image" .= inlineResponse200Image
      , "ResolvConfPath" .= inlineResponse200ResolvConfPath
      , "HostnamePath" .= inlineResponse200HostnamePath
      , "HostsPath" .= inlineResponse200HostsPath
      , "LogPath" .= inlineResponse200LogPath
      , "Node" .= inlineResponse200Node
      , "Name" .= inlineResponse200Name
      , "RestartCount" .= inlineResponse200RestartCount
      , "Driver" .= inlineResponse200Driver
      , "MountLabel" .= inlineResponse200MountLabel
      , "ProcessLabel" .= inlineResponse200ProcessLabel
      , "AppArmorProfile" .= inlineResponse200AppArmorProfile
      , "ExecIDs" .= inlineResponse200ExecIDs
      , "HostConfig" .= inlineResponse200HostConfig
      , "GraphDriver" .= inlineResponse200GraphDriver
      , "SizeRw" .= inlineResponse200SizeRw
      , "SizeRootFs" .= inlineResponse200SizeRootFs
      , "Mounts" .= inlineResponse200Mounts
      , "Config" .= inlineResponse200Config
      , "NetworkSettings" .= inlineResponse200NetworkSettings
      ]


-- | Construct a value of type 'InlineResponse200' (by applying it's required fields, if any)
mkInlineResponse200
  :: InlineResponse200
mkInlineResponse200 =
  InlineResponse200
  { inlineResponse200Id = Nothing
  , inlineResponse200Created = Nothing
  , inlineResponse200Path = Nothing
  , inlineResponse200Args = Nothing
  , inlineResponse200State = Nothing
  , inlineResponse200Image = Nothing
  , inlineResponse200ResolvConfPath = Nothing
  , inlineResponse200HostnamePath = Nothing
  , inlineResponse200HostsPath = Nothing
  , inlineResponse200LogPath = Nothing
  , inlineResponse200Node = Nothing
  , inlineResponse200Name = Nothing
  , inlineResponse200RestartCount = Nothing
  , inlineResponse200Driver = Nothing
  , inlineResponse200MountLabel = Nothing
  , inlineResponse200ProcessLabel = Nothing
  , inlineResponse200AppArmorProfile = Nothing
  , inlineResponse200ExecIDs = Nothing
  , inlineResponse200HostConfig = Nothing
  , inlineResponse200GraphDriver = Nothing
  , inlineResponse200SizeRw = Nothing
  , inlineResponse200SizeRootFs = Nothing
  , inlineResponse200Mounts = Nothing
  , inlineResponse200Config = Nothing
  , inlineResponse200NetworkSettings = Nothing
  }

-- ** InlineResponse2001
-- | InlineResponse2001
data InlineResponse2001 = InlineResponse2001
  { inlineResponse2001Titles :: !(Maybe [Text]) -- ^ "Titles" - The ps column titles
  , inlineResponse2001Processes :: !(Maybe [[Text]]) -- ^ "Processes" - Each process running in the container, where each is process is an array of values corresponding to the titles
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2001
instance A.FromJSON InlineResponse2001 where
  parseJSON = A.withObject "InlineResponse2001" $ \o ->
    InlineResponse2001
      <$> (o .:? "Titles")
      <*> (o .:? "Processes")

-- | ToJSON InlineResponse2001
instance A.ToJSON InlineResponse2001 where
  toJSON InlineResponse2001 {..} =
   _omitNulls
      [ "Titles" .= inlineResponse2001Titles
      , "Processes" .= inlineResponse2001Processes
      ]


-- | Construct a value of type 'InlineResponse2001' (by applying it's required fields, if any)
mkInlineResponse2001
  :: InlineResponse2001
mkInlineResponse2001 =
  InlineResponse2001
  { inlineResponse2001Titles = Nothing
  , inlineResponse2001Processes = Nothing
  }

-- ** InlineResponse20010
-- | InlineResponse20010
data InlineResponse20010 = InlineResponse20010
  { inlineResponse20010Architecture :: !(Maybe Text) -- ^ "Architecture"
  , inlineResponse20010Containers :: !(Maybe Int) -- ^ "Containers"
  , inlineResponse20010ContainersRunning :: !(Maybe Int) -- ^ "ContainersRunning"
  , inlineResponse20010ContainersStopped :: !(Maybe Int) -- ^ "ContainersStopped"
  , inlineResponse20010ContainersPaused :: !(Maybe Int) -- ^ "ContainersPaused"
  , inlineResponse20010CpuCfsPeriod :: !(Maybe Bool) -- ^ "CpuCfsPeriod"
  , inlineResponse20010CpuCfsQuota :: !(Maybe Bool) -- ^ "CpuCfsQuota"
  , inlineResponse20010Debug :: !(Maybe Bool) -- ^ "Debug"
  , inlineResponse20010DiscoveryBackend :: !(Maybe Text) -- ^ "DiscoveryBackend"
  , inlineResponse20010DockerRootDir :: !(Maybe Text) -- ^ "DockerRootDir"
  , inlineResponse20010Driver :: !(Maybe Text) -- ^ "Driver"
  , inlineResponse20010DriverStatus :: !(Maybe [[Text]]) -- ^ "DriverStatus"
  , inlineResponse20010SystemStatus :: !(Maybe [[Text]]) -- ^ "SystemStatus"
  , inlineResponse20010Plugins :: !(Maybe InlineResponse20010Plugins) -- ^ "Plugins"
  , inlineResponse20010ExperimentalBuild :: !(Maybe Bool) -- ^ "ExperimentalBuild"
  , inlineResponse20010HttpProxy :: !(Maybe Text) -- ^ "HttpProxy"
  , inlineResponse20010HttpsProxy :: !(Maybe Text) -- ^ "HttpsProxy"
  , inlineResponse20010Id :: !(Maybe Text) -- ^ "ID"
  , inlineResponse20010IPv4Forwarding :: !(Maybe Bool) -- ^ "IPv4Forwarding"
  , inlineResponse20010Images :: !(Maybe Int) -- ^ "Images"
  , inlineResponse20010IndexServerAddress :: !(Maybe Text) -- ^ "IndexServerAddress"
  , inlineResponse20010InitPath :: !(Maybe Text) -- ^ "InitPath"
  , inlineResponse20010InitSha1 :: !(Maybe Text) -- ^ "InitSha1"
  , inlineResponse20010KernelVersion :: !(Maybe Text) -- ^ "KernelVersion"
  , inlineResponse20010Labels :: !(Maybe [Text]) -- ^ "Labels"
  , inlineResponse20010MemTotal :: !(Maybe Int) -- ^ "MemTotal"
  , inlineResponse20010MemoryLimit :: !(Maybe Bool) -- ^ "MemoryLimit"
  , inlineResponse20010Ncpu :: !(Maybe Int) -- ^ "NCPU"
  , inlineResponse20010NEventsListener :: !(Maybe Int) -- ^ "NEventsListener"
  , inlineResponse20010NFd :: !(Maybe Int) -- ^ "NFd"
  , inlineResponse20010NGoroutines :: !(Maybe Int) -- ^ "NGoroutines"
  , inlineResponse20010Name :: !(Maybe Text) -- ^ "Name"
  , inlineResponse20010NoProxy :: !(Maybe Text) -- ^ "NoProxy"
  , inlineResponse20010OomKillDisable :: !(Maybe Bool) -- ^ "OomKillDisable"
  , inlineResponse20010OsType :: !(Maybe Text) -- ^ "OSType"
  , inlineResponse20010OomScoreAdj :: !(Maybe Int) -- ^ "OomScoreAdj"
  , inlineResponse20010OperatingSystem :: !(Maybe Text) -- ^ "OperatingSystem"
  , inlineResponse20010RegistryConfig :: !(Maybe InlineResponse20010RegistryConfig) -- ^ "RegistryConfig"
  , inlineResponse20010SwapLimit :: !(Maybe Bool) -- ^ "SwapLimit"
  , inlineResponse20010SystemTime :: !(Maybe Text) -- ^ "SystemTime"
  , inlineResponse20010ServerVersion :: !(Maybe Text) -- ^ "ServerVersion"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20010
instance A.FromJSON InlineResponse20010 where
  parseJSON = A.withObject "InlineResponse20010" $ \o ->
    InlineResponse20010
      <$> (o .:? "Architecture")
      <*> (o .:? "Containers")
      <*> (o .:? "ContainersRunning")
      <*> (o .:? "ContainersStopped")
      <*> (o .:? "ContainersPaused")
      <*> (o .:? "CpuCfsPeriod")
      <*> (o .:? "CpuCfsQuota")
      <*> (o .:? "Debug")
      <*> (o .:? "DiscoveryBackend")
      <*> (o .:? "DockerRootDir")
      <*> (o .:? "Driver")
      <*> (o .:? "DriverStatus")
      <*> (o .:? "SystemStatus")
      <*> (o .:? "Plugins")
      <*> (o .:? "ExperimentalBuild")
      <*> (o .:? "HttpProxy")
      <*> (o .:? "HttpsProxy")
      <*> (o .:? "ID")
      <*> (o .:? "IPv4Forwarding")
      <*> (o .:? "Images")
      <*> (o .:? "IndexServerAddress")
      <*> (o .:? "InitPath")
      <*> (o .:? "InitSha1")
      <*> (o .:? "KernelVersion")
      <*> (o .:? "Labels")
      <*> (o .:? "MemTotal")
      <*> (o .:? "MemoryLimit")
      <*> (o .:? "NCPU")
      <*> (o .:? "NEventsListener")
      <*> (o .:? "NFd")
      <*> (o .:? "NGoroutines")
      <*> (o .:? "Name")
      <*> (o .:? "NoProxy")
      <*> (o .:? "OomKillDisable")
      <*> (o .:? "OSType")
      <*> (o .:? "OomScoreAdj")
      <*> (o .:? "OperatingSystem")
      <*> (o .:? "RegistryConfig")
      <*> (o .:? "SwapLimit")
      <*> (o .:? "SystemTime")
      <*> (o .:? "ServerVersion")

-- | ToJSON InlineResponse20010
instance A.ToJSON InlineResponse20010 where
  toJSON InlineResponse20010 {..} =
   _omitNulls
      [ "Architecture" .= inlineResponse20010Architecture
      , "Containers" .= inlineResponse20010Containers
      , "ContainersRunning" .= inlineResponse20010ContainersRunning
      , "ContainersStopped" .= inlineResponse20010ContainersStopped
      , "ContainersPaused" .= inlineResponse20010ContainersPaused
      , "CpuCfsPeriod" .= inlineResponse20010CpuCfsPeriod
      , "CpuCfsQuota" .= inlineResponse20010CpuCfsQuota
      , "Debug" .= inlineResponse20010Debug
      , "DiscoveryBackend" .= inlineResponse20010DiscoveryBackend
      , "DockerRootDir" .= inlineResponse20010DockerRootDir
      , "Driver" .= inlineResponse20010Driver
      , "DriverStatus" .= inlineResponse20010DriverStatus
      , "SystemStatus" .= inlineResponse20010SystemStatus
      , "Plugins" .= inlineResponse20010Plugins
      , "ExperimentalBuild" .= inlineResponse20010ExperimentalBuild
      , "HttpProxy" .= inlineResponse20010HttpProxy
      , "HttpsProxy" .= inlineResponse20010HttpsProxy
      , "ID" .= inlineResponse20010Id
      , "IPv4Forwarding" .= inlineResponse20010IPv4Forwarding
      , "Images" .= inlineResponse20010Images
      , "IndexServerAddress" .= inlineResponse20010IndexServerAddress
      , "InitPath" .= inlineResponse20010InitPath
      , "InitSha1" .= inlineResponse20010InitSha1
      , "KernelVersion" .= inlineResponse20010KernelVersion
      , "Labels" .= inlineResponse20010Labels
      , "MemTotal" .= inlineResponse20010MemTotal
      , "MemoryLimit" .= inlineResponse20010MemoryLimit
      , "NCPU" .= inlineResponse20010Ncpu
      , "NEventsListener" .= inlineResponse20010NEventsListener
      , "NFd" .= inlineResponse20010NFd
      , "NGoroutines" .= inlineResponse20010NGoroutines
      , "Name" .= inlineResponse20010Name
      , "NoProxy" .= inlineResponse20010NoProxy
      , "OomKillDisable" .= inlineResponse20010OomKillDisable
      , "OSType" .= inlineResponse20010OsType
      , "OomScoreAdj" .= inlineResponse20010OomScoreAdj
      , "OperatingSystem" .= inlineResponse20010OperatingSystem
      , "RegistryConfig" .= inlineResponse20010RegistryConfig
      , "SwapLimit" .= inlineResponse20010SwapLimit
      , "SystemTime" .= inlineResponse20010SystemTime
      , "ServerVersion" .= inlineResponse20010ServerVersion
      ]


-- | Construct a value of type 'InlineResponse20010' (by applying it's required fields, if any)
mkInlineResponse20010
  :: InlineResponse20010
mkInlineResponse20010 =
  InlineResponse20010
  { inlineResponse20010Architecture = Nothing
  , inlineResponse20010Containers = Nothing
  , inlineResponse20010ContainersRunning = Nothing
  , inlineResponse20010ContainersStopped = Nothing
  , inlineResponse20010ContainersPaused = Nothing
  , inlineResponse20010CpuCfsPeriod = Nothing
  , inlineResponse20010CpuCfsQuota = Nothing
  , inlineResponse20010Debug = Nothing
  , inlineResponse20010DiscoveryBackend = Nothing
  , inlineResponse20010DockerRootDir = Nothing
  , inlineResponse20010Driver = Nothing
  , inlineResponse20010DriverStatus = Nothing
  , inlineResponse20010SystemStatus = Nothing
  , inlineResponse20010Plugins = Nothing
  , inlineResponse20010ExperimentalBuild = Nothing
  , inlineResponse20010HttpProxy = Nothing
  , inlineResponse20010HttpsProxy = Nothing
  , inlineResponse20010Id = Nothing
  , inlineResponse20010IPv4Forwarding = Nothing
  , inlineResponse20010Images = Nothing
  , inlineResponse20010IndexServerAddress = Nothing
  , inlineResponse20010InitPath = Nothing
  , inlineResponse20010InitSha1 = Nothing
  , inlineResponse20010KernelVersion = Nothing
  , inlineResponse20010Labels = Nothing
  , inlineResponse20010MemTotal = Nothing
  , inlineResponse20010MemoryLimit = Nothing
  , inlineResponse20010Ncpu = Nothing
  , inlineResponse20010NEventsListener = Nothing
  , inlineResponse20010NFd = Nothing
  , inlineResponse20010NGoroutines = Nothing
  , inlineResponse20010Name = Nothing
  , inlineResponse20010NoProxy = Nothing
  , inlineResponse20010OomKillDisable = Nothing
  , inlineResponse20010OsType = Nothing
  , inlineResponse20010OomScoreAdj = Nothing
  , inlineResponse20010OperatingSystem = Nothing
  , inlineResponse20010RegistryConfig = Nothing
  , inlineResponse20010SwapLimit = Nothing
  , inlineResponse20010SystemTime = Nothing
  , inlineResponse20010ServerVersion = Nothing
  }

-- ** InlineResponse20010Plugins
-- | InlineResponse20010Plugins
data InlineResponse20010Plugins = InlineResponse20010Plugins
  { inlineResponse20010PluginsVolume :: !(Maybe [Text]) -- ^ "Volume"
  , inlineResponse20010PluginsNetwork :: !(Maybe [Text]) -- ^ "Network"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20010Plugins
instance A.FromJSON InlineResponse20010Plugins where
  parseJSON = A.withObject "InlineResponse20010Plugins" $ \o ->
    InlineResponse20010Plugins
      <$> (o .:? "Volume")
      <*> (o .:? "Network")

-- | ToJSON InlineResponse20010Plugins
instance A.ToJSON InlineResponse20010Plugins where
  toJSON InlineResponse20010Plugins {..} =
   _omitNulls
      [ "Volume" .= inlineResponse20010PluginsVolume
      , "Network" .= inlineResponse20010PluginsNetwork
      ]


-- | Construct a value of type 'InlineResponse20010Plugins' (by applying it's required fields, if any)
mkInlineResponse20010Plugins
  :: InlineResponse20010Plugins
mkInlineResponse20010Plugins =
  InlineResponse20010Plugins
  { inlineResponse20010PluginsVolume = Nothing
  , inlineResponse20010PluginsNetwork = Nothing
  }

-- ** InlineResponse20010RegistryConfig
-- | InlineResponse20010RegistryConfig
data InlineResponse20010RegistryConfig = InlineResponse20010RegistryConfig
  { inlineResponse20010RegistryConfigIndexConfigs :: !(Maybe (Map.Map String InlineResponse20010RegistryConfigIndexConfigs)) -- ^ "IndexConfigs"
  , inlineResponse20010RegistryConfigInsecureRegistryCidRs :: !(Maybe [Text]) -- ^ "InsecureRegistryCIDRs"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20010RegistryConfig
instance A.FromJSON InlineResponse20010RegistryConfig where
  parseJSON = A.withObject "InlineResponse20010RegistryConfig" $ \o ->
    InlineResponse20010RegistryConfig
      <$> (o .:? "IndexConfigs")
      <*> (o .:? "InsecureRegistryCIDRs")

-- | ToJSON InlineResponse20010RegistryConfig
instance A.ToJSON InlineResponse20010RegistryConfig where
  toJSON InlineResponse20010RegistryConfig {..} =
   _omitNulls
      [ "IndexConfigs" .= inlineResponse20010RegistryConfigIndexConfigs
      , "InsecureRegistryCIDRs" .= inlineResponse20010RegistryConfigInsecureRegistryCidRs
      ]


-- | Construct a value of type 'InlineResponse20010RegistryConfig' (by applying it's required fields, if any)
mkInlineResponse20010RegistryConfig
  :: InlineResponse20010RegistryConfig
mkInlineResponse20010RegistryConfig =
  InlineResponse20010RegistryConfig
  { inlineResponse20010RegistryConfigIndexConfigs = Nothing
  , inlineResponse20010RegistryConfigInsecureRegistryCidRs = Nothing
  }

-- ** InlineResponse20010RegistryConfigIndexConfigs
-- | InlineResponse20010RegistryConfigIndexConfigs
data InlineResponse20010RegistryConfigIndexConfigs = InlineResponse20010RegistryConfigIndexConfigs
  { inlineResponse20010RegistryConfigIndexConfigsMirrors :: !(Maybe [Text]) -- ^ "Mirrors"
  , inlineResponse20010RegistryConfigIndexConfigsName :: !(Maybe Text) -- ^ "Name"
  , inlineResponse20010RegistryConfigIndexConfigsOfficial :: !(Maybe Bool) -- ^ "Official"
  , inlineResponse20010RegistryConfigIndexConfigsSecure :: !(Maybe Bool) -- ^ "Secure"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20010RegistryConfigIndexConfigs
instance A.FromJSON InlineResponse20010RegistryConfigIndexConfigs where
  parseJSON = A.withObject "InlineResponse20010RegistryConfigIndexConfigs" $ \o ->
    InlineResponse20010RegistryConfigIndexConfigs
      <$> (o .:? "Mirrors")
      <*> (o .:? "Name")
      <*> (o .:? "Official")
      <*> (o .:? "Secure")

-- | ToJSON InlineResponse20010RegistryConfigIndexConfigs
instance A.ToJSON InlineResponse20010RegistryConfigIndexConfigs where
  toJSON InlineResponse20010RegistryConfigIndexConfigs {..} =
   _omitNulls
      [ "Mirrors" .= inlineResponse20010RegistryConfigIndexConfigsMirrors
      , "Name" .= inlineResponse20010RegistryConfigIndexConfigsName
      , "Official" .= inlineResponse20010RegistryConfigIndexConfigsOfficial
      , "Secure" .= inlineResponse20010RegistryConfigIndexConfigsSecure
      ]


-- | Construct a value of type 'InlineResponse20010RegistryConfigIndexConfigs' (by applying it's required fields, if any)
mkInlineResponse20010RegistryConfigIndexConfigs
  :: InlineResponse20010RegistryConfigIndexConfigs
mkInlineResponse20010RegistryConfigIndexConfigs =
  InlineResponse20010RegistryConfigIndexConfigs
  { inlineResponse20010RegistryConfigIndexConfigsMirrors = Nothing
  , inlineResponse20010RegistryConfigIndexConfigsName = Nothing
  , inlineResponse20010RegistryConfigIndexConfigsOfficial = Nothing
  , inlineResponse20010RegistryConfigIndexConfigsSecure = Nothing
  }

-- ** InlineResponse20011
-- | InlineResponse20011
data InlineResponse20011 = InlineResponse20011
  { inlineResponse20011Version :: !(Maybe Text) -- ^ "Version"
  , inlineResponse20011ApiVersion :: !(Maybe Text) -- ^ "ApiVersion"
  , inlineResponse20011MinApiVersion :: !(Maybe Text) -- ^ "MinAPIVersion"
  , inlineResponse20011GitCommit :: !(Maybe Text) -- ^ "GitCommit"
  , inlineResponse20011GoVersion :: !(Maybe Text) -- ^ "GoVersion"
  , inlineResponse20011Os :: !(Maybe Text) -- ^ "Os"
  , inlineResponse20011Arch :: !(Maybe Text) -- ^ "Arch"
  , inlineResponse20011KernelVersion :: !(Maybe Text) -- ^ "KernelVersion"
  , inlineResponse20011Experimental :: !(Maybe Bool) -- ^ "Experimental"
  , inlineResponse20011BuildTime :: !(Maybe Text) -- ^ "BuildTime"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20011
instance A.FromJSON InlineResponse20011 where
  parseJSON = A.withObject "InlineResponse20011" $ \o ->
    InlineResponse20011
      <$> (o .:? "Version")
      <*> (o .:? "ApiVersion")
      <*> (o .:? "MinAPIVersion")
      <*> (o .:? "GitCommit")
      <*> (o .:? "GoVersion")
      <*> (o .:? "Os")
      <*> (o .:? "Arch")
      <*> (o .:? "KernelVersion")
      <*> (o .:? "Experimental")
      <*> (o .:? "BuildTime")

-- | ToJSON InlineResponse20011
instance A.ToJSON InlineResponse20011 where
  toJSON InlineResponse20011 {..} =
   _omitNulls
      [ "Version" .= inlineResponse20011Version
      , "ApiVersion" .= inlineResponse20011ApiVersion
      , "MinAPIVersion" .= inlineResponse20011MinApiVersion
      , "GitCommit" .= inlineResponse20011GitCommit
      , "GoVersion" .= inlineResponse20011GoVersion
      , "Os" .= inlineResponse20011Os
      , "Arch" .= inlineResponse20011Arch
      , "KernelVersion" .= inlineResponse20011KernelVersion
      , "Experimental" .= inlineResponse20011Experimental
      , "BuildTime" .= inlineResponse20011BuildTime
      ]


-- | Construct a value of type 'InlineResponse20011' (by applying it's required fields, if any)
mkInlineResponse20011
  :: InlineResponse20011
mkInlineResponse20011 =
  InlineResponse20011
  { inlineResponse20011Version = Nothing
  , inlineResponse20011ApiVersion = Nothing
  , inlineResponse20011MinApiVersion = Nothing
  , inlineResponse20011GitCommit = Nothing
  , inlineResponse20011GoVersion = Nothing
  , inlineResponse20011Os = Nothing
  , inlineResponse20011Arch = Nothing
  , inlineResponse20011KernelVersion = Nothing
  , inlineResponse20011Experimental = Nothing
  , inlineResponse20011BuildTime = Nothing
  }

-- ** InlineResponse20012
-- | InlineResponse20012
data InlineResponse20012 = InlineResponse20012
  { inlineResponse20012Type :: !(Maybe Text) -- ^ "Type" - The type of object emitting the event
  , inlineResponse20012Action :: !(Maybe Text) -- ^ "Action" - The type of event
  , inlineResponse20012Actor :: !(Maybe InlineResponse20012Actor) -- ^ "Actor"
  , inlineResponse20012Time :: !(Maybe Int) -- ^ "time" - Timestamp of event
  , inlineResponse20012TimeNano :: !(Maybe Integer) -- ^ "timeNano" - Timestamp of event, with nanosecond accuracy
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20012
instance A.FromJSON InlineResponse20012 where
  parseJSON = A.withObject "InlineResponse20012" $ \o ->
    InlineResponse20012
      <$> (o .:? "Type")
      <*> (o .:? "Action")
      <*> (o .:? "Actor")
      <*> (o .:? "time")
      <*> (o .:? "timeNano")

-- | ToJSON InlineResponse20012
instance A.ToJSON InlineResponse20012 where
  toJSON InlineResponse20012 {..} =
   _omitNulls
      [ "Type" .= inlineResponse20012Type
      , "Action" .= inlineResponse20012Action
      , "Actor" .= inlineResponse20012Actor
      , "time" .= inlineResponse20012Time
      , "timeNano" .= inlineResponse20012TimeNano
      ]


-- | Construct a value of type 'InlineResponse20012' (by applying it's required fields, if any)
mkInlineResponse20012
  :: InlineResponse20012
mkInlineResponse20012 =
  InlineResponse20012
  { inlineResponse20012Type = Nothing
  , inlineResponse20012Action = Nothing
  , inlineResponse20012Actor = Nothing
  , inlineResponse20012Time = Nothing
  , inlineResponse20012TimeNano = Nothing
  }

-- ** InlineResponse20012Actor
-- | InlineResponse20012Actor
data InlineResponse20012Actor = InlineResponse20012Actor
  { inlineResponse20012ActorId :: !(Maybe Text) -- ^ "ID" - The ID of the object emitting the event
  , inlineResponse20012ActorAttributes :: !(Maybe (Map.Map String Text)) -- ^ "Attributes" - Various key/value attributes of the object, depending on its type
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20012Actor
instance A.FromJSON InlineResponse20012Actor where
  parseJSON = A.withObject "InlineResponse20012Actor" $ \o ->
    InlineResponse20012Actor
      <$> (o .:? "ID")
      <*> (o .:? "Attributes")

-- | ToJSON InlineResponse20012Actor
instance A.ToJSON InlineResponse20012Actor where
  toJSON InlineResponse20012Actor {..} =
   _omitNulls
      [ "ID" .= inlineResponse20012ActorId
      , "Attributes" .= inlineResponse20012ActorAttributes
      ]


-- | Construct a value of type 'InlineResponse20012Actor' (by applying it's required fields, if any)
mkInlineResponse20012Actor
  :: InlineResponse20012Actor
mkInlineResponse20012Actor =
  InlineResponse20012Actor
  { inlineResponse20012ActorId = Nothing
  , inlineResponse20012ActorAttributes = Nothing
  }

-- ** InlineResponse20013
-- | InlineResponse20013
data InlineResponse20013 = InlineResponse20013
  { inlineResponse20013LayersSize :: !(Maybe Integer) -- ^ "LayersSize"
  , inlineResponse20013Images :: !(Maybe [ImageSummary]) -- ^ "Images"
  , inlineResponse20013Containers :: !(Maybe [ContainerSummary]) -- ^ "Containers"
  , inlineResponse20013Volumes :: !(Maybe [Volume]) -- ^ "Volumes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20013
instance A.FromJSON InlineResponse20013 where
  parseJSON = A.withObject "InlineResponse20013" $ \o ->
    InlineResponse20013
      <$> (o .:? "LayersSize")
      <*> (o .:? "Images")
      <*> (o .:? "Containers")
      <*> (o .:? "Volumes")

-- | ToJSON InlineResponse20013
instance A.ToJSON InlineResponse20013 where
  toJSON InlineResponse20013 {..} =
   _omitNulls
      [ "LayersSize" .= inlineResponse20013LayersSize
      , "Images" .= inlineResponse20013Images
      , "Containers" .= inlineResponse20013Containers
      , "Volumes" .= inlineResponse20013Volumes
      ]


-- | Construct a value of type 'InlineResponse20013' (by applying it's required fields, if any)
mkInlineResponse20013
  :: InlineResponse20013
mkInlineResponse20013 =
  InlineResponse20013
  { inlineResponse20013LayersSize = Nothing
  , inlineResponse20013Images = Nothing
  , inlineResponse20013Containers = Nothing
  , inlineResponse20013Volumes = Nothing
  }

-- ** InlineResponse20014
-- | InlineResponse20014
data InlineResponse20014 = InlineResponse20014
  { inlineResponse20014Id :: !(Maybe Text) -- ^ "ID"
  , inlineResponse20014Running :: !(Maybe Bool) -- ^ "Running"
  , inlineResponse20014ExitCode :: !(Maybe Int) -- ^ "ExitCode"
  , inlineResponse20014ProcessConfig :: !(Maybe ProcessConfig) -- ^ "ProcessConfig"
  , inlineResponse20014OpenStdin :: !(Maybe Bool) -- ^ "OpenStdin"
  , inlineResponse20014OpenStderr :: !(Maybe Bool) -- ^ "OpenStderr"
  , inlineResponse20014OpenStdout :: !(Maybe Bool) -- ^ "OpenStdout"
  , inlineResponse20014ContainerId :: !(Maybe Text) -- ^ "ContainerID"
  , inlineResponse20014Pid :: !(Maybe Int) -- ^ "Pid" - The system process ID for the exec process.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20014
instance A.FromJSON InlineResponse20014 where
  parseJSON = A.withObject "InlineResponse20014" $ \o ->
    InlineResponse20014
      <$> (o .:? "ID")
      <*> (o .:? "Running")
      <*> (o .:? "ExitCode")
      <*> (o .:? "ProcessConfig")
      <*> (o .:? "OpenStdin")
      <*> (o .:? "OpenStderr")
      <*> (o .:? "OpenStdout")
      <*> (o .:? "ContainerID")
      <*> (o .:? "Pid")

-- | ToJSON InlineResponse20014
instance A.ToJSON InlineResponse20014 where
  toJSON InlineResponse20014 {..} =
   _omitNulls
      [ "ID" .= inlineResponse20014Id
      , "Running" .= inlineResponse20014Running
      , "ExitCode" .= inlineResponse20014ExitCode
      , "ProcessConfig" .= inlineResponse20014ProcessConfig
      , "OpenStdin" .= inlineResponse20014OpenStdin
      , "OpenStderr" .= inlineResponse20014OpenStderr
      , "OpenStdout" .= inlineResponse20014OpenStdout
      , "ContainerID" .= inlineResponse20014ContainerId
      , "Pid" .= inlineResponse20014Pid
      ]


-- | Construct a value of type 'InlineResponse20014' (by applying it's required fields, if any)
mkInlineResponse20014
  :: InlineResponse20014
mkInlineResponse20014 =
  InlineResponse20014
  { inlineResponse20014Id = Nothing
  , inlineResponse20014Running = Nothing
  , inlineResponse20014ExitCode = Nothing
  , inlineResponse20014ProcessConfig = Nothing
  , inlineResponse20014OpenStdin = Nothing
  , inlineResponse20014OpenStderr = Nothing
  , inlineResponse20014OpenStdout = Nothing
  , inlineResponse20014ContainerId = Nothing
  , inlineResponse20014Pid = Nothing
  }

-- ** InlineResponse20015
-- | InlineResponse20015
data InlineResponse20015 = InlineResponse20015
  { inlineResponse20015Volumes :: !([Volume]) -- ^ /Required/ "Volumes" - List of volumes
  , inlineResponse20015Warnings :: !([Text]) -- ^ /Required/ "Warnings" - Warnings that occurred when fetching the list of volumes
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20015
instance A.FromJSON InlineResponse20015 where
  parseJSON = A.withObject "InlineResponse20015" $ \o ->
    InlineResponse20015
      <$> (o .:  "Volumes")
      <*> (o .:  "Warnings")

-- | ToJSON InlineResponse20015
instance A.ToJSON InlineResponse20015 where
  toJSON InlineResponse20015 {..} =
   _omitNulls
      [ "Volumes" .= inlineResponse20015Volumes
      , "Warnings" .= inlineResponse20015Warnings
      ]


-- | Construct a value of type 'InlineResponse20015' (by applying it's required fields, if any)
mkInlineResponse20015
  :: [Volume] -- ^ 'inlineResponse20015Volumes': List of volumes
  -> [Text] -- ^ 'inlineResponse20015Warnings': Warnings that occurred when fetching the list of volumes
  -> InlineResponse20015
mkInlineResponse20015 inlineResponse20015Volumes inlineResponse20015Warnings =
  InlineResponse20015
  { inlineResponse20015Volumes
  , inlineResponse20015Warnings
  }

-- ** InlineResponse20016
-- | InlineResponse20016
data InlineResponse20016 = InlineResponse20016
  { inlineResponse20016VolumesDeleted :: !(Maybe [Text]) -- ^ "VolumesDeleted" - Volumes that were deleted
  , inlineResponse20016SpaceReclaimed :: !(Maybe Integer) -- ^ "SpaceReclaimed" - Disk space reclaimed in bytes
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20016
instance A.FromJSON InlineResponse20016 where
  parseJSON = A.withObject "InlineResponse20016" $ \o ->
    InlineResponse20016
      <$> (o .:? "VolumesDeleted")
      <*> (o .:? "SpaceReclaimed")

-- | ToJSON InlineResponse20016
instance A.ToJSON InlineResponse20016 where
  toJSON InlineResponse20016 {..} =
   _omitNulls
      [ "VolumesDeleted" .= inlineResponse20016VolumesDeleted
      , "SpaceReclaimed" .= inlineResponse20016SpaceReclaimed
      ]


-- | Construct a value of type 'InlineResponse20016' (by applying it's required fields, if any)
mkInlineResponse20016
  :: InlineResponse20016
mkInlineResponse20016 =
  InlineResponse20016
  { inlineResponse20016VolumesDeleted = Nothing
  , inlineResponse20016SpaceReclaimed = Nothing
  }

-- ** InlineResponse20017
-- | InlineResponse20017
data InlineResponse20017 = InlineResponse20017
  { inlineResponse20017VolumesDeleted :: !(Maybe [Text]) -- ^ "VolumesDeleted" - Networks that were deleted
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20017
instance A.FromJSON InlineResponse20017 where
  parseJSON = A.withObject "InlineResponse20017" $ \o ->
    InlineResponse20017
      <$> (o .:? "VolumesDeleted")

-- | ToJSON InlineResponse20017
instance A.ToJSON InlineResponse20017 where
  toJSON InlineResponse20017 {..} =
   _omitNulls
      [ "VolumesDeleted" .= inlineResponse20017VolumesDeleted
      ]


-- | Construct a value of type 'InlineResponse20017' (by applying it's required fields, if any)
mkInlineResponse20017
  :: InlineResponse20017
mkInlineResponse20017 =
  InlineResponse20017
  { inlineResponse20017VolumesDeleted = Nothing
  }

-- ** InlineResponse20018
-- | InlineResponse20018
-- Describes a permission the user has to accept upon installing the plugin.
data InlineResponse20018 = InlineResponse20018
  { inlineResponse20018Name :: !(Maybe Text) -- ^ "Name"
  , inlineResponse20018Description :: !(Maybe Text) -- ^ "Description"
  , inlineResponse20018Value :: !(Maybe [Text]) -- ^ "Value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20018
instance A.FromJSON InlineResponse20018 where
  parseJSON = A.withObject "InlineResponse20018" $ \o ->
    InlineResponse20018
      <$> (o .:? "Name")
      <*> (o .:? "Description")
      <*> (o .:? "Value")

-- | ToJSON InlineResponse20018
instance A.ToJSON InlineResponse20018 where
  toJSON InlineResponse20018 {..} =
   _omitNulls
      [ "Name" .= inlineResponse20018Name
      , "Description" .= inlineResponse20018Description
      , "Value" .= inlineResponse20018Value
      ]


-- | Construct a value of type 'InlineResponse20018' (by applying it's required fields, if any)
mkInlineResponse20018
  :: InlineResponse20018
mkInlineResponse20018 =
  InlineResponse20018
  { inlineResponse20018Name = Nothing
  , inlineResponse20018Description = Nothing
  , inlineResponse20018Value = Nothing
  }

-- ** InlineResponse20019
-- | InlineResponse20019
data InlineResponse20019 = InlineResponse20019
  { inlineResponse20019UnlockKey :: !(Maybe Text) -- ^ "UnlockKey" - The swarm&#39;s unlock key.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20019
instance A.FromJSON InlineResponse20019 where
  parseJSON = A.withObject "InlineResponse20019" $ \o ->
    InlineResponse20019
      <$> (o .:? "UnlockKey")

-- | ToJSON InlineResponse20019
instance A.ToJSON InlineResponse20019 where
  toJSON InlineResponse20019 {..} =
   _omitNulls
      [ "UnlockKey" .= inlineResponse20019UnlockKey
      ]


-- | Construct a value of type 'InlineResponse20019' (by applying it's required fields, if any)
mkInlineResponse20019
  :: InlineResponse20019
mkInlineResponse20019 =
  InlineResponse20019
  { inlineResponse20019UnlockKey = Nothing
  }

-- ** InlineResponse2002
-- | InlineResponse2002
data InlineResponse2002 = InlineResponse2002
  { inlineResponse2002Path :: !(Maybe Text) -- ^ "Path" - Path to file that has changed
  , inlineResponse2002Kind :: !(Maybe Int) -- ^ "Kind" - Kind of change
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2002
instance A.FromJSON InlineResponse2002 where
  parseJSON = A.withObject "InlineResponse2002" $ \o ->
    InlineResponse2002
      <$> (o .:? "Path")
      <*> (o .:? "Kind")

-- | ToJSON InlineResponse2002
instance A.ToJSON InlineResponse2002 where
  toJSON InlineResponse2002 {..} =
   _omitNulls
      [ "Path" .= inlineResponse2002Path
      , "Kind" .= inlineResponse2002Kind
      ]


-- | Construct a value of type 'InlineResponse2002' (by applying it's required fields, if any)
mkInlineResponse2002
  :: InlineResponse2002
mkInlineResponse2002 =
  InlineResponse2002
  { inlineResponse2002Path = Nothing
  , inlineResponse2002Kind = Nothing
  }

-- ** InlineResponse2003
-- | InlineResponse2003
data InlineResponse2003 = InlineResponse2003
  { inlineResponse2003Warnings :: !(Maybe [Text]) -- ^ "Warnings"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2003
instance A.FromJSON InlineResponse2003 where
  parseJSON = A.withObject "InlineResponse2003" $ \o ->
    InlineResponse2003
      <$> (o .:? "Warnings")

-- | ToJSON InlineResponse2003
instance A.ToJSON InlineResponse2003 where
  toJSON InlineResponse2003 {..} =
   _omitNulls
      [ "Warnings" .= inlineResponse2003Warnings
      ]


-- | Construct a value of type 'InlineResponse2003' (by applying it's required fields, if any)
mkInlineResponse2003
  :: InlineResponse2003
mkInlineResponse2003 =
  InlineResponse2003
  { inlineResponse2003Warnings = Nothing
  }

-- ** InlineResponse2004
-- | InlineResponse2004
data InlineResponse2004 = InlineResponse2004
  { inlineResponse2004StatusCode :: !(Int) -- ^ /Required/ "StatusCode" - Exit code of the container
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2004
instance A.FromJSON InlineResponse2004 where
  parseJSON = A.withObject "InlineResponse2004" $ \o ->
    InlineResponse2004
      <$> (o .:  "StatusCode")

-- | ToJSON InlineResponse2004
instance A.ToJSON InlineResponse2004 where
  toJSON InlineResponse2004 {..} =
   _omitNulls
      [ "StatusCode" .= inlineResponse2004StatusCode
      ]


-- | Construct a value of type 'InlineResponse2004' (by applying it's required fields, if any)
mkInlineResponse2004
  :: Int -- ^ 'inlineResponse2004StatusCode': Exit code of the container
  -> InlineResponse2004
mkInlineResponse2004 inlineResponse2004StatusCode =
  InlineResponse2004
  { inlineResponse2004StatusCode
  }

-- ** InlineResponse2005
-- | InlineResponse2005
data InlineResponse2005 = InlineResponse2005
  { inlineResponse2005ContainersDeleted :: !(Maybe [Text]) -- ^ "ContainersDeleted" - Container IDs that were deleted
  , inlineResponse2005SpaceReclaimed :: !(Maybe Integer) -- ^ "SpaceReclaimed" - Disk space reclaimed in bytes
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2005
instance A.FromJSON InlineResponse2005 where
  parseJSON = A.withObject "InlineResponse2005" $ \o ->
    InlineResponse2005
      <$> (o .:? "ContainersDeleted")
      <*> (o .:? "SpaceReclaimed")

-- | ToJSON InlineResponse2005
instance A.ToJSON InlineResponse2005 where
  toJSON InlineResponse2005 {..} =
   _omitNulls
      [ "ContainersDeleted" .= inlineResponse2005ContainersDeleted
      , "SpaceReclaimed" .= inlineResponse2005SpaceReclaimed
      ]


-- | Construct a value of type 'InlineResponse2005' (by applying it's required fields, if any)
mkInlineResponse2005
  :: InlineResponse2005
mkInlineResponse2005 =
  InlineResponse2005
  { inlineResponse2005ContainersDeleted = Nothing
  , inlineResponse2005SpaceReclaimed = Nothing
  }

-- ** InlineResponse2006
-- | InlineResponse2006
data InlineResponse2006 = InlineResponse2006
  { inlineResponse2006Id :: !(Maybe Text) -- ^ "Id"
  , inlineResponse2006Created :: !(Maybe Integer) -- ^ "Created"
  , inlineResponse2006CreatedBy :: !(Maybe Text) -- ^ "CreatedBy"
  , inlineResponse2006Tags :: !(Maybe [Text]) -- ^ "Tags"
  , inlineResponse2006Size :: !(Maybe Integer) -- ^ "Size"
  , inlineResponse2006Comment :: !(Maybe Text) -- ^ "Comment"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2006
instance A.FromJSON InlineResponse2006 where
  parseJSON = A.withObject "InlineResponse2006" $ \o ->
    InlineResponse2006
      <$> (o .:? "Id")
      <*> (o .:? "Created")
      <*> (o .:? "CreatedBy")
      <*> (o .:? "Tags")
      <*> (o .:? "Size")
      <*> (o .:? "Comment")

-- | ToJSON InlineResponse2006
instance A.ToJSON InlineResponse2006 where
  toJSON InlineResponse2006 {..} =
   _omitNulls
      [ "Id" .= inlineResponse2006Id
      , "Created" .= inlineResponse2006Created
      , "CreatedBy" .= inlineResponse2006CreatedBy
      , "Tags" .= inlineResponse2006Tags
      , "Size" .= inlineResponse2006Size
      , "Comment" .= inlineResponse2006Comment
      ]


-- | Construct a value of type 'InlineResponse2006' (by applying it's required fields, if any)
mkInlineResponse2006
  :: InlineResponse2006
mkInlineResponse2006 =
  InlineResponse2006
  { inlineResponse2006Id = Nothing
  , inlineResponse2006Created = Nothing
  , inlineResponse2006CreatedBy = Nothing
  , inlineResponse2006Tags = Nothing
  , inlineResponse2006Size = Nothing
  , inlineResponse2006Comment = Nothing
  }

-- ** InlineResponse2007
-- | InlineResponse2007
data InlineResponse2007 = InlineResponse2007
  { inlineResponse2007Description :: !(Maybe Text) -- ^ "description"
  , inlineResponse2007IsOfficial :: !(Maybe Bool) -- ^ "is_official"
  , inlineResponse2007IsAutomated :: !(Maybe Bool) -- ^ "is_automated"
  , inlineResponse2007Name :: !(Maybe Text) -- ^ "name"
  , inlineResponse2007StarCount :: !(Maybe Int) -- ^ "star_count"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2007
instance A.FromJSON InlineResponse2007 where
  parseJSON = A.withObject "InlineResponse2007" $ \o ->
    InlineResponse2007
      <$> (o .:? "description")
      <*> (o .:? "is_official")
      <*> (o .:? "is_automated")
      <*> (o .:? "name")
      <*> (o .:? "star_count")

-- | ToJSON InlineResponse2007
instance A.ToJSON InlineResponse2007 where
  toJSON InlineResponse2007 {..} =
   _omitNulls
      [ "description" .= inlineResponse2007Description
      , "is_official" .= inlineResponse2007IsOfficial
      , "is_automated" .= inlineResponse2007IsAutomated
      , "name" .= inlineResponse2007Name
      , "star_count" .= inlineResponse2007StarCount
      ]


-- | Construct a value of type 'InlineResponse2007' (by applying it's required fields, if any)
mkInlineResponse2007
  :: InlineResponse2007
mkInlineResponse2007 =
  InlineResponse2007
  { inlineResponse2007Description = Nothing
  , inlineResponse2007IsOfficial = Nothing
  , inlineResponse2007IsAutomated = Nothing
  , inlineResponse2007Name = Nothing
  , inlineResponse2007StarCount = Nothing
  }

-- ** InlineResponse2008
-- | InlineResponse2008
data InlineResponse2008 = InlineResponse2008
  { inlineResponse2008ImagesDeleted :: !(Maybe [ImageDeleteResponse]) -- ^ "ImagesDeleted" - Images that were deleted
  , inlineResponse2008SpaceReclaimed :: !(Maybe Integer) -- ^ "SpaceReclaimed" - Disk space reclaimed in bytes
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2008
instance A.FromJSON InlineResponse2008 where
  parseJSON = A.withObject "InlineResponse2008" $ \o ->
    InlineResponse2008
      <$> (o .:? "ImagesDeleted")
      <*> (o .:? "SpaceReclaimed")

-- | ToJSON InlineResponse2008
instance A.ToJSON InlineResponse2008 where
  toJSON InlineResponse2008 {..} =
   _omitNulls
      [ "ImagesDeleted" .= inlineResponse2008ImagesDeleted
      , "SpaceReclaimed" .= inlineResponse2008SpaceReclaimed
      ]


-- | Construct a value of type 'InlineResponse2008' (by applying it's required fields, if any)
mkInlineResponse2008
  :: InlineResponse2008
mkInlineResponse2008 =
  InlineResponse2008
  { inlineResponse2008ImagesDeleted = Nothing
  , inlineResponse2008SpaceReclaimed = Nothing
  }

-- ** InlineResponse2009
-- | InlineResponse2009
data InlineResponse2009 = InlineResponse2009
  { inlineResponse2009Status :: !(Text) -- ^ /Required/ "Status" - The status of the authentication
  , inlineResponse2009IdentityToken :: !(Maybe Text) -- ^ "IdentityToken" - An opaque token used to authenticate a user after a successful login
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2009
instance A.FromJSON InlineResponse2009 where
  parseJSON = A.withObject "InlineResponse2009" $ \o ->
    InlineResponse2009
      <$> (o .:  "Status")
      <*> (o .:? "IdentityToken")

-- | ToJSON InlineResponse2009
instance A.ToJSON InlineResponse2009 where
  toJSON InlineResponse2009 {..} =
   _omitNulls
      [ "Status" .= inlineResponse2009Status
      , "IdentityToken" .= inlineResponse2009IdentityToken
      ]


-- | Construct a value of type 'InlineResponse2009' (by applying it's required fields, if any)
mkInlineResponse2009
  :: Text -- ^ 'inlineResponse2009Status': The status of the authentication
  -> InlineResponse2009
mkInlineResponse2009 inlineResponse2009Status =
  InlineResponse2009
  { inlineResponse2009Status
  , inlineResponse2009IdentityToken = Nothing
  }

-- ** InlineResponse200State
-- | InlineResponse200State
-- The state of the container.
data InlineResponse200State = InlineResponse200State
  { inlineResponse200StateStatus :: !(Maybe Text) -- ^ "Status" - The status of the container. For example, &#x60;running&#x60; or &#x60;exited&#x60;.
  , inlineResponse200StateRunning :: !(Maybe Bool) -- ^ "Running" - Whether this container is running.
  , inlineResponse200StatePaused :: !(Maybe Bool) -- ^ "Paused" - Whether this container is paused.
  , inlineResponse200StateRestarting :: !(Maybe Bool) -- ^ "Restarting" - Whether this container is restarting.
  , inlineResponse200StateOomKilled :: !(Maybe Bool) -- ^ "OOMKilled" - Whether this container has been killed because it ran out of memory.
  , inlineResponse200StateDead :: !(Maybe Bool) -- ^ "Dead"
  , inlineResponse200StatePid :: !(Maybe Int) -- ^ "Pid" - The process ID of this container
  , inlineResponse200StateExitCode :: !(Maybe Int) -- ^ "ExitCode" - The last exit code of this container
  , inlineResponse200StateError :: !(Maybe Text) -- ^ "Error"
  , inlineResponse200StateStartedAt :: !(Maybe Text) -- ^ "StartedAt" - The time when this container was last started.
  , inlineResponse200StateFinishedAt :: !(Maybe Text) -- ^ "FinishedAt" - The time when this container last exited.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse200State
instance A.FromJSON InlineResponse200State where
  parseJSON = A.withObject "InlineResponse200State" $ \o ->
    InlineResponse200State
      <$> (o .:? "Status")
      <*> (o .:? "Running")
      <*> (o .:? "Paused")
      <*> (o .:? "Restarting")
      <*> (o .:? "OOMKilled")
      <*> (o .:? "Dead")
      <*> (o .:? "Pid")
      <*> (o .:? "ExitCode")
      <*> (o .:? "Error")
      <*> (o .:? "StartedAt")
      <*> (o .:? "FinishedAt")

-- | ToJSON InlineResponse200State
instance A.ToJSON InlineResponse200State where
  toJSON InlineResponse200State {..} =
   _omitNulls
      [ "Status" .= inlineResponse200StateStatus
      , "Running" .= inlineResponse200StateRunning
      , "Paused" .= inlineResponse200StatePaused
      , "Restarting" .= inlineResponse200StateRestarting
      , "OOMKilled" .= inlineResponse200StateOomKilled
      , "Dead" .= inlineResponse200StateDead
      , "Pid" .= inlineResponse200StatePid
      , "ExitCode" .= inlineResponse200StateExitCode
      , "Error" .= inlineResponse200StateError
      , "StartedAt" .= inlineResponse200StateStartedAt
      , "FinishedAt" .= inlineResponse200StateFinishedAt
      ]


-- | Construct a value of type 'InlineResponse200State' (by applying it's required fields, if any)
mkInlineResponse200State
  :: InlineResponse200State
mkInlineResponse200State =
  InlineResponse200State
  { inlineResponse200StateStatus = Nothing
  , inlineResponse200StateRunning = Nothing
  , inlineResponse200StatePaused = Nothing
  , inlineResponse200StateRestarting = Nothing
  , inlineResponse200StateOomKilled = Nothing
  , inlineResponse200StateDead = Nothing
  , inlineResponse200StatePid = Nothing
  , inlineResponse200StateExitCode = Nothing
  , inlineResponse200StateError = Nothing
  , inlineResponse200StateStartedAt = Nothing
  , inlineResponse200StateFinishedAt = Nothing
  }

-- ** InlineResponse201
-- | InlineResponse201
data InlineResponse201 = InlineResponse201
  { inlineResponse201Id :: !(Text) -- ^ /Required/ "Id" - The ID of the created container
  , inlineResponse201Warnings :: !([Text]) -- ^ /Required/ "Warnings" - Warnings encountered when creating the container
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse201
instance A.FromJSON InlineResponse201 where
  parseJSON = A.withObject "InlineResponse201" $ \o ->
    InlineResponse201
      <$> (o .:  "Id")
      <*> (o .:  "Warnings")

-- | ToJSON InlineResponse201
instance A.ToJSON InlineResponse201 where
  toJSON InlineResponse201 {..} =
   _omitNulls
      [ "Id" .= inlineResponse201Id
      , "Warnings" .= inlineResponse201Warnings
      ]


-- | Construct a value of type 'InlineResponse201' (by applying it's required fields, if any)
mkInlineResponse201
  :: Text -- ^ 'inlineResponse201Id': The ID of the created container
  -> [Text] -- ^ 'inlineResponse201Warnings': Warnings encountered when creating the container
  -> InlineResponse201
mkInlineResponse201 inlineResponse201Id inlineResponse201Warnings =
  InlineResponse201
  { inlineResponse201Id
  , inlineResponse201Warnings
  }

-- ** InlineResponse2011
-- | InlineResponse2011
data InlineResponse2011 = InlineResponse2011
  { inlineResponse2011Id :: !(Maybe Text) -- ^ "Id" - The ID of the created network.
  , inlineResponse2011Warning :: !(Maybe Text) -- ^ "Warning"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2011
instance A.FromJSON InlineResponse2011 where
  parseJSON = A.withObject "InlineResponse2011" $ \o ->
    InlineResponse2011
      <$> (o .:? "Id")
      <*> (o .:? "Warning")

-- | ToJSON InlineResponse2011
instance A.ToJSON InlineResponse2011 where
  toJSON InlineResponse2011 {..} =
   _omitNulls
      [ "Id" .= inlineResponse2011Id
      , "Warning" .= inlineResponse2011Warning
      ]


-- | Construct a value of type 'InlineResponse2011' (by applying it's required fields, if any)
mkInlineResponse2011
  :: InlineResponse2011
mkInlineResponse2011 =
  InlineResponse2011
  { inlineResponse2011Id = Nothing
  , inlineResponse2011Warning = Nothing
  }

-- ** InlineResponse2012
-- | InlineResponse2012
data InlineResponse2012 = InlineResponse2012
  { inlineResponse2012Id :: !(Maybe Text) -- ^ "ID" - The ID of the created service.
  , inlineResponse2012Warning :: !(Maybe Text) -- ^ "Warning" - Optional warning message
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2012
instance A.FromJSON InlineResponse2012 where
  parseJSON = A.withObject "InlineResponse2012" $ \o ->
    InlineResponse2012
      <$> (o .:? "ID")
      <*> (o .:? "Warning")

-- | ToJSON InlineResponse2012
instance A.ToJSON InlineResponse2012 where
  toJSON InlineResponse2012 {..} =
   _omitNulls
      [ "ID" .= inlineResponse2012Id
      , "Warning" .= inlineResponse2012Warning
      ]


-- | Construct a value of type 'InlineResponse2012' (by applying it's required fields, if any)
mkInlineResponse2012
  :: InlineResponse2012
mkInlineResponse2012 =
  InlineResponse2012
  { inlineResponse2012Id = Nothing
  , inlineResponse2012Warning = Nothing
  }

-- ** InlineResponse2013
-- | InlineResponse2013
data InlineResponse2013 = InlineResponse2013
  { inlineResponse2013Id :: !(Maybe Text) -- ^ "ID" - The ID of the created secret.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2013
instance A.FromJSON InlineResponse2013 where
  parseJSON = A.withObject "InlineResponse2013" $ \o ->
    InlineResponse2013
      <$> (o .:? "ID")

-- | ToJSON InlineResponse2013
instance A.ToJSON InlineResponse2013 where
  toJSON InlineResponse2013 {..} =
   _omitNulls
      [ "ID" .= inlineResponse2013Id
      ]


-- | Construct a value of type 'InlineResponse2013' (by applying it's required fields, if any)
mkInlineResponse2013
  :: InlineResponse2013
mkInlineResponse2013 =
  InlineResponse2013
  { inlineResponse2013Id = Nothing
  }

-- ** Mount
-- | Mount
data Mount = Mount
  { mountTarget :: !(Maybe Text) -- ^ "Target" - Container path.
  , mountType :: !(Maybe E'Type2) -- ^ "Type" - The mount type. Available types:  - &#x60;bind&#x60; Mounts a file or directory from the host into the container. Must exist prior to creating the container. - &#x60;volume&#x60; Creates a volume with the given name and options (or uses a pre-existing volume with the same name and options). These are **not** removed when the container is removed. - &#x60;tmpfs&#x60; Create a tmpfs with the given options. The mount source cannot be specified for tmpfs. 
  , mountReadOnly :: !(Maybe Bool) -- ^ "ReadOnly" - Whether the mount should be read-only.
  , mountBindOptions :: !(Maybe A.Value) -- ^ "BindOptions" - Optional configuration for the &#x60;bind&#x60; type.
  , mountVolumeOptions :: !(Maybe MountVolumeOptions) -- ^ "VolumeOptions"
  , mountTmpfsOptions :: !(Maybe MountTmpfsOptions) -- ^ "TmpfsOptions"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Mount
instance A.FromJSON Mount where
  parseJSON = A.withObject "Mount" $ \o ->
    Mount
      <$> (o .:? "Target")
      <*> (o .:? "Type")
      <*> (o .:? "ReadOnly")
      <*> (o .:? "BindOptions")
      <*> (o .:? "VolumeOptions")
      <*> (o .:? "TmpfsOptions")

-- | ToJSON Mount
instance A.ToJSON Mount where
  toJSON Mount {..} =
   _omitNulls
      [ "Target" .= mountTarget
      , "Type" .= mountType
      , "ReadOnly" .= mountReadOnly
      , "BindOptions" .= mountBindOptions
      , "VolumeOptions" .= mountVolumeOptions
      , "TmpfsOptions" .= mountTmpfsOptions
      ]


-- | Construct a value of type 'Mount' (by applying it's required fields, if any)
mkMount
  :: Mount
mkMount =
  Mount
  { mountTarget = Nothing
  , mountType = Nothing
  , mountReadOnly = Nothing
  , mountBindOptions = Nothing
  , mountVolumeOptions = Nothing
  , mountTmpfsOptions = Nothing
  }

-- ** MountPoint
-- | MountPoint
-- A mount point inside a container
data MountPoint = MountPoint
  { mountPointType :: !(Maybe Text) -- ^ "Type"
  , mountPointName :: !(Maybe Text) -- ^ "Name"
  , mountPointSource :: !(Maybe Text) -- ^ "Source"
  , mountPointDestination :: !(Maybe Text) -- ^ "Destination"
  , mountPointDriver :: !(Maybe Text) -- ^ "Driver"
  , mountPointMode :: !(Maybe Text) -- ^ "Mode"
  , mountPointRw :: !(Maybe Bool) -- ^ "RW"
  , mountPointPropagation :: !(Maybe Text) -- ^ "Propagation"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MountPoint
instance A.FromJSON MountPoint where
  parseJSON = A.withObject "MountPoint" $ \o ->
    MountPoint
      <$> (o .:? "Type")
      <*> (o .:? "Name")
      <*> (o .:? "Source")
      <*> (o .:? "Destination")
      <*> (o .:? "Driver")
      <*> (o .:? "Mode")
      <*> (o .:? "RW")
      <*> (o .:? "Propagation")

-- | ToJSON MountPoint
instance A.ToJSON MountPoint where
  toJSON MountPoint {..} =
   _omitNulls
      [ "Type" .= mountPointType
      , "Name" .= mountPointName
      , "Source" .= mountPointSource
      , "Destination" .= mountPointDestination
      , "Driver" .= mountPointDriver
      , "Mode" .= mountPointMode
      , "RW" .= mountPointRw
      , "Propagation" .= mountPointPropagation
      ]


-- | Construct a value of type 'MountPoint' (by applying it's required fields, if any)
mkMountPoint
  :: MountPoint
mkMountPoint =
  MountPoint
  { mountPointType = Nothing
  , mountPointName = Nothing
  , mountPointSource = Nothing
  , mountPointDestination = Nothing
  , mountPointDriver = Nothing
  , mountPointMode = Nothing
  , mountPointRw = Nothing
  , mountPointPropagation = Nothing
  }

-- ** MountTmpfsOptions
-- | MountTmpfsOptions
-- Optional configuration for the `tmpfs` type.
data MountTmpfsOptions = MountTmpfsOptions
  { mountTmpfsOptionsSizeBytes :: !(Maybe Integer) -- ^ "SizeBytes" - The size for the tmpfs mount in bytes.
  , mountTmpfsOptionsMode :: !(Maybe Int) -- ^ "Mode" - The permission mode for the tmpfs mount in an integer.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MountTmpfsOptions
instance A.FromJSON MountTmpfsOptions where
  parseJSON = A.withObject "MountTmpfsOptions" $ \o ->
    MountTmpfsOptions
      <$> (o .:? "SizeBytes")
      <*> (o .:? "Mode")

-- | ToJSON MountTmpfsOptions
instance A.ToJSON MountTmpfsOptions where
  toJSON MountTmpfsOptions {..} =
   _omitNulls
      [ "SizeBytes" .= mountTmpfsOptionsSizeBytes
      , "Mode" .= mountTmpfsOptionsMode
      ]


-- | Construct a value of type 'MountTmpfsOptions' (by applying it's required fields, if any)
mkMountTmpfsOptions
  :: MountTmpfsOptions
mkMountTmpfsOptions =
  MountTmpfsOptions
  { mountTmpfsOptionsSizeBytes = Nothing
  , mountTmpfsOptionsMode = Nothing
  }

-- ** MountVolumeOptions
-- | MountVolumeOptions
-- Optional configuration for the `volume` type.
data MountVolumeOptions = MountVolumeOptions
  { mountVolumeOptionsNoCopy :: !(Maybe Bool) -- ^ "NoCopy" - Populate volume with data from the target.
  , mountVolumeOptionsLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  , mountVolumeOptionsDriverConfig :: !(Maybe MountVolumeOptionsDriverConfig) -- ^ "DriverConfig"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MountVolumeOptions
instance A.FromJSON MountVolumeOptions where
  parseJSON = A.withObject "MountVolumeOptions" $ \o ->
    MountVolumeOptions
      <$> (o .:? "NoCopy")
      <*> (o .:? "Labels")
      <*> (o .:? "DriverConfig")

-- | ToJSON MountVolumeOptions
instance A.ToJSON MountVolumeOptions where
  toJSON MountVolumeOptions {..} =
   _omitNulls
      [ "NoCopy" .= mountVolumeOptionsNoCopy
      , "Labels" .= mountVolumeOptionsLabels
      , "DriverConfig" .= mountVolumeOptionsDriverConfig
      ]


-- | Construct a value of type 'MountVolumeOptions' (by applying it's required fields, if any)
mkMountVolumeOptions
  :: MountVolumeOptions
mkMountVolumeOptions =
  MountVolumeOptions
  { mountVolumeOptionsNoCopy = Nothing
  , mountVolumeOptionsLabels = Nothing
  , mountVolumeOptionsDriverConfig = Nothing
  }

-- ** MountVolumeOptionsDriverConfig
-- | MountVolumeOptionsDriverConfig
-- Map of driver specific options
data MountVolumeOptionsDriverConfig = MountVolumeOptionsDriverConfig
  { mountVolumeOptionsDriverConfigName :: !(Maybe Text) -- ^ "Name" - Name of the driver to use to create the volume.
  , mountVolumeOptionsDriverConfigOptions :: !(Maybe (Map.Map String Text)) -- ^ "Options" - key/value map of driver specific options.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MountVolumeOptionsDriverConfig
instance A.FromJSON MountVolumeOptionsDriverConfig where
  parseJSON = A.withObject "MountVolumeOptionsDriverConfig" $ \o ->
    MountVolumeOptionsDriverConfig
      <$> (o .:? "Name")
      <*> (o .:? "Options")

-- | ToJSON MountVolumeOptionsDriverConfig
instance A.ToJSON MountVolumeOptionsDriverConfig where
  toJSON MountVolumeOptionsDriverConfig {..} =
   _omitNulls
      [ "Name" .= mountVolumeOptionsDriverConfigName
      , "Options" .= mountVolumeOptionsDriverConfigOptions
      ]


-- | Construct a value of type 'MountVolumeOptionsDriverConfig' (by applying it's required fields, if any)
mkMountVolumeOptionsDriverConfig
  :: MountVolumeOptionsDriverConfig
mkMountVolumeOptionsDriverConfig =
  MountVolumeOptionsDriverConfig
  { mountVolumeOptionsDriverConfigName = Nothing
  , mountVolumeOptionsDriverConfigOptions = Nothing
  }

-- ** Network
-- | Network
data Network = Network
  { networkName :: !(Maybe Text) -- ^ "Name"
  , networkId :: !(Maybe Text) -- ^ "Id"
  , networkCreated :: !(Maybe Text) -- ^ "Created"
  , networkScope :: !(Maybe Text) -- ^ "Scope"
  , networkDriver :: !(Maybe Text) -- ^ "Driver"
  , networkEnableIPv6 :: !(Maybe Bool) -- ^ "EnableIPv6"
  , networkIpam :: !(Maybe IPAM) -- ^ "IPAM"
  , networkInternal :: !(Maybe Bool) -- ^ "Internal"
  , networkContainers :: !(Maybe (Map.Map String NetworkContainer)) -- ^ "Containers"
  , networkOptions :: !(Maybe (Map.Map String Text)) -- ^ "Options"
  , networkLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Network
instance A.FromJSON Network where
  parseJSON = A.withObject "Network" $ \o ->
    Network
      <$> (o .:? "Name")
      <*> (o .:? "Id")
      <*> (o .:? "Created")
      <*> (o .:? "Scope")
      <*> (o .:? "Driver")
      <*> (o .:? "EnableIPv6")
      <*> (o .:? "IPAM")
      <*> (o .:? "Internal")
      <*> (o .:? "Containers")
      <*> (o .:? "Options")
      <*> (o .:? "Labels")

-- | ToJSON Network
instance A.ToJSON Network where
  toJSON Network {..} =
   _omitNulls
      [ "Name" .= networkName
      , "Id" .= networkId
      , "Created" .= networkCreated
      , "Scope" .= networkScope
      , "Driver" .= networkDriver
      , "EnableIPv6" .= networkEnableIPv6
      , "IPAM" .= networkIpam
      , "Internal" .= networkInternal
      , "Containers" .= networkContainers
      , "Options" .= networkOptions
      , "Labels" .= networkLabels
      ]


-- | Construct a value of type 'Network' (by applying it's required fields, if any)
mkNetwork
  :: Network
mkNetwork =
  Network
  { networkName = Nothing
  , networkId = Nothing
  , networkCreated = Nothing
  , networkScope = Nothing
  , networkDriver = Nothing
  , networkEnableIPv6 = Nothing
  , networkIpam = Nothing
  , networkInternal = Nothing
  , networkContainers = Nothing
  , networkOptions = Nothing
  , networkLabels = Nothing
  }

-- ** NetworkConfig2
-- | NetworkConfig2
data NetworkConfig2 = NetworkConfig2
  { networkConfig2Name :: !(Text) -- ^ /Required/ "Name" - The network&#39;s name.
  , networkConfig2CheckDuplicate :: !(Maybe Bool) -- ^ "CheckDuplicate" - Check for networks with duplicate names.
  , networkConfig2Driver :: !(Maybe Text) -- ^ "Driver" - Name of the network driver plugin to use.
  , networkConfig2Internal :: !(Maybe Bool) -- ^ "Internal" - Restrict external access to the network.
  , networkConfig2Ipam :: !(Maybe IPAM) -- ^ "IPAM" - Optional custom IP scheme for the network.
  , networkConfig2EnableIPv6 :: !(Maybe Bool) -- ^ "EnableIPv6" - Enable IPv6 on the network.
  , networkConfig2Options :: !(Maybe (Map.Map String Text)) -- ^ "Options" - Network specific options to be used by the drivers.
  , networkConfig2Labels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NetworkConfig2
instance A.FromJSON NetworkConfig2 where
  parseJSON = A.withObject "NetworkConfig2" $ \o ->
    NetworkConfig2
      <$> (o .:  "Name")
      <*> (o .:? "CheckDuplicate")
      <*> (o .:? "Driver")
      <*> (o .:? "Internal")
      <*> (o .:? "IPAM")
      <*> (o .:? "EnableIPv6")
      <*> (o .:? "Options")
      <*> (o .:? "Labels")

-- | ToJSON NetworkConfig2
instance A.ToJSON NetworkConfig2 where
  toJSON NetworkConfig2 {..} =
   _omitNulls
      [ "Name" .= networkConfig2Name
      , "CheckDuplicate" .= networkConfig2CheckDuplicate
      , "Driver" .= networkConfig2Driver
      , "Internal" .= networkConfig2Internal
      , "IPAM" .= networkConfig2Ipam
      , "EnableIPv6" .= networkConfig2EnableIPv6
      , "Options" .= networkConfig2Options
      , "Labels" .= networkConfig2Labels
      ]


-- | Construct a value of type 'NetworkConfig2' (by applying it's required fields, if any)
mkNetworkConfig2
  :: Text -- ^ 'networkConfig2Name': The network's name.
  -> NetworkConfig2
mkNetworkConfig2 networkConfig2Name =
  NetworkConfig2
  { networkConfig2Name
  , networkConfig2CheckDuplicate = Nothing
  , networkConfig2Driver = Nothing
  , networkConfig2Internal = Nothing
  , networkConfig2Ipam = Nothing
  , networkConfig2EnableIPv6 = Nothing
  , networkConfig2Options = Nothing
  , networkConfig2Labels = Nothing
  }

-- ** NetworkContainer
-- | NetworkContainer
data NetworkContainer = NetworkContainer
  { networkContainerEndpointId :: !(Maybe Text) -- ^ "EndpointID"
  , networkContainerMacAddress :: !(Maybe Text) -- ^ "MacAddress"
  , networkContainerIPv4Address :: !(Maybe Text) -- ^ "IPv4Address"
  , networkContainerIPv6Address :: !(Maybe Text) -- ^ "IPv6Address"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NetworkContainer
instance A.FromJSON NetworkContainer where
  parseJSON = A.withObject "NetworkContainer" $ \o ->
    NetworkContainer
      <$> (o .:? "EndpointID")
      <*> (o .:? "MacAddress")
      <*> (o .:? "IPv4Address")
      <*> (o .:? "IPv6Address")

-- | ToJSON NetworkContainer
instance A.ToJSON NetworkContainer where
  toJSON NetworkContainer {..} =
   _omitNulls
      [ "EndpointID" .= networkContainerEndpointId
      , "MacAddress" .= networkContainerMacAddress
      , "IPv4Address" .= networkContainerIPv4Address
      , "IPv6Address" .= networkContainerIPv6Address
      ]


-- | Construct a value of type 'NetworkContainer' (by applying it's required fields, if any)
mkNetworkContainer
  :: NetworkContainer
mkNetworkContainer =
  NetworkContainer
  { networkContainerEndpointId = Nothing
  , networkContainerMacAddress = Nothing
  , networkContainerIPv4Address = Nothing
  , networkContainerIPv6Address = Nothing
  }

-- ** Node
-- | Node
data Node = Node
  { nodeId :: !(Maybe Text) -- ^ "ID"
  , nodeVersion :: !(Maybe NodeVersion) -- ^ "Version"
  , nodeCreatedAt :: !(Maybe Text) -- ^ "CreatedAt"
  , nodeUpdatedAt :: !(Maybe Text) -- ^ "UpdatedAt"
  , nodeSpec :: !(Maybe NodeSpec) -- ^ "Spec"
  , nodeDescription :: !(Maybe NodeDescription) -- ^ "Description"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Node
instance A.FromJSON Node where
  parseJSON = A.withObject "Node" $ \o ->
    Node
      <$> (o .:? "ID")
      <*> (o .:? "Version")
      <*> (o .:? "CreatedAt")
      <*> (o .:? "UpdatedAt")
      <*> (o .:? "Spec")
      <*> (o .:? "Description")

-- | ToJSON Node
instance A.ToJSON Node where
  toJSON Node {..} =
   _omitNulls
      [ "ID" .= nodeId
      , "Version" .= nodeVersion
      , "CreatedAt" .= nodeCreatedAt
      , "UpdatedAt" .= nodeUpdatedAt
      , "Spec" .= nodeSpec
      , "Description" .= nodeDescription
      ]


-- | Construct a value of type 'Node' (by applying it's required fields, if any)
mkNode
  :: Node
mkNode =
  Node
  { nodeId = Nothing
  , nodeVersion = Nothing
  , nodeCreatedAt = Nothing
  , nodeUpdatedAt = Nothing
  , nodeSpec = Nothing
  , nodeDescription = Nothing
  }

-- ** NodeDescription
-- | NodeDescription
data NodeDescription = NodeDescription
  { nodeDescriptionHostname :: !(Maybe Text) -- ^ "Hostname"
  , nodeDescriptionPlatform :: !(Maybe NodeDescriptionPlatform) -- ^ "Platform"
  , nodeDescriptionResources :: !(Maybe NodeDescriptionResources) -- ^ "Resources"
  , nodeDescriptionEngine :: !(Maybe NodeDescriptionEngine) -- ^ "Engine"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NodeDescription
instance A.FromJSON NodeDescription where
  parseJSON = A.withObject "NodeDescription" $ \o ->
    NodeDescription
      <$> (o .:? "Hostname")
      <*> (o .:? "Platform")
      <*> (o .:? "Resources")
      <*> (o .:? "Engine")

-- | ToJSON NodeDescription
instance A.ToJSON NodeDescription where
  toJSON NodeDescription {..} =
   _omitNulls
      [ "Hostname" .= nodeDescriptionHostname
      , "Platform" .= nodeDescriptionPlatform
      , "Resources" .= nodeDescriptionResources
      , "Engine" .= nodeDescriptionEngine
      ]


-- | Construct a value of type 'NodeDescription' (by applying it's required fields, if any)
mkNodeDescription
  :: NodeDescription
mkNodeDescription =
  NodeDescription
  { nodeDescriptionHostname = Nothing
  , nodeDescriptionPlatform = Nothing
  , nodeDescriptionResources = Nothing
  , nodeDescriptionEngine = Nothing
  }

-- ** NodeDescriptionEngine
-- | NodeDescriptionEngine
data NodeDescriptionEngine = NodeDescriptionEngine
  { nodeDescriptionEngineEngineVersion :: !(Maybe Text) -- ^ "EngineVersion"
  , nodeDescriptionEngineLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels"
  , nodeDescriptionEnginePlugins :: !(Maybe [NodeDescriptionEnginePlugins]) -- ^ "Plugins"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NodeDescriptionEngine
instance A.FromJSON NodeDescriptionEngine where
  parseJSON = A.withObject "NodeDescriptionEngine" $ \o ->
    NodeDescriptionEngine
      <$> (o .:? "EngineVersion")
      <*> (o .:? "Labels")
      <*> (o .:? "Plugins")

-- | ToJSON NodeDescriptionEngine
instance A.ToJSON NodeDescriptionEngine where
  toJSON NodeDescriptionEngine {..} =
   _omitNulls
      [ "EngineVersion" .= nodeDescriptionEngineEngineVersion
      , "Labels" .= nodeDescriptionEngineLabels
      , "Plugins" .= nodeDescriptionEnginePlugins
      ]


-- | Construct a value of type 'NodeDescriptionEngine' (by applying it's required fields, if any)
mkNodeDescriptionEngine
  :: NodeDescriptionEngine
mkNodeDescriptionEngine =
  NodeDescriptionEngine
  { nodeDescriptionEngineEngineVersion = Nothing
  , nodeDescriptionEngineLabels = Nothing
  , nodeDescriptionEnginePlugins = Nothing
  }

-- ** NodeDescriptionEnginePlugins
-- | NodeDescriptionEnginePlugins
data NodeDescriptionEnginePlugins = NodeDescriptionEnginePlugins
  { nodeDescriptionEnginePluginsType :: !(Maybe Text) -- ^ "Type"
  , nodeDescriptionEnginePluginsName :: !(Maybe Text) -- ^ "Name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NodeDescriptionEnginePlugins
instance A.FromJSON NodeDescriptionEnginePlugins where
  parseJSON = A.withObject "NodeDescriptionEnginePlugins" $ \o ->
    NodeDescriptionEnginePlugins
      <$> (o .:? "Type")
      <*> (o .:? "Name")

-- | ToJSON NodeDescriptionEnginePlugins
instance A.ToJSON NodeDescriptionEnginePlugins where
  toJSON NodeDescriptionEnginePlugins {..} =
   _omitNulls
      [ "Type" .= nodeDescriptionEnginePluginsType
      , "Name" .= nodeDescriptionEnginePluginsName
      ]


-- | Construct a value of type 'NodeDescriptionEnginePlugins' (by applying it's required fields, if any)
mkNodeDescriptionEnginePlugins
  :: NodeDescriptionEnginePlugins
mkNodeDescriptionEnginePlugins =
  NodeDescriptionEnginePlugins
  { nodeDescriptionEnginePluginsType = Nothing
  , nodeDescriptionEnginePluginsName = Nothing
  }

-- ** NodeDescriptionPlatform
-- | NodeDescriptionPlatform
data NodeDescriptionPlatform = NodeDescriptionPlatform
  { nodeDescriptionPlatformArchitecture :: !(Maybe Text) -- ^ "Architecture"
  , nodeDescriptionPlatformOs :: !(Maybe Text) -- ^ "OS"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NodeDescriptionPlatform
instance A.FromJSON NodeDescriptionPlatform where
  parseJSON = A.withObject "NodeDescriptionPlatform" $ \o ->
    NodeDescriptionPlatform
      <$> (o .:? "Architecture")
      <*> (o .:? "OS")

-- | ToJSON NodeDescriptionPlatform
instance A.ToJSON NodeDescriptionPlatform where
  toJSON NodeDescriptionPlatform {..} =
   _omitNulls
      [ "Architecture" .= nodeDescriptionPlatformArchitecture
      , "OS" .= nodeDescriptionPlatformOs
      ]


-- | Construct a value of type 'NodeDescriptionPlatform' (by applying it's required fields, if any)
mkNodeDescriptionPlatform
  :: NodeDescriptionPlatform
mkNodeDescriptionPlatform =
  NodeDescriptionPlatform
  { nodeDescriptionPlatformArchitecture = Nothing
  , nodeDescriptionPlatformOs = Nothing
  }

-- ** NodeDescriptionResources
-- | NodeDescriptionResources
data NodeDescriptionResources = NodeDescriptionResources
  { nodeDescriptionResourcesNanoCpUs :: !(Maybe Integer) -- ^ "NanoCPUs"
  , nodeDescriptionResourcesMemoryBytes :: !(Maybe Integer) -- ^ "MemoryBytes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NodeDescriptionResources
instance A.FromJSON NodeDescriptionResources where
  parseJSON = A.withObject "NodeDescriptionResources" $ \o ->
    NodeDescriptionResources
      <$> (o .:? "NanoCPUs")
      <*> (o .:? "MemoryBytes")

-- | ToJSON NodeDescriptionResources
instance A.ToJSON NodeDescriptionResources where
  toJSON NodeDescriptionResources {..} =
   _omitNulls
      [ "NanoCPUs" .= nodeDescriptionResourcesNanoCpUs
      , "MemoryBytes" .= nodeDescriptionResourcesMemoryBytes
      ]


-- | Construct a value of type 'NodeDescriptionResources' (by applying it's required fields, if any)
mkNodeDescriptionResources
  :: NodeDescriptionResources
mkNodeDescriptionResources =
  NodeDescriptionResources
  { nodeDescriptionResourcesNanoCpUs = Nothing
  , nodeDescriptionResourcesMemoryBytes = Nothing
  }

-- ** NodeSpec
-- | NodeSpec
data NodeSpec = NodeSpec
  { nodeSpecName :: !(Maybe Text) -- ^ "Name" - Name for the node.
  , nodeSpecLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  , nodeSpecRole :: !(Maybe E'Role) -- ^ "Role" - Role of the node.
  , nodeSpecAvailability :: !(Maybe E'Availability) -- ^ "Availability" - Availability of the node.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NodeSpec
instance A.FromJSON NodeSpec where
  parseJSON = A.withObject "NodeSpec" $ \o ->
    NodeSpec
      <$> (o .:? "Name")
      <*> (o .:? "Labels")
      <*> (o .:? "Role")
      <*> (o .:? "Availability")

-- | ToJSON NodeSpec
instance A.ToJSON NodeSpec where
  toJSON NodeSpec {..} =
   _omitNulls
      [ "Name" .= nodeSpecName
      , "Labels" .= nodeSpecLabels
      , "Role" .= nodeSpecRole
      , "Availability" .= nodeSpecAvailability
      ]


-- | Construct a value of type 'NodeSpec' (by applying it's required fields, if any)
mkNodeSpec
  :: NodeSpec
mkNodeSpec =
  NodeSpec
  { nodeSpecName = Nothing
  , nodeSpecLabels = Nothing
  , nodeSpecRole = Nothing
  , nodeSpecAvailability = Nothing
  }

-- ** NodeVersion
-- | NodeVersion
data NodeVersion = NodeVersion
  { nodeVersionIndex :: !(Maybe Integer) -- ^ "Index"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NodeVersion
instance A.FromJSON NodeVersion where
  parseJSON = A.withObject "NodeVersion" $ \o ->
    NodeVersion
      <$> (o .:? "Index")

-- | ToJSON NodeVersion
instance A.ToJSON NodeVersion where
  toJSON NodeVersion {..} =
   _omitNulls
      [ "Index" .= nodeVersionIndex
      ]


-- | Construct a value of type 'NodeVersion' (by applying it's required fields, if any)
mkNodeVersion
  :: NodeVersion
mkNodeVersion =
  NodeVersion
  { nodeVersionIndex = Nothing
  }

-- ** Plugin
-- | Plugin
-- A plugin for the Engine API
data Plugin = Plugin
  { pluginId :: !(Maybe Text) -- ^ "Id"
  , pluginName :: !(Text) -- ^ /Required/ "Name"
  , pluginEnabled :: !(Bool) -- ^ /Required/ "Enabled" - True when the plugin is running. False when the plugin is not running, only installed.
  , pluginSettings :: !(PluginSettings) -- ^ /Required/ "Settings"
  , pluginConfig :: !(PluginConfig) -- ^ /Required/ "Config"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Plugin
instance A.FromJSON Plugin where
  parseJSON = A.withObject "Plugin" $ \o ->
    Plugin
      <$> (o .:? "Id")
      <*> (o .:  "Name")
      <*> (o .:  "Enabled")
      <*> (o .:  "Settings")
      <*> (o .:  "Config")

-- | ToJSON Plugin
instance A.ToJSON Plugin where
  toJSON Plugin {..} =
   _omitNulls
      [ "Id" .= pluginId
      , "Name" .= pluginName
      , "Enabled" .= pluginEnabled
      , "Settings" .= pluginSettings
      , "Config" .= pluginConfig
      ]


-- | Construct a value of type 'Plugin' (by applying it's required fields, if any)
mkPlugin
  :: Text -- ^ 'pluginName' 
  -> Bool -- ^ 'pluginEnabled': True when the plugin is running. False when the plugin is not running, only installed.
  -> PluginSettings -- ^ 'pluginSettings' 
  -> PluginConfig -- ^ 'pluginConfig' 
  -> Plugin
mkPlugin pluginName pluginEnabled pluginSettings pluginConfig =
  Plugin
  { pluginId = Nothing
  , pluginName
  , pluginEnabled
  , pluginSettings
  , pluginConfig
  }

-- ** PluginConfig
-- | PluginConfig
-- The config of a plugin.
data PluginConfig = PluginConfig
  { pluginConfigDescription :: !(Text) -- ^ /Required/ "Description"
  , pluginConfigDocumentation :: !(Text) -- ^ /Required/ "Documentation"
  , pluginConfigInterface :: !(PluginConfigInterface) -- ^ /Required/ "Interface"
  , pluginConfigEntrypoint :: !([Text]) -- ^ /Required/ "Entrypoint"
  , pluginConfigWorkDir :: !(Text) -- ^ /Required/ "WorkDir"
  , pluginConfigUser :: !(Maybe PluginConfigUser) -- ^ "User"
  , pluginConfigNetwork :: !(PluginConfigNetwork) -- ^ /Required/ "Network"
  , pluginConfigLinux :: !(PluginConfigLinux) -- ^ /Required/ "Linux"
  , pluginConfigPropagatedMount :: !(Text) -- ^ /Required/ "PropagatedMount"
  , pluginConfigMounts :: !([PluginMount]) -- ^ /Required/ "Mounts"
  , pluginConfigEnv :: !([PluginEnv]) -- ^ /Required/ "Env"
  , pluginConfigArgs :: !(PluginConfigArgs) -- ^ /Required/ "Args"
  , pluginConfigRootfs :: !(Maybe PluginConfigRootfs) -- ^ "rootfs"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginConfig
instance A.FromJSON PluginConfig where
  parseJSON = A.withObject "PluginConfig" $ \o ->
    PluginConfig
      <$> (o .:  "Description")
      <*> (o .:  "Documentation")
      <*> (o .:  "Interface")
      <*> (o .:  "Entrypoint")
      <*> (o .:  "WorkDir")
      <*> (o .:? "User")
      <*> (o .:  "Network")
      <*> (o .:  "Linux")
      <*> (o .:  "PropagatedMount")
      <*> (o .:  "Mounts")
      <*> (o .:  "Env")
      <*> (o .:  "Args")
      <*> (o .:? "rootfs")

-- | ToJSON PluginConfig
instance A.ToJSON PluginConfig where
  toJSON PluginConfig {..} =
   _omitNulls
      [ "Description" .= pluginConfigDescription
      , "Documentation" .= pluginConfigDocumentation
      , "Interface" .= pluginConfigInterface
      , "Entrypoint" .= pluginConfigEntrypoint
      , "WorkDir" .= pluginConfigWorkDir
      , "User" .= pluginConfigUser
      , "Network" .= pluginConfigNetwork
      , "Linux" .= pluginConfigLinux
      , "PropagatedMount" .= pluginConfigPropagatedMount
      , "Mounts" .= pluginConfigMounts
      , "Env" .= pluginConfigEnv
      , "Args" .= pluginConfigArgs
      , "rootfs" .= pluginConfigRootfs
      ]


-- | Construct a value of type 'PluginConfig' (by applying it's required fields, if any)
mkPluginConfig
  :: Text -- ^ 'pluginConfigDescription' 
  -> Text -- ^ 'pluginConfigDocumentation' 
  -> PluginConfigInterface -- ^ 'pluginConfigInterface' 
  -> [Text] -- ^ 'pluginConfigEntrypoint' 
  -> Text -- ^ 'pluginConfigWorkDir' 
  -> PluginConfigNetwork -- ^ 'pluginConfigNetwork' 
  -> PluginConfigLinux -- ^ 'pluginConfigLinux' 
  -> Text -- ^ 'pluginConfigPropagatedMount' 
  -> [PluginMount] -- ^ 'pluginConfigMounts' 
  -> [PluginEnv] -- ^ 'pluginConfigEnv' 
  -> PluginConfigArgs -- ^ 'pluginConfigArgs' 
  -> PluginConfig
mkPluginConfig pluginConfigDescription pluginConfigDocumentation pluginConfigInterface pluginConfigEntrypoint pluginConfigWorkDir pluginConfigNetwork pluginConfigLinux pluginConfigPropagatedMount pluginConfigMounts pluginConfigEnv pluginConfigArgs =
  PluginConfig
  { pluginConfigDescription
  , pluginConfigDocumentation
  , pluginConfigInterface
  , pluginConfigEntrypoint
  , pluginConfigWorkDir
  , pluginConfigUser = Nothing
  , pluginConfigNetwork
  , pluginConfigLinux
  , pluginConfigPropagatedMount
  , pluginConfigMounts
  , pluginConfigEnv
  , pluginConfigArgs
  , pluginConfigRootfs = Nothing
  }

-- ** PluginConfigArgs
-- | PluginConfigArgs
data PluginConfigArgs = PluginConfigArgs
  { pluginConfigArgsName :: !(Text) -- ^ /Required/ "Name"
  , pluginConfigArgsDescription :: !(Text) -- ^ /Required/ "Description"
  , pluginConfigArgsSettable :: !([Text]) -- ^ /Required/ "Settable"
  , pluginConfigArgsValue :: !([Text]) -- ^ /Required/ "Value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginConfigArgs
instance A.FromJSON PluginConfigArgs where
  parseJSON = A.withObject "PluginConfigArgs" $ \o ->
    PluginConfigArgs
      <$> (o .:  "Name")
      <*> (o .:  "Description")
      <*> (o .:  "Settable")
      <*> (o .:  "Value")

-- | ToJSON PluginConfigArgs
instance A.ToJSON PluginConfigArgs where
  toJSON PluginConfigArgs {..} =
   _omitNulls
      [ "Name" .= pluginConfigArgsName
      , "Description" .= pluginConfigArgsDescription
      , "Settable" .= pluginConfigArgsSettable
      , "Value" .= pluginConfigArgsValue
      ]


-- | Construct a value of type 'PluginConfigArgs' (by applying it's required fields, if any)
mkPluginConfigArgs
  :: Text -- ^ 'pluginConfigArgsName' 
  -> Text -- ^ 'pluginConfigArgsDescription' 
  -> [Text] -- ^ 'pluginConfigArgsSettable' 
  -> [Text] -- ^ 'pluginConfigArgsValue' 
  -> PluginConfigArgs
mkPluginConfigArgs pluginConfigArgsName pluginConfigArgsDescription pluginConfigArgsSettable pluginConfigArgsValue =
  PluginConfigArgs
  { pluginConfigArgsName
  , pluginConfigArgsDescription
  , pluginConfigArgsSettable
  , pluginConfigArgsValue
  }

-- ** PluginConfigInterface
-- | PluginConfigInterface
-- The interface between Docker and the plugin
data PluginConfigInterface = PluginConfigInterface
  { pluginConfigInterfaceTypes :: !([PluginInterfaceType]) -- ^ /Required/ "Types"
  , pluginConfigInterfaceSocket :: !(Text) -- ^ /Required/ "Socket"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginConfigInterface
instance A.FromJSON PluginConfigInterface where
  parseJSON = A.withObject "PluginConfigInterface" $ \o ->
    PluginConfigInterface
      <$> (o .:  "Types")
      <*> (o .:  "Socket")

-- | ToJSON PluginConfigInterface
instance A.ToJSON PluginConfigInterface where
  toJSON PluginConfigInterface {..} =
   _omitNulls
      [ "Types" .= pluginConfigInterfaceTypes
      , "Socket" .= pluginConfigInterfaceSocket
      ]


-- | Construct a value of type 'PluginConfigInterface' (by applying it's required fields, if any)
mkPluginConfigInterface
  :: [PluginInterfaceType] -- ^ 'pluginConfigInterfaceTypes' 
  -> Text -- ^ 'pluginConfigInterfaceSocket' 
  -> PluginConfigInterface
mkPluginConfigInterface pluginConfigInterfaceTypes pluginConfigInterfaceSocket =
  PluginConfigInterface
  { pluginConfigInterfaceTypes
  , pluginConfigInterfaceSocket
  }

-- ** PluginConfigLinux
-- | PluginConfigLinux
data PluginConfigLinux = PluginConfigLinux
  { pluginConfigLinuxCapabilities :: !([Text]) -- ^ /Required/ "Capabilities"
  , pluginConfigLinuxAllowAllDevices :: !(Bool) -- ^ /Required/ "AllowAllDevices"
  , pluginConfigLinuxDevices :: !([PluginDevice]) -- ^ /Required/ "Devices"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginConfigLinux
instance A.FromJSON PluginConfigLinux where
  parseJSON = A.withObject "PluginConfigLinux" $ \o ->
    PluginConfigLinux
      <$> (o .:  "Capabilities")
      <*> (o .:  "AllowAllDevices")
      <*> (o .:  "Devices")

-- | ToJSON PluginConfigLinux
instance A.ToJSON PluginConfigLinux where
  toJSON PluginConfigLinux {..} =
   _omitNulls
      [ "Capabilities" .= pluginConfigLinuxCapabilities
      , "AllowAllDevices" .= pluginConfigLinuxAllowAllDevices
      , "Devices" .= pluginConfigLinuxDevices
      ]


-- | Construct a value of type 'PluginConfigLinux' (by applying it's required fields, if any)
mkPluginConfigLinux
  :: [Text] -- ^ 'pluginConfigLinuxCapabilities' 
  -> Bool -- ^ 'pluginConfigLinuxAllowAllDevices' 
  -> [PluginDevice] -- ^ 'pluginConfigLinuxDevices' 
  -> PluginConfigLinux
mkPluginConfigLinux pluginConfigLinuxCapabilities pluginConfigLinuxAllowAllDevices pluginConfigLinuxDevices =
  PluginConfigLinux
  { pluginConfigLinuxCapabilities
  , pluginConfigLinuxAllowAllDevices
  , pluginConfigLinuxDevices
  }

-- ** PluginConfigNetwork
-- | PluginConfigNetwork
data PluginConfigNetwork = PluginConfigNetwork
  { pluginConfigNetworkType :: !(Text) -- ^ /Required/ "Type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginConfigNetwork
instance A.FromJSON PluginConfigNetwork where
  parseJSON = A.withObject "PluginConfigNetwork" $ \o ->
    PluginConfigNetwork
      <$> (o .:  "Type")

-- | ToJSON PluginConfigNetwork
instance A.ToJSON PluginConfigNetwork where
  toJSON PluginConfigNetwork {..} =
   _omitNulls
      [ "Type" .= pluginConfigNetworkType
      ]


-- | Construct a value of type 'PluginConfigNetwork' (by applying it's required fields, if any)
mkPluginConfigNetwork
  :: Text -- ^ 'pluginConfigNetworkType' 
  -> PluginConfigNetwork
mkPluginConfigNetwork pluginConfigNetworkType =
  PluginConfigNetwork
  { pluginConfigNetworkType
  }

-- ** PluginConfigRootfs
-- | PluginConfigRootfs
data PluginConfigRootfs = PluginConfigRootfs
  { pluginConfigRootfsType :: !(Maybe Text) -- ^ "type"
  , pluginConfigRootfsDiffIds :: !(Maybe [Text]) -- ^ "diff_ids"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginConfigRootfs
instance A.FromJSON PluginConfigRootfs where
  parseJSON = A.withObject "PluginConfigRootfs" $ \o ->
    PluginConfigRootfs
      <$> (o .:? "type")
      <*> (o .:? "diff_ids")

-- | ToJSON PluginConfigRootfs
instance A.ToJSON PluginConfigRootfs where
  toJSON PluginConfigRootfs {..} =
   _omitNulls
      [ "type" .= pluginConfigRootfsType
      , "diff_ids" .= pluginConfigRootfsDiffIds
      ]


-- | Construct a value of type 'PluginConfigRootfs' (by applying it's required fields, if any)
mkPluginConfigRootfs
  :: PluginConfigRootfs
mkPluginConfigRootfs =
  PluginConfigRootfs
  { pluginConfigRootfsType = Nothing
  , pluginConfigRootfsDiffIds = Nothing
  }

-- ** PluginConfigUser
-- | PluginConfigUser
data PluginConfigUser = PluginConfigUser
  { pluginConfigUserUid :: !(Maybe Int) -- ^ "UID"
  , pluginConfigUserGid :: !(Maybe Int) -- ^ "GID"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginConfigUser
instance A.FromJSON PluginConfigUser where
  parseJSON = A.withObject "PluginConfigUser" $ \o ->
    PluginConfigUser
      <$> (o .:? "UID")
      <*> (o .:? "GID")

-- | ToJSON PluginConfigUser
instance A.ToJSON PluginConfigUser where
  toJSON PluginConfigUser {..} =
   _omitNulls
      [ "UID" .= pluginConfigUserUid
      , "GID" .= pluginConfigUserGid
      ]


-- | Construct a value of type 'PluginConfigUser' (by applying it's required fields, if any)
mkPluginConfigUser
  :: PluginConfigUser
mkPluginConfigUser =
  PluginConfigUser
  { pluginConfigUserUid = Nothing
  , pluginConfigUserGid = Nothing
  }

-- ** PluginDevice
-- | PluginDevice
data PluginDevice = PluginDevice
  { pluginDeviceName :: !(Text) -- ^ /Required/ "Name"
  , pluginDeviceDescription :: !(Text) -- ^ /Required/ "Description"
  , pluginDeviceSettable :: !([Text]) -- ^ /Required/ "Settable"
  , pluginDevicePath :: !(Text) -- ^ /Required/ "Path"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginDevice
instance A.FromJSON PluginDevice where
  parseJSON = A.withObject "PluginDevice" $ \o ->
    PluginDevice
      <$> (o .:  "Name")
      <*> (o .:  "Description")
      <*> (o .:  "Settable")
      <*> (o .:  "Path")

-- | ToJSON PluginDevice
instance A.ToJSON PluginDevice where
  toJSON PluginDevice {..} =
   _omitNulls
      [ "Name" .= pluginDeviceName
      , "Description" .= pluginDeviceDescription
      , "Settable" .= pluginDeviceSettable
      , "Path" .= pluginDevicePath
      ]


-- | Construct a value of type 'PluginDevice' (by applying it's required fields, if any)
mkPluginDevice
  :: Text -- ^ 'pluginDeviceName' 
  -> Text -- ^ 'pluginDeviceDescription' 
  -> [Text] -- ^ 'pluginDeviceSettable' 
  -> Text -- ^ 'pluginDevicePath' 
  -> PluginDevice
mkPluginDevice pluginDeviceName pluginDeviceDescription pluginDeviceSettable pluginDevicePath =
  PluginDevice
  { pluginDeviceName
  , pluginDeviceDescription
  , pluginDeviceSettable
  , pluginDevicePath
  }

-- ** PluginEnv
-- | PluginEnv
data PluginEnv = PluginEnv
  { pluginEnvName :: !(Text) -- ^ /Required/ "Name"
  , pluginEnvDescription :: !(Text) -- ^ /Required/ "Description"
  , pluginEnvSettable :: !([Text]) -- ^ /Required/ "Settable"
  , pluginEnvValue :: !(Text) -- ^ /Required/ "Value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginEnv
instance A.FromJSON PluginEnv where
  parseJSON = A.withObject "PluginEnv" $ \o ->
    PluginEnv
      <$> (o .:  "Name")
      <*> (o .:  "Description")
      <*> (o .:  "Settable")
      <*> (o .:  "Value")

-- | ToJSON PluginEnv
instance A.ToJSON PluginEnv where
  toJSON PluginEnv {..} =
   _omitNulls
      [ "Name" .= pluginEnvName
      , "Description" .= pluginEnvDescription
      , "Settable" .= pluginEnvSettable
      , "Value" .= pluginEnvValue
      ]


-- | Construct a value of type 'PluginEnv' (by applying it's required fields, if any)
mkPluginEnv
  :: Text -- ^ 'pluginEnvName' 
  -> Text -- ^ 'pluginEnvDescription' 
  -> [Text] -- ^ 'pluginEnvSettable' 
  -> Text -- ^ 'pluginEnvValue' 
  -> PluginEnv
mkPluginEnv pluginEnvName pluginEnvDescription pluginEnvSettable pluginEnvValue =
  PluginEnv
  { pluginEnvName
  , pluginEnvDescription
  , pluginEnvSettable
  , pluginEnvValue
  }

-- ** PluginInterfaceType
-- | PluginInterfaceType
data PluginInterfaceType = PluginInterfaceType
  { pluginInterfaceTypePrefix :: !(Text) -- ^ /Required/ "Prefix"
  , pluginInterfaceTypeCapability :: !(Text) -- ^ /Required/ "Capability"
  , pluginInterfaceTypeVersion :: !(Text) -- ^ /Required/ "Version"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginInterfaceType
instance A.FromJSON PluginInterfaceType where
  parseJSON = A.withObject "PluginInterfaceType" $ \o ->
    PluginInterfaceType
      <$> (o .:  "Prefix")
      <*> (o .:  "Capability")
      <*> (o .:  "Version")

-- | ToJSON PluginInterfaceType
instance A.ToJSON PluginInterfaceType where
  toJSON PluginInterfaceType {..} =
   _omitNulls
      [ "Prefix" .= pluginInterfaceTypePrefix
      , "Capability" .= pluginInterfaceTypeCapability
      , "Version" .= pluginInterfaceTypeVersion
      ]


-- | Construct a value of type 'PluginInterfaceType' (by applying it's required fields, if any)
mkPluginInterfaceType
  :: Text -- ^ 'pluginInterfaceTypePrefix' 
  -> Text -- ^ 'pluginInterfaceTypeCapability' 
  -> Text -- ^ 'pluginInterfaceTypeVersion' 
  -> PluginInterfaceType
mkPluginInterfaceType pluginInterfaceTypePrefix pluginInterfaceTypeCapability pluginInterfaceTypeVersion =
  PluginInterfaceType
  { pluginInterfaceTypePrefix
  , pluginInterfaceTypeCapability
  , pluginInterfaceTypeVersion
  }

-- ** PluginMount
-- | PluginMount
data PluginMount = PluginMount
  { pluginMountName :: !(Text) -- ^ /Required/ "Name"
  , pluginMountDescription :: !(Text) -- ^ /Required/ "Description"
  , pluginMountSettable :: !([Text]) -- ^ /Required/ "Settable"
  , pluginMountSource :: !(Text) -- ^ /Required/ "Source"
  , pluginMountDestination :: !(Text) -- ^ /Required/ "Destination"
  , pluginMountType :: !(Text) -- ^ /Required/ "Type"
  , pluginMountOptions :: !([Text]) -- ^ /Required/ "Options"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginMount
instance A.FromJSON PluginMount where
  parseJSON = A.withObject "PluginMount" $ \o ->
    PluginMount
      <$> (o .:  "Name")
      <*> (o .:  "Description")
      <*> (o .:  "Settable")
      <*> (o .:  "Source")
      <*> (o .:  "Destination")
      <*> (o .:  "Type")
      <*> (o .:  "Options")

-- | ToJSON PluginMount
instance A.ToJSON PluginMount where
  toJSON PluginMount {..} =
   _omitNulls
      [ "Name" .= pluginMountName
      , "Description" .= pluginMountDescription
      , "Settable" .= pluginMountSettable
      , "Source" .= pluginMountSource
      , "Destination" .= pluginMountDestination
      , "Type" .= pluginMountType
      , "Options" .= pluginMountOptions
      ]


-- | Construct a value of type 'PluginMount' (by applying it's required fields, if any)
mkPluginMount
  :: Text -- ^ 'pluginMountName' 
  -> Text -- ^ 'pluginMountDescription' 
  -> [Text] -- ^ 'pluginMountSettable' 
  -> Text -- ^ 'pluginMountSource' 
  -> Text -- ^ 'pluginMountDestination' 
  -> Text -- ^ 'pluginMountType' 
  -> [Text] -- ^ 'pluginMountOptions' 
  -> PluginMount
mkPluginMount pluginMountName pluginMountDescription pluginMountSettable pluginMountSource pluginMountDestination pluginMountType pluginMountOptions =
  PluginMount
  { pluginMountName
  , pluginMountDescription
  , pluginMountSettable
  , pluginMountSource
  , pluginMountDestination
  , pluginMountType
  , pluginMountOptions
  }

-- ** PluginSettings
-- | PluginSettings
-- Settings that can be modified by users.
data PluginSettings = PluginSettings
  { pluginSettingsMounts :: !([PluginMount]) -- ^ /Required/ "Mounts"
  , pluginSettingsEnv :: !([Text]) -- ^ /Required/ "Env"
  , pluginSettingsArgs :: !([Text]) -- ^ /Required/ "Args"
  , pluginSettingsDevices :: !([PluginDevice]) -- ^ /Required/ "Devices"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginSettings
instance A.FromJSON PluginSettings where
  parseJSON = A.withObject "PluginSettings" $ \o ->
    PluginSettings
      <$> (o .:  "Mounts")
      <*> (o .:  "Env")
      <*> (o .:  "Args")
      <*> (o .:  "Devices")

-- | ToJSON PluginSettings
instance A.ToJSON PluginSettings where
  toJSON PluginSettings {..} =
   _omitNulls
      [ "Mounts" .= pluginSettingsMounts
      , "Env" .= pluginSettingsEnv
      , "Args" .= pluginSettingsArgs
      , "Devices" .= pluginSettingsDevices
      ]


-- | Construct a value of type 'PluginSettings' (by applying it's required fields, if any)
mkPluginSettings
  :: [PluginMount] -- ^ 'pluginSettingsMounts' 
  -> [Text] -- ^ 'pluginSettingsEnv' 
  -> [Text] -- ^ 'pluginSettingsArgs' 
  -> [PluginDevice] -- ^ 'pluginSettingsDevices' 
  -> PluginSettings
mkPluginSettings pluginSettingsMounts pluginSettingsEnv pluginSettingsArgs pluginSettingsDevices =
  PluginSettings
  { pluginSettingsMounts
  , pluginSettingsEnv
  , pluginSettingsArgs
  , pluginSettingsDevices
  }

-- ** Port
-- | Port
-- An open port on a container
data Port = Port
  { portIp :: !(Maybe Text) -- ^ "IP"
  , portPrivatePort :: !(Int) -- ^ /Required/ "PrivatePort" - Port on the container
  , portPublicPort :: !(Maybe Int) -- ^ "PublicPort" - Port exposed on the host
  , portType :: !(E'Type) -- ^ /Required/ "Type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Port
instance A.FromJSON Port where
  parseJSON = A.withObject "Port" $ \o ->
    Port
      <$> (o .:? "IP")
      <*> (o .:  "PrivatePort")
      <*> (o .:? "PublicPort")
      <*> (o .:  "Type")

-- | ToJSON Port
instance A.ToJSON Port where
  toJSON Port {..} =
   _omitNulls
      [ "IP" .= portIp
      , "PrivatePort" .= portPrivatePort
      , "PublicPort" .= portPublicPort
      , "Type" .= portType
      ]


-- | Construct a value of type 'Port' (by applying it's required fields, if any)
mkPort
  :: Int -- ^ 'portPrivatePort': Port on the container
  -> E'Type -- ^ 'portType' 
  -> Port
mkPort portPrivatePort portType =
  Port
  { portIp = Nothing
  , portPrivatePort
  , portPublicPort = Nothing
  , portType
  }

-- ** ProcessConfig
-- | ProcessConfig
data ProcessConfig = ProcessConfig
  { processConfigPrivileged :: !(Maybe Bool) -- ^ "privileged"
  , processConfigUser :: !(Maybe Text) -- ^ "user"
  , processConfigTty :: !(Maybe Bool) -- ^ "tty"
  , processConfigEntrypoint :: !(Maybe Text) -- ^ "entrypoint"
  , processConfigArguments :: !(Maybe [Text]) -- ^ "arguments"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProcessConfig
instance A.FromJSON ProcessConfig where
  parseJSON = A.withObject "ProcessConfig" $ \o ->
    ProcessConfig
      <$> (o .:? "privileged")
      <*> (o .:? "user")
      <*> (o .:? "tty")
      <*> (o .:? "entrypoint")
      <*> (o .:? "arguments")

-- | ToJSON ProcessConfig
instance A.ToJSON ProcessConfig where
  toJSON ProcessConfig {..} =
   _omitNulls
      [ "privileged" .= processConfigPrivileged
      , "user" .= processConfigUser
      , "tty" .= processConfigTty
      , "entrypoint" .= processConfigEntrypoint
      , "arguments" .= processConfigArguments
      ]


-- | Construct a value of type 'ProcessConfig' (by applying it's required fields, if any)
mkProcessConfig
  :: ProcessConfig
mkProcessConfig =
  ProcessConfig
  { processConfigPrivileged = Nothing
  , processConfigUser = Nothing
  , processConfigTty = Nothing
  , processConfigEntrypoint = Nothing
  , processConfigArguments = Nothing
  }

-- ** ProgressDetail
-- | ProgressDetail
data ProgressDetail = ProgressDetail
  { progressDetailCode :: !(Maybe Int) -- ^ "code"
  , progressDetailMessage :: !(Maybe Int) -- ^ "message"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProgressDetail
instance A.FromJSON ProgressDetail where
  parseJSON = A.withObject "ProgressDetail" $ \o ->
    ProgressDetail
      <$> (o .:? "code")
      <*> (o .:? "message")

-- | ToJSON ProgressDetail
instance A.ToJSON ProgressDetail where
  toJSON ProgressDetail {..} =
   _omitNulls
      [ "code" .= progressDetailCode
      , "message" .= progressDetailMessage
      ]


-- | Construct a value of type 'ProgressDetail' (by applying it's required fields, if any)
mkProgressDetail
  :: ProgressDetail
mkProgressDetail =
  ProgressDetail
  { progressDetailCode = Nothing
  , progressDetailMessage = Nothing
  }

-- ** PushImageInfo
-- | PushImageInfo
data PushImageInfo = PushImageInfo
  { pushImageInfoError :: !(Maybe Text) -- ^ "error"
  , pushImageInfoStatus :: !(Maybe Text) -- ^ "status"
  , pushImageInfoProgress :: !(Maybe Text) -- ^ "progress"
  , pushImageInfoProgressDetail :: !(Maybe ProgressDetail) -- ^ "progressDetail"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PushImageInfo
instance A.FromJSON PushImageInfo where
  parseJSON = A.withObject "PushImageInfo" $ \o ->
    PushImageInfo
      <$> (o .:? "error")
      <*> (o .:? "status")
      <*> (o .:? "progress")
      <*> (o .:? "progressDetail")

-- | ToJSON PushImageInfo
instance A.ToJSON PushImageInfo where
  toJSON PushImageInfo {..} =
   _omitNulls
      [ "error" .= pushImageInfoError
      , "status" .= pushImageInfoStatus
      , "progress" .= pushImageInfoProgress
      , "progressDetail" .= pushImageInfoProgressDetail
      ]


-- | Construct a value of type 'PushImageInfo' (by applying it's required fields, if any)
mkPushImageInfo
  :: PushImageInfo
mkPushImageInfo =
  PushImageInfo
  { pushImageInfoError = Nothing
  , pushImageInfoStatus = Nothing
  , pushImageInfoProgress = Nothing
  , pushImageInfoProgressDetail = Nothing
  }

-- ** Resources
-- | Resources
-- A container's resources (cgroups config, ulimits, etc)
data Resources = Resources
  { resourcesCpuShares :: !(Maybe Int) -- ^ "CpuShares" - An integer value representing this container&#39;s relative CPU weight versus other containers.
  , resourcesMemory :: !(Maybe Int) -- ^ "Memory" - Memory limit in bytes.
  , resourcesCgroupParent :: !(Maybe Text) -- ^ "CgroupParent" - Path to &#x60;cgroups&#x60; under which the container&#39;s &#x60;cgroup&#x60; is created. If the path is not absolute, the path is considered to be relative to the &#x60;cgroups&#x60; path of the init process. Cgroups are created if they do not already exist.
  , resourcesBlkioWeight :: !(Maybe Int) -- ^ "BlkioWeight" - Block IO weight (relative weight).
  , resourcesBlkioWeightDevice :: !(Maybe [ResourcesBlkioWeightDevice]) -- ^ "BlkioWeightDevice" - Block IO weight (relative device weight) in the form &#x60;[{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Weight\&quot;: weight}]&#x60;. 
  , resourcesBlkioDeviceReadBps :: !(Maybe [ThrottleDevice]) -- ^ "BlkioDeviceReadBps" - Limit read rate (bytes per second) from a device, in the form &#x60;[{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Rate\&quot;: rate}]&#x60;. 
  , resourcesBlkioDeviceWriteBps :: !(Maybe [ThrottleDevice]) -- ^ "BlkioDeviceWriteBps" - Limit write rate (bytes per second) to a device, in the form &#x60;[{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Rate\&quot;: rate}]&#x60;. 
  , resourcesBlkioDeviceReadIOps :: !(Maybe [ThrottleDevice]) -- ^ "BlkioDeviceReadIOps" - Limit read rate (IO per second) from a device, in the form &#x60;[{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Rate\&quot;: rate}]&#x60;. 
  , resourcesBlkioDeviceWriteIOps :: !(Maybe [ThrottleDevice]) -- ^ "BlkioDeviceWriteIOps" - Limit write rate (IO per second) to a device, in the form &#x60;[{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Rate\&quot;: rate}]&#x60;. 
  , resourcesCpuPeriod :: !(Maybe Integer) -- ^ "CpuPeriod" - The length of a CPU period in microseconds.
  , resourcesCpuQuota :: !(Maybe Integer) -- ^ "CpuQuota" - Microseconds of CPU time that the container can get in a CPU period.
  , resourcesCpuRealtimePeriod :: !(Maybe Integer) -- ^ "CpuRealtimePeriod" - The length of a CPU real-time period in microseconds. Set to 0 to allocate no time allocated to real-time tasks.
  , resourcesCpuRealtimeRuntime :: !(Maybe Integer) -- ^ "CpuRealtimeRuntime" - The length of a CPU real-time runtime in microseconds. Set to 0 to allocate no time allocated to real-time tasks.
  , resourcesCpusetCpus :: !(Maybe Text) -- ^ "CpusetCpus" - CPUs in which to allow execution (e.g., &#x60;0-3&#x60;, &#x60;0,1&#x60;)
  , resourcesCpusetMems :: !(Maybe Text) -- ^ "CpusetMems" - Memory nodes (MEMs) in which to allow execution (0-3, 0,1). Only effective on NUMA systems.
  , resourcesDevices :: !(Maybe [DeviceMapping]) -- ^ "Devices" - A list of devices to add to the container.
  , resourcesDiskQuota :: !(Maybe Integer) -- ^ "DiskQuota" - Disk limit (in bytes).
  , resourcesKernelMemory :: !(Maybe Integer) -- ^ "KernelMemory" - Kernel memory limit in bytes.
  , resourcesMemoryReservation :: !(Maybe Integer) -- ^ "MemoryReservation" - Memory soft limit in bytes.
  , resourcesMemorySwap :: !(Maybe Integer) -- ^ "MemorySwap" - Total memory limit (memory + swap). Set as &#x60;-1&#x60; to enable unlimited swap.
  , resourcesMemorySwappiness :: !(Maybe Integer) -- ^ "MemorySwappiness" - Tune a container&#39;s memory swappiness behavior. Accepts an integer between 0 and 100.
  , resourcesNanoCpUs :: !(Maybe Integer) -- ^ "NanoCPUs" - CPU quota in units of 10&lt;sup&gt;-9&lt;/sup&gt; CPUs.
  , resourcesOomKillDisable :: !(Maybe Bool) -- ^ "OomKillDisable" - Disable OOM Killer for the container.
  , resourcesPidsLimit :: !(Maybe Integer) -- ^ "PidsLimit" - Tune a container&#39;s pids limit. Set -1 for unlimited.
  , resourcesUlimits :: !(Maybe [ResourcesUlimits]) -- ^ "Ulimits" - A list of resource limits to set in the container. For example: &#x60;{\&quot;Name\&quot;: \&quot;nofile\&quot;, \&quot;Soft\&quot;: 1024, \&quot;Hard\&quot;: 2048}&#x60;\&quot; 
  , resourcesCpuCount :: !(Maybe Integer) -- ^ "CpuCount" - The number of usable CPUs (Windows only).  On Windows Server containers, the processor resource controls are mutually exclusive. The order of precedence is &#x60;CPUCount&#x60; first, then &#x60;CPUShares&#x60;, and &#x60;CPUPercent&#x60; last. 
  , resourcesCpuPercent :: !(Maybe Integer) -- ^ "CpuPercent" - The usable percentage of the available CPUs (Windows only).  On Windows Server containers, the processor resource controls are mutually exclusive. The order of precedence is &#x60;CPUCount&#x60; first, then &#x60;CPUShares&#x60;, and &#x60;CPUPercent&#x60; last. 
  , resourcesIoMaximumIOps :: !(Maybe Integer) -- ^ "IOMaximumIOps" - Maximum IOps for the container system drive (Windows only)
  , resourcesIoMaximumBandwidth :: !(Maybe Integer) -- ^ "IOMaximumBandwidth" - Maximum IO in bytes per second for the container system drive (Windows only)
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Resources
instance A.FromJSON Resources where
  parseJSON = A.withObject "Resources" $ \o ->
    Resources
      <$> (o .:? "CpuShares")
      <*> (o .:? "Memory")
      <*> (o .:? "CgroupParent")
      <*> (o .:? "BlkioWeight")
      <*> (o .:? "BlkioWeightDevice")
      <*> (o .:? "BlkioDeviceReadBps")
      <*> (o .:? "BlkioDeviceWriteBps")
      <*> (o .:? "BlkioDeviceReadIOps")
      <*> (o .:? "BlkioDeviceWriteIOps")
      <*> (o .:? "CpuPeriod")
      <*> (o .:? "CpuQuota")
      <*> (o .:? "CpuRealtimePeriod")
      <*> (o .:? "CpuRealtimeRuntime")
      <*> (o .:? "CpusetCpus")
      <*> (o .:? "CpusetMems")
      <*> (o .:? "Devices")
      <*> (o .:? "DiskQuota")
      <*> (o .:? "KernelMemory")
      <*> (o .:? "MemoryReservation")
      <*> (o .:? "MemorySwap")
      <*> (o .:? "MemorySwappiness")
      <*> (o .:? "NanoCPUs")
      <*> (o .:? "OomKillDisable")
      <*> (o .:? "PidsLimit")
      <*> (o .:? "Ulimits")
      <*> (o .:? "CpuCount")
      <*> (o .:? "CpuPercent")
      <*> (o .:? "IOMaximumIOps")
      <*> (o .:? "IOMaximumBandwidth")

-- | ToJSON Resources
instance A.ToJSON Resources where
  toJSON Resources {..} =
   _omitNulls
      [ "CpuShares" .= resourcesCpuShares
      , "Memory" .= resourcesMemory
      , "CgroupParent" .= resourcesCgroupParent
      , "BlkioWeight" .= resourcesBlkioWeight
      , "BlkioWeightDevice" .= resourcesBlkioWeightDevice
      , "BlkioDeviceReadBps" .= resourcesBlkioDeviceReadBps
      , "BlkioDeviceWriteBps" .= resourcesBlkioDeviceWriteBps
      , "BlkioDeviceReadIOps" .= resourcesBlkioDeviceReadIOps
      , "BlkioDeviceWriteIOps" .= resourcesBlkioDeviceWriteIOps
      , "CpuPeriod" .= resourcesCpuPeriod
      , "CpuQuota" .= resourcesCpuQuota
      , "CpuRealtimePeriod" .= resourcesCpuRealtimePeriod
      , "CpuRealtimeRuntime" .= resourcesCpuRealtimeRuntime
      , "CpusetCpus" .= resourcesCpusetCpus
      , "CpusetMems" .= resourcesCpusetMems
      , "Devices" .= resourcesDevices
      , "DiskQuota" .= resourcesDiskQuota
      , "KernelMemory" .= resourcesKernelMemory
      , "MemoryReservation" .= resourcesMemoryReservation
      , "MemorySwap" .= resourcesMemorySwap
      , "MemorySwappiness" .= resourcesMemorySwappiness
      , "NanoCPUs" .= resourcesNanoCpUs
      , "OomKillDisable" .= resourcesOomKillDisable
      , "PidsLimit" .= resourcesPidsLimit
      , "Ulimits" .= resourcesUlimits
      , "CpuCount" .= resourcesCpuCount
      , "CpuPercent" .= resourcesCpuPercent
      , "IOMaximumIOps" .= resourcesIoMaximumIOps
      , "IOMaximumBandwidth" .= resourcesIoMaximumBandwidth
      ]


-- | Construct a value of type 'Resources' (by applying it's required fields, if any)
mkResources
  :: Resources
mkResources =
  Resources
  { resourcesCpuShares = Nothing
  , resourcesMemory = Nothing
  , resourcesCgroupParent = Nothing
  , resourcesBlkioWeight = Nothing
  , resourcesBlkioWeightDevice = Nothing
  , resourcesBlkioDeviceReadBps = Nothing
  , resourcesBlkioDeviceWriteBps = Nothing
  , resourcesBlkioDeviceReadIOps = Nothing
  , resourcesBlkioDeviceWriteIOps = Nothing
  , resourcesCpuPeriod = Nothing
  , resourcesCpuQuota = Nothing
  , resourcesCpuRealtimePeriod = Nothing
  , resourcesCpuRealtimeRuntime = Nothing
  , resourcesCpusetCpus = Nothing
  , resourcesCpusetMems = Nothing
  , resourcesDevices = Nothing
  , resourcesDiskQuota = Nothing
  , resourcesKernelMemory = Nothing
  , resourcesMemoryReservation = Nothing
  , resourcesMemorySwap = Nothing
  , resourcesMemorySwappiness = Nothing
  , resourcesNanoCpUs = Nothing
  , resourcesOomKillDisable = Nothing
  , resourcesPidsLimit = Nothing
  , resourcesUlimits = Nothing
  , resourcesCpuCount = Nothing
  , resourcesCpuPercent = Nothing
  , resourcesIoMaximumIOps = Nothing
  , resourcesIoMaximumBandwidth = Nothing
  }

-- ** ResourcesBlkioWeightDevice
-- | ResourcesBlkioWeightDevice
data ResourcesBlkioWeightDevice = ResourcesBlkioWeightDevice
  { resourcesBlkioWeightDevicePath :: !(Maybe Text) -- ^ "Path"
  , resourcesBlkioWeightDeviceWeight :: !(Maybe Int) -- ^ "Weight"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResourcesBlkioWeightDevice
instance A.FromJSON ResourcesBlkioWeightDevice where
  parseJSON = A.withObject "ResourcesBlkioWeightDevice" $ \o ->
    ResourcesBlkioWeightDevice
      <$> (o .:? "Path")
      <*> (o .:? "Weight")

-- | ToJSON ResourcesBlkioWeightDevice
instance A.ToJSON ResourcesBlkioWeightDevice where
  toJSON ResourcesBlkioWeightDevice {..} =
   _omitNulls
      [ "Path" .= resourcesBlkioWeightDevicePath
      , "Weight" .= resourcesBlkioWeightDeviceWeight
      ]


-- | Construct a value of type 'ResourcesBlkioWeightDevice' (by applying it's required fields, if any)
mkResourcesBlkioWeightDevice
  :: ResourcesBlkioWeightDevice
mkResourcesBlkioWeightDevice =
  ResourcesBlkioWeightDevice
  { resourcesBlkioWeightDevicePath = Nothing
  , resourcesBlkioWeightDeviceWeight = Nothing
  }

-- ** ResourcesUlimits
-- | ResourcesUlimits
data ResourcesUlimits = ResourcesUlimits
  { resourcesUlimitsName :: !(Maybe Text) -- ^ "Name" - Name of ulimit
  , resourcesUlimitsSoft :: !(Maybe Int) -- ^ "Soft" - Soft limit
  , resourcesUlimitsHard :: !(Maybe Int) -- ^ "Hard" - Hard limit
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResourcesUlimits
instance A.FromJSON ResourcesUlimits where
  parseJSON = A.withObject "ResourcesUlimits" $ \o ->
    ResourcesUlimits
      <$> (o .:? "Name")
      <*> (o .:? "Soft")
      <*> (o .:? "Hard")

-- | ToJSON ResourcesUlimits
instance A.ToJSON ResourcesUlimits where
  toJSON ResourcesUlimits {..} =
   _omitNulls
      [ "Name" .= resourcesUlimitsName
      , "Soft" .= resourcesUlimitsSoft
      , "Hard" .= resourcesUlimitsHard
      ]


-- | Construct a value of type 'ResourcesUlimits' (by applying it's required fields, if any)
mkResourcesUlimits
  :: ResourcesUlimits
mkResourcesUlimits =
  ResourcesUlimits
  { resourcesUlimitsName = Nothing
  , resourcesUlimitsSoft = Nothing
  , resourcesUlimitsHard = Nothing
  }

-- ** RestartPolicy
-- | RestartPolicy
-- The behavior to apply when the container exits. The default is not to restart.  An ever increasing delay (double the previous delay, starting at 100ms) is added before each restart to prevent flooding the server. 
data RestartPolicy = RestartPolicy
  { restartPolicyName :: !(Maybe E'Name) -- ^ "Name" - - &#x60;always&#x60; Always restart - &#x60;unless-stopped&#x60; Restart always except when the user has manually stopped the container - &#x60;on-failure&#x60; Restart only when the container exit code is non-zero 
  , restartPolicyMaximumRetryCount :: !(Maybe Int) -- ^ "MaximumRetryCount" - If &#x60;on-failure&#x60; is used, the number of times to retry before giving up
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RestartPolicy
instance A.FromJSON RestartPolicy where
  parseJSON = A.withObject "RestartPolicy" $ \o ->
    RestartPolicy
      <$> (o .:? "Name")
      <*> (o .:? "MaximumRetryCount")

-- | ToJSON RestartPolicy
instance A.ToJSON RestartPolicy where
  toJSON RestartPolicy {..} =
   _omitNulls
      [ "Name" .= restartPolicyName
      , "MaximumRetryCount" .= restartPolicyMaximumRetryCount
      ]


-- | Construct a value of type 'RestartPolicy' (by applying it's required fields, if any)
mkRestartPolicy
  :: RestartPolicy
mkRestartPolicy =
  RestartPolicy
  { restartPolicyName = Nothing
  , restartPolicyMaximumRetryCount = Nothing
  }

-- ** Secret
-- | Secret
data Secret = Secret
  { secretId :: !(Maybe Text) -- ^ "ID"
  , secretVersion :: !(Maybe NodeVersion) -- ^ "Version"
  , secretCreatedAt :: !(Maybe Text) -- ^ "CreatedAt"
  , secretUpdatedAt :: !(Maybe Text) -- ^ "UpdatedAt"
  , secretSpec :: !(Maybe ServiceSpec) -- ^ "Spec"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Secret
instance A.FromJSON Secret where
  parseJSON = A.withObject "Secret" $ \o ->
    Secret
      <$> (o .:? "ID")
      <*> (o .:? "Version")
      <*> (o .:? "CreatedAt")
      <*> (o .:? "UpdatedAt")
      <*> (o .:? "Spec")

-- | ToJSON Secret
instance A.ToJSON Secret where
  toJSON Secret {..} =
   _omitNulls
      [ "ID" .= secretId
      , "Version" .= secretVersion
      , "CreatedAt" .= secretCreatedAt
      , "UpdatedAt" .= secretUpdatedAt
      , "Spec" .= secretSpec
      ]


-- | Construct a value of type 'Secret' (by applying it's required fields, if any)
mkSecret
  :: Secret
mkSecret =
  Secret
  { secretId = Nothing
  , secretVersion = Nothing
  , secretCreatedAt = Nothing
  , secretUpdatedAt = Nothing
  , secretSpec = Nothing
  }

-- ** SecretSpec
-- | SecretSpec
data SecretSpec = SecretSpec
  { secretSpecName :: !(Maybe Text) -- ^ "Name" - User-defined name of the secret.
  , secretSpecLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  , secretSpecData :: !(Maybe [Text]) -- ^ "Data" - Base64-url-safe-encoded secret data
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SecretSpec
instance A.FromJSON SecretSpec where
  parseJSON = A.withObject "SecretSpec" $ \o ->
    SecretSpec
      <$> (o .:? "Name")
      <*> (o .:? "Labels")
      <*> (o .:? "Data")

-- | ToJSON SecretSpec
instance A.ToJSON SecretSpec where
  toJSON SecretSpec {..} =
   _omitNulls
      [ "Name" .= secretSpecName
      , "Labels" .= secretSpecLabels
      , "Data" .= secretSpecData
      ]


-- | Construct a value of type 'SecretSpec' (by applying it's required fields, if any)
mkSecretSpec
  :: SecretSpec
mkSecretSpec =
  SecretSpec
  { secretSpecName = Nothing
  , secretSpecLabels = Nothing
  , secretSpecData = Nothing
  }

-- ** Service
-- | Service
data Service = Service
  { serviceId :: !(Maybe Text) -- ^ "ID"
  , serviceVersion :: !(Maybe NodeVersion) -- ^ "Version"
  , serviceCreatedAt :: !(Maybe Text) -- ^ "CreatedAt"
  , serviceUpdatedAt :: !(Maybe Text) -- ^ "UpdatedAt"
  , serviceSpec :: !(Maybe ServiceSpec) -- ^ "Spec"
  , serviceEndpoint :: !(Maybe ServiceEndpoint) -- ^ "Endpoint"
  , serviceUpdateStatus :: !(Maybe ServiceUpdateStatus) -- ^ "UpdateStatus"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Service
instance A.FromJSON Service where
  parseJSON = A.withObject "Service" $ \o ->
    Service
      <$> (o .:? "ID")
      <*> (o .:? "Version")
      <*> (o .:? "CreatedAt")
      <*> (o .:? "UpdatedAt")
      <*> (o .:? "Spec")
      <*> (o .:? "Endpoint")
      <*> (o .:? "UpdateStatus")

-- | ToJSON Service
instance A.ToJSON Service where
  toJSON Service {..} =
   _omitNulls
      [ "ID" .= serviceId
      , "Version" .= serviceVersion
      , "CreatedAt" .= serviceCreatedAt
      , "UpdatedAt" .= serviceUpdatedAt
      , "Spec" .= serviceSpec
      , "Endpoint" .= serviceEndpoint
      , "UpdateStatus" .= serviceUpdateStatus
      ]


-- | Construct a value of type 'Service' (by applying it's required fields, if any)
mkService
  :: Service
mkService =
  Service
  { serviceId = Nothing
  , serviceVersion = Nothing
  , serviceCreatedAt = Nothing
  , serviceUpdatedAt = Nothing
  , serviceSpec = Nothing
  , serviceEndpoint = Nothing
  , serviceUpdateStatus = Nothing
  }

-- ** ServiceEndpoint
-- | ServiceEndpoint
data ServiceEndpoint = ServiceEndpoint
  { serviceEndpointSpec :: !(Maybe EndpointSpec) -- ^ "Spec"
  , serviceEndpointPorts :: !(Maybe [EndpointPortConfig]) -- ^ "Ports"
  , serviceEndpointVirtualIPs :: !(Maybe [ServiceEndpointVirtualIPs]) -- ^ "VirtualIPs"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceEndpoint
instance A.FromJSON ServiceEndpoint where
  parseJSON = A.withObject "ServiceEndpoint" $ \o ->
    ServiceEndpoint
      <$> (o .:? "Spec")
      <*> (o .:? "Ports")
      <*> (o .:? "VirtualIPs")

-- | ToJSON ServiceEndpoint
instance A.ToJSON ServiceEndpoint where
  toJSON ServiceEndpoint {..} =
   _omitNulls
      [ "Spec" .= serviceEndpointSpec
      , "Ports" .= serviceEndpointPorts
      , "VirtualIPs" .= serviceEndpointVirtualIPs
      ]


-- | Construct a value of type 'ServiceEndpoint' (by applying it's required fields, if any)
mkServiceEndpoint
  :: ServiceEndpoint
mkServiceEndpoint =
  ServiceEndpoint
  { serviceEndpointSpec = Nothing
  , serviceEndpointPorts = Nothing
  , serviceEndpointVirtualIPs = Nothing
  }

-- ** ServiceEndpointVirtualIPs
-- | ServiceEndpointVirtualIPs
data ServiceEndpointVirtualIPs = ServiceEndpointVirtualIPs
  { serviceEndpointVirtualIPsNetworkId :: !(Maybe Text) -- ^ "NetworkID"
  , serviceEndpointVirtualIPsAddr :: !(Maybe Text) -- ^ "Addr"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceEndpointVirtualIPs
instance A.FromJSON ServiceEndpointVirtualIPs where
  parseJSON = A.withObject "ServiceEndpointVirtualIPs" $ \o ->
    ServiceEndpointVirtualIPs
      <$> (o .:? "NetworkID")
      <*> (o .:? "Addr")

-- | ToJSON ServiceEndpointVirtualIPs
instance A.ToJSON ServiceEndpointVirtualIPs where
  toJSON ServiceEndpointVirtualIPs {..} =
   _omitNulls
      [ "NetworkID" .= serviceEndpointVirtualIPsNetworkId
      , "Addr" .= serviceEndpointVirtualIPsAddr
      ]


-- | Construct a value of type 'ServiceEndpointVirtualIPs' (by applying it's required fields, if any)
mkServiceEndpointVirtualIPs
  :: ServiceEndpointVirtualIPs
mkServiceEndpointVirtualIPs =
  ServiceEndpointVirtualIPs
  { serviceEndpointVirtualIPsNetworkId = Nothing
  , serviceEndpointVirtualIPsAddr = Nothing
  }

-- ** ServiceSpec
-- | ServiceSpec
-- User modifiable configuration for a service.
data ServiceSpec = ServiceSpec
  { serviceSpecName :: !(Maybe Text) -- ^ "Name" - Name of the service.
  , serviceSpecLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  , serviceSpecTaskTemplate :: !(Maybe TaskSpec) -- ^ "TaskTemplate"
  , serviceSpecMode :: !(Maybe ServiceSpecMode) -- ^ "Mode"
  , serviceSpecUpdateConfig :: !(Maybe ServiceSpecUpdateConfig) -- ^ "UpdateConfig"
  , serviceSpecNetworks :: !(Maybe [TaskSpecNetworks]) -- ^ "Networks" - Array of network names or IDs to attach the service to.
  , serviceSpecEndpointSpec :: !(Maybe EndpointSpec) -- ^ "EndpointSpec"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceSpec
instance A.FromJSON ServiceSpec where
  parseJSON = A.withObject "ServiceSpec" $ \o ->
    ServiceSpec
      <$> (o .:? "Name")
      <*> (o .:? "Labels")
      <*> (o .:? "TaskTemplate")
      <*> (o .:? "Mode")
      <*> (o .:? "UpdateConfig")
      <*> (o .:? "Networks")
      <*> (o .:? "EndpointSpec")

-- | ToJSON ServiceSpec
instance A.ToJSON ServiceSpec where
  toJSON ServiceSpec {..} =
   _omitNulls
      [ "Name" .= serviceSpecName
      , "Labels" .= serviceSpecLabels
      , "TaskTemplate" .= serviceSpecTaskTemplate
      , "Mode" .= serviceSpecMode
      , "UpdateConfig" .= serviceSpecUpdateConfig
      , "Networks" .= serviceSpecNetworks
      , "EndpointSpec" .= serviceSpecEndpointSpec
      ]


-- | Construct a value of type 'ServiceSpec' (by applying it's required fields, if any)
mkServiceSpec
  :: ServiceSpec
mkServiceSpec =
  ServiceSpec
  { serviceSpecName = Nothing
  , serviceSpecLabels = Nothing
  , serviceSpecTaskTemplate = Nothing
  , serviceSpecMode = Nothing
  , serviceSpecUpdateConfig = Nothing
  , serviceSpecNetworks = Nothing
  , serviceSpecEndpointSpec = Nothing
  }

-- ** ServiceSpecMode
-- | ServiceSpecMode
-- Scheduling mode for the service.
data ServiceSpecMode = ServiceSpecMode
  { serviceSpecModeReplicated :: !(Maybe ServiceSpecModeReplicated) -- ^ "Replicated"
  , serviceSpecModeGlobal :: !(Maybe A.Value) -- ^ "Global"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceSpecMode
instance A.FromJSON ServiceSpecMode where
  parseJSON = A.withObject "ServiceSpecMode" $ \o ->
    ServiceSpecMode
      <$> (o .:? "Replicated")
      <*> (o .:? "Global")

-- | ToJSON ServiceSpecMode
instance A.ToJSON ServiceSpecMode where
  toJSON ServiceSpecMode {..} =
   _omitNulls
      [ "Replicated" .= serviceSpecModeReplicated
      , "Global" .= serviceSpecModeGlobal
      ]


-- | Construct a value of type 'ServiceSpecMode' (by applying it's required fields, if any)
mkServiceSpecMode
  :: ServiceSpecMode
mkServiceSpecMode =
  ServiceSpecMode
  { serviceSpecModeReplicated = Nothing
  , serviceSpecModeGlobal = Nothing
  }

-- ** ServiceSpecModeReplicated
-- | ServiceSpecModeReplicated
data ServiceSpecModeReplicated = ServiceSpecModeReplicated
  { serviceSpecModeReplicatedReplicas :: !(Maybe Integer) -- ^ "Replicas"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceSpecModeReplicated
instance A.FromJSON ServiceSpecModeReplicated where
  parseJSON = A.withObject "ServiceSpecModeReplicated" $ \o ->
    ServiceSpecModeReplicated
      <$> (o .:? "Replicas")

-- | ToJSON ServiceSpecModeReplicated
instance A.ToJSON ServiceSpecModeReplicated where
  toJSON ServiceSpecModeReplicated {..} =
   _omitNulls
      [ "Replicas" .= serviceSpecModeReplicatedReplicas
      ]


-- | Construct a value of type 'ServiceSpecModeReplicated' (by applying it's required fields, if any)
mkServiceSpecModeReplicated
  :: ServiceSpecModeReplicated
mkServiceSpecModeReplicated =
  ServiceSpecModeReplicated
  { serviceSpecModeReplicatedReplicas = Nothing
  }

-- ** ServiceSpecUpdateConfig
-- | ServiceSpecUpdateConfig
-- Specification for the update strategy of the service.
data ServiceSpecUpdateConfig = ServiceSpecUpdateConfig
  { serviceSpecUpdateConfigParallelism :: !(Maybe Integer) -- ^ "Parallelism" - Maximum number of tasks to be updated in one iteration (0 means unlimited parallelism).
  , serviceSpecUpdateConfigDelay :: !(Maybe Integer) -- ^ "Delay" - Amount of time between updates, in nanoseconds.
  , serviceSpecUpdateConfigFailureAction :: !(Maybe E'FailureAction) -- ^ "FailureAction" - Action to take if an updated task fails to run, or stops running during the update.
  , serviceSpecUpdateConfigMonitor :: !(Maybe Integer) -- ^ "Monitor" - Amount of time to monitor each updated task for failures, in nanoseconds.
  , serviceSpecUpdateConfigMaxFailureRatio :: !(Maybe Double) -- ^ "MaxFailureRatio" - The fraction of tasks that may fail during an update before the failure action is invoked, specified as a floating point number between 0 and 1.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceSpecUpdateConfig
instance A.FromJSON ServiceSpecUpdateConfig where
  parseJSON = A.withObject "ServiceSpecUpdateConfig" $ \o ->
    ServiceSpecUpdateConfig
      <$> (o .:? "Parallelism")
      <*> (o .:? "Delay")
      <*> (o .:? "FailureAction")
      <*> (o .:? "Monitor")
      <*> (o .:? "MaxFailureRatio")

-- | ToJSON ServiceSpecUpdateConfig
instance A.ToJSON ServiceSpecUpdateConfig where
  toJSON ServiceSpecUpdateConfig {..} =
   _omitNulls
      [ "Parallelism" .= serviceSpecUpdateConfigParallelism
      , "Delay" .= serviceSpecUpdateConfigDelay
      , "FailureAction" .= serviceSpecUpdateConfigFailureAction
      , "Monitor" .= serviceSpecUpdateConfigMonitor
      , "MaxFailureRatio" .= serviceSpecUpdateConfigMaxFailureRatio
      ]


-- | Construct a value of type 'ServiceSpecUpdateConfig' (by applying it's required fields, if any)
mkServiceSpecUpdateConfig
  :: ServiceSpecUpdateConfig
mkServiceSpecUpdateConfig =
  ServiceSpecUpdateConfig
  { serviceSpecUpdateConfigParallelism = Nothing
  , serviceSpecUpdateConfigDelay = Nothing
  , serviceSpecUpdateConfigFailureAction = Nothing
  , serviceSpecUpdateConfigMonitor = Nothing
  , serviceSpecUpdateConfigMaxFailureRatio = Nothing
  }

-- ** ServiceUpdateResponse
-- | ServiceUpdateResponse
data ServiceUpdateResponse = ServiceUpdateResponse
  { serviceUpdateResponseWarnings :: !(Maybe [Text]) -- ^ "Warnings" - Optional warning messages
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceUpdateResponse
instance A.FromJSON ServiceUpdateResponse where
  parseJSON = A.withObject "ServiceUpdateResponse" $ \o ->
    ServiceUpdateResponse
      <$> (o .:? "Warnings")

-- | ToJSON ServiceUpdateResponse
instance A.ToJSON ServiceUpdateResponse where
  toJSON ServiceUpdateResponse {..} =
   _omitNulls
      [ "Warnings" .= serviceUpdateResponseWarnings
      ]


-- | Construct a value of type 'ServiceUpdateResponse' (by applying it's required fields, if any)
mkServiceUpdateResponse
  :: ServiceUpdateResponse
mkServiceUpdateResponse =
  ServiceUpdateResponse
  { serviceUpdateResponseWarnings = Nothing
  }

-- ** ServiceUpdateStatus
-- | ServiceUpdateStatus
-- The status of a service update.
data ServiceUpdateStatus = ServiceUpdateStatus
  { serviceUpdateStatusState :: !(Maybe E'State) -- ^ "State"
  , serviceUpdateStatusStartedAt :: !(Maybe Text) -- ^ "StartedAt"
  , serviceUpdateStatusCompletedAt :: !(Maybe Text) -- ^ "CompletedAt"
  , serviceUpdateStatusMessage :: !(Maybe Text) -- ^ "Message"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceUpdateStatus
instance A.FromJSON ServiceUpdateStatus where
  parseJSON = A.withObject "ServiceUpdateStatus" $ \o ->
    ServiceUpdateStatus
      <$> (o .:? "State")
      <*> (o .:? "StartedAt")
      <*> (o .:? "CompletedAt")
      <*> (o .:? "Message")

-- | ToJSON ServiceUpdateStatus
instance A.ToJSON ServiceUpdateStatus where
  toJSON ServiceUpdateStatus {..} =
   _omitNulls
      [ "State" .= serviceUpdateStatusState
      , "StartedAt" .= serviceUpdateStatusStartedAt
      , "CompletedAt" .= serviceUpdateStatusCompletedAt
      , "Message" .= serviceUpdateStatusMessage
      ]


-- | Construct a value of type 'ServiceUpdateStatus' (by applying it's required fields, if any)
mkServiceUpdateStatus
  :: ServiceUpdateStatus
mkServiceUpdateStatus =
  ServiceUpdateStatus
  { serviceUpdateStatusState = Nothing
  , serviceUpdateStatusStartedAt = Nothing
  , serviceUpdateStatusCompletedAt = Nothing
  , serviceUpdateStatusMessage = Nothing
  }

-- ** SwarmSpec
-- | SwarmSpec
-- User modifiable swarm configuration.
data SwarmSpec = SwarmSpec
  { swarmSpecName :: !(Maybe Text) -- ^ "Name" - Name of the swarm.
  , swarmSpecLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  , swarmSpecOrchestration :: !(Maybe SwarmSpecOrchestration) -- ^ "Orchestration"
  , swarmSpecRaft :: !(Maybe SwarmSpecRaft) -- ^ "Raft"
  , swarmSpecDispatcher :: !(Maybe SwarmSpecDispatcher) -- ^ "Dispatcher"
  , swarmSpecCaConfig :: !(Maybe SwarmSpecCAConfig) -- ^ "CAConfig"
  , swarmSpecEncryptionConfig :: !(Maybe SwarmSpecEncryptionConfig) -- ^ "EncryptionConfig"
  , swarmSpecTaskDefaults :: !(Maybe SwarmSpecTaskDefaults) -- ^ "TaskDefaults"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmSpec
instance A.FromJSON SwarmSpec where
  parseJSON = A.withObject "SwarmSpec" $ \o ->
    SwarmSpec
      <$> (o .:? "Name")
      <*> (o .:? "Labels")
      <*> (o .:? "Orchestration")
      <*> (o .:? "Raft")
      <*> (o .:? "Dispatcher")
      <*> (o .:? "CAConfig")
      <*> (o .:? "EncryptionConfig")
      <*> (o .:? "TaskDefaults")

-- | ToJSON SwarmSpec
instance A.ToJSON SwarmSpec where
  toJSON SwarmSpec {..} =
   _omitNulls
      [ "Name" .= swarmSpecName
      , "Labels" .= swarmSpecLabels
      , "Orchestration" .= swarmSpecOrchestration
      , "Raft" .= swarmSpecRaft
      , "Dispatcher" .= swarmSpecDispatcher
      , "CAConfig" .= swarmSpecCaConfig
      , "EncryptionConfig" .= swarmSpecEncryptionConfig
      , "TaskDefaults" .= swarmSpecTaskDefaults
      ]


-- | Construct a value of type 'SwarmSpec' (by applying it's required fields, if any)
mkSwarmSpec
  :: SwarmSpec
mkSwarmSpec =
  SwarmSpec
  { swarmSpecName = Nothing
  , swarmSpecLabels = Nothing
  , swarmSpecOrchestration = Nothing
  , swarmSpecRaft = Nothing
  , swarmSpecDispatcher = Nothing
  , swarmSpecCaConfig = Nothing
  , swarmSpecEncryptionConfig = Nothing
  , swarmSpecTaskDefaults = Nothing
  }

-- ** SwarmSpecCAConfig
-- | SwarmSpecCAConfig
-- CA configuration.
data SwarmSpecCAConfig = SwarmSpecCAConfig
  { swarmSpecCAConfigNodeCertExpiry :: !(Maybe Integer) -- ^ "NodeCertExpiry" - The duration node certificates are issued for.
  , swarmSpecCAConfigExternalCAs :: !(Maybe [SwarmSpecCAConfigExternalCAs]) -- ^ "ExternalCAs" - Configuration for forwarding signing requests to an external certificate authority.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmSpecCAConfig
instance A.FromJSON SwarmSpecCAConfig where
  parseJSON = A.withObject "SwarmSpecCAConfig" $ \o ->
    SwarmSpecCAConfig
      <$> (o .:? "NodeCertExpiry")
      <*> (o .:? "ExternalCAs")

-- | ToJSON SwarmSpecCAConfig
instance A.ToJSON SwarmSpecCAConfig where
  toJSON SwarmSpecCAConfig {..} =
   _omitNulls
      [ "NodeCertExpiry" .= swarmSpecCAConfigNodeCertExpiry
      , "ExternalCAs" .= swarmSpecCAConfigExternalCAs
      ]


-- | Construct a value of type 'SwarmSpecCAConfig' (by applying it's required fields, if any)
mkSwarmSpecCAConfig
  :: SwarmSpecCAConfig
mkSwarmSpecCAConfig =
  SwarmSpecCAConfig
  { swarmSpecCAConfigNodeCertExpiry = Nothing
  , swarmSpecCAConfigExternalCAs = Nothing
  }

-- ** SwarmSpecCAConfigExternalCAs
-- | SwarmSpecCAConfigExternalCAs
data SwarmSpecCAConfigExternalCAs = SwarmSpecCAConfigExternalCAs
  { swarmSpecCAConfigExternalCAsProtocol :: !(Maybe E'Protocol) -- ^ "Protocol" - Protocol for communication with the external CA (currently only &#x60;cfssl&#x60; is supported).
  , swarmSpecCAConfigExternalCAsUrl :: !(Maybe Text) -- ^ "URL" - URL where certificate signing requests should be sent.
  , swarmSpecCAConfigExternalCAsOptions :: !(Maybe (Map.Map String Text)) -- ^ "Options" - An object with key/value pairs that are interpreted as protocol-specific options for the external CA driver.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmSpecCAConfigExternalCAs
instance A.FromJSON SwarmSpecCAConfigExternalCAs where
  parseJSON = A.withObject "SwarmSpecCAConfigExternalCAs" $ \o ->
    SwarmSpecCAConfigExternalCAs
      <$> (o .:? "Protocol")
      <*> (o .:? "URL")
      <*> (o .:? "Options")

-- | ToJSON SwarmSpecCAConfigExternalCAs
instance A.ToJSON SwarmSpecCAConfigExternalCAs where
  toJSON SwarmSpecCAConfigExternalCAs {..} =
   _omitNulls
      [ "Protocol" .= swarmSpecCAConfigExternalCAsProtocol
      , "URL" .= swarmSpecCAConfigExternalCAsUrl
      , "Options" .= swarmSpecCAConfigExternalCAsOptions
      ]


-- | Construct a value of type 'SwarmSpecCAConfigExternalCAs' (by applying it's required fields, if any)
mkSwarmSpecCAConfigExternalCAs
  :: SwarmSpecCAConfigExternalCAs
mkSwarmSpecCAConfigExternalCAs =
  SwarmSpecCAConfigExternalCAs
  { swarmSpecCAConfigExternalCAsProtocol = Nothing
  , swarmSpecCAConfigExternalCAsUrl = Nothing
  , swarmSpecCAConfigExternalCAsOptions = Nothing
  }

-- ** SwarmSpecDispatcher
-- | SwarmSpecDispatcher
-- Dispatcher configuration.
data SwarmSpecDispatcher = SwarmSpecDispatcher
  { swarmSpecDispatcherHeartbeatPeriod :: !(Maybe Integer) -- ^ "HeartbeatPeriod" - The delay for an agent to send a heartbeat to the dispatcher.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmSpecDispatcher
instance A.FromJSON SwarmSpecDispatcher where
  parseJSON = A.withObject "SwarmSpecDispatcher" $ \o ->
    SwarmSpecDispatcher
      <$> (o .:? "HeartbeatPeriod")

-- | ToJSON SwarmSpecDispatcher
instance A.ToJSON SwarmSpecDispatcher where
  toJSON SwarmSpecDispatcher {..} =
   _omitNulls
      [ "HeartbeatPeriod" .= swarmSpecDispatcherHeartbeatPeriod
      ]


-- | Construct a value of type 'SwarmSpecDispatcher' (by applying it's required fields, if any)
mkSwarmSpecDispatcher
  :: SwarmSpecDispatcher
mkSwarmSpecDispatcher =
  SwarmSpecDispatcher
  { swarmSpecDispatcherHeartbeatPeriod = Nothing
  }

-- ** SwarmSpecEncryptionConfig
-- | SwarmSpecEncryptionConfig
-- Parameters related to encryption-at-rest.
data SwarmSpecEncryptionConfig = SwarmSpecEncryptionConfig
  { swarmSpecEncryptionConfigAutoLockManagers :: !(Maybe Bool) -- ^ "AutoLockManagers" - If set, generate a key and use it to lock data stored on the managers.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmSpecEncryptionConfig
instance A.FromJSON SwarmSpecEncryptionConfig where
  parseJSON = A.withObject "SwarmSpecEncryptionConfig" $ \o ->
    SwarmSpecEncryptionConfig
      <$> (o .:? "AutoLockManagers")

-- | ToJSON SwarmSpecEncryptionConfig
instance A.ToJSON SwarmSpecEncryptionConfig where
  toJSON SwarmSpecEncryptionConfig {..} =
   _omitNulls
      [ "AutoLockManagers" .= swarmSpecEncryptionConfigAutoLockManagers
      ]


-- | Construct a value of type 'SwarmSpecEncryptionConfig' (by applying it's required fields, if any)
mkSwarmSpecEncryptionConfig
  :: SwarmSpecEncryptionConfig
mkSwarmSpecEncryptionConfig =
  SwarmSpecEncryptionConfig
  { swarmSpecEncryptionConfigAutoLockManagers = Nothing
  }

-- ** SwarmSpecOrchestration
-- | SwarmSpecOrchestration
-- Orchestration configuration.
data SwarmSpecOrchestration = SwarmSpecOrchestration
  { swarmSpecOrchestrationTaskHistoryRetentionLimit :: !(Maybe Integer) -- ^ "TaskHistoryRetentionLimit" - The number of historic tasks to keep per instance or node. If negative, never remove completed or failed tasks.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmSpecOrchestration
instance A.FromJSON SwarmSpecOrchestration where
  parseJSON = A.withObject "SwarmSpecOrchestration" $ \o ->
    SwarmSpecOrchestration
      <$> (o .:? "TaskHistoryRetentionLimit")

-- | ToJSON SwarmSpecOrchestration
instance A.ToJSON SwarmSpecOrchestration where
  toJSON SwarmSpecOrchestration {..} =
   _omitNulls
      [ "TaskHistoryRetentionLimit" .= swarmSpecOrchestrationTaskHistoryRetentionLimit
      ]


-- | Construct a value of type 'SwarmSpecOrchestration' (by applying it's required fields, if any)
mkSwarmSpecOrchestration
  :: SwarmSpecOrchestration
mkSwarmSpecOrchestration =
  SwarmSpecOrchestration
  { swarmSpecOrchestrationTaskHistoryRetentionLimit = Nothing
  }

-- ** SwarmSpecRaft
-- | SwarmSpecRaft
-- Raft configuration.
data SwarmSpecRaft = SwarmSpecRaft
  { swarmSpecRaftSnapshotInterval :: !(Maybe Integer) -- ^ "SnapshotInterval" - The number of log entries between snapshots.
  , swarmSpecRaftKeepOldSnapshots :: !(Maybe Integer) -- ^ "KeepOldSnapshots" - The number of snapshots to keep beyond the current snapshot.
  , swarmSpecRaftLogEntriesForSlowFollowers :: !(Maybe Integer) -- ^ "LogEntriesForSlowFollowers" - The number of log entries to keep around to sync up slow followers after a snapshot is created.
  , swarmSpecRaftElectionTick :: !(Maybe Int) -- ^ "ElectionTick" - The number of ticks that a follower will wait for a message from the leader before becoming a candidate and starting an election. &#x60;ElectionTick&#x60; must be greater than &#x60;HeartbeatTick&#x60;.  A tick currently defaults to one second, so these translate directly to seconds currently, but this is NOT guaranteed. 
  , swarmSpecRaftHeartbeatTick :: !(Maybe Int) -- ^ "HeartbeatTick" - The number of ticks between heartbeats. Every HeartbeatTick ticks, the leader will send a heartbeat to the followers.  A tick currently defaults to one second, so these translate directly to seconds currently, but this is NOT guaranteed. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmSpecRaft
instance A.FromJSON SwarmSpecRaft where
  parseJSON = A.withObject "SwarmSpecRaft" $ \o ->
    SwarmSpecRaft
      <$> (o .:? "SnapshotInterval")
      <*> (o .:? "KeepOldSnapshots")
      <*> (o .:? "LogEntriesForSlowFollowers")
      <*> (o .:? "ElectionTick")
      <*> (o .:? "HeartbeatTick")

-- | ToJSON SwarmSpecRaft
instance A.ToJSON SwarmSpecRaft where
  toJSON SwarmSpecRaft {..} =
   _omitNulls
      [ "SnapshotInterval" .= swarmSpecRaftSnapshotInterval
      , "KeepOldSnapshots" .= swarmSpecRaftKeepOldSnapshots
      , "LogEntriesForSlowFollowers" .= swarmSpecRaftLogEntriesForSlowFollowers
      , "ElectionTick" .= swarmSpecRaftElectionTick
      , "HeartbeatTick" .= swarmSpecRaftHeartbeatTick
      ]


-- | Construct a value of type 'SwarmSpecRaft' (by applying it's required fields, if any)
mkSwarmSpecRaft
  :: SwarmSpecRaft
mkSwarmSpecRaft =
  SwarmSpecRaft
  { swarmSpecRaftSnapshotInterval = Nothing
  , swarmSpecRaftKeepOldSnapshots = Nothing
  , swarmSpecRaftLogEntriesForSlowFollowers = Nothing
  , swarmSpecRaftElectionTick = Nothing
  , swarmSpecRaftHeartbeatTick = Nothing
  }

-- ** SwarmSpecTaskDefaults
-- | SwarmSpecTaskDefaults
-- Defaults for creating tasks in this cluster.
data SwarmSpecTaskDefaults = SwarmSpecTaskDefaults
  { swarmSpecTaskDefaultsLogDriver :: !(Maybe SwarmSpecTaskDefaultsLogDriver) -- ^ "LogDriver"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmSpecTaskDefaults
instance A.FromJSON SwarmSpecTaskDefaults where
  parseJSON = A.withObject "SwarmSpecTaskDefaults" $ \o ->
    SwarmSpecTaskDefaults
      <$> (o .:? "LogDriver")

-- | ToJSON SwarmSpecTaskDefaults
instance A.ToJSON SwarmSpecTaskDefaults where
  toJSON SwarmSpecTaskDefaults {..} =
   _omitNulls
      [ "LogDriver" .= swarmSpecTaskDefaultsLogDriver
      ]


-- | Construct a value of type 'SwarmSpecTaskDefaults' (by applying it's required fields, if any)
mkSwarmSpecTaskDefaults
  :: SwarmSpecTaskDefaults
mkSwarmSpecTaskDefaults =
  SwarmSpecTaskDefaults
  { swarmSpecTaskDefaultsLogDriver = Nothing
  }

-- ** SwarmSpecTaskDefaultsLogDriver
-- | SwarmSpecTaskDefaultsLogDriver
-- The log driver to use for tasks created in the orchestrator if unspecified by a service.  Updating this value will only have an affect on new tasks. Old tasks will continue use their previously configured log driver until recreated. 
data SwarmSpecTaskDefaultsLogDriver = SwarmSpecTaskDefaultsLogDriver
  { swarmSpecTaskDefaultsLogDriverName :: !(Maybe Text) -- ^ "Name"
  , swarmSpecTaskDefaultsLogDriverOptions :: !(Maybe (Map.Map String Text)) -- ^ "Options"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmSpecTaskDefaultsLogDriver
instance A.FromJSON SwarmSpecTaskDefaultsLogDriver where
  parseJSON = A.withObject "SwarmSpecTaskDefaultsLogDriver" $ \o ->
    SwarmSpecTaskDefaultsLogDriver
      <$> (o .:? "Name")
      <*> (o .:? "Options")

-- | ToJSON SwarmSpecTaskDefaultsLogDriver
instance A.ToJSON SwarmSpecTaskDefaultsLogDriver where
  toJSON SwarmSpecTaskDefaultsLogDriver {..} =
   _omitNulls
      [ "Name" .= swarmSpecTaskDefaultsLogDriverName
      , "Options" .= swarmSpecTaskDefaultsLogDriverOptions
      ]


-- | Construct a value of type 'SwarmSpecTaskDefaultsLogDriver' (by applying it's required fields, if any)
mkSwarmSpecTaskDefaultsLogDriver
  :: SwarmSpecTaskDefaultsLogDriver
mkSwarmSpecTaskDefaultsLogDriver =
  SwarmSpecTaskDefaultsLogDriver
  { swarmSpecTaskDefaultsLogDriverName = Nothing
  , swarmSpecTaskDefaultsLogDriverOptions = Nothing
  }

-- ** Task
-- | Task
data Task = Task
  { taskId :: !(Maybe Text) -- ^ "ID" - The ID of the task.
  , taskVersion :: !(Maybe NodeVersion) -- ^ "Version"
  , taskCreatedAt :: !(Maybe Text) -- ^ "CreatedAt"
  , taskUpdatedAt :: !(Maybe Text) -- ^ "UpdatedAt"
  , taskName :: !(Maybe Text) -- ^ "Name" - Name of the task.
  , taskLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  , taskSpec :: !(Maybe TaskSpec) -- ^ "Spec"
  , taskServiceId :: !(Maybe Text) -- ^ "ServiceID" - The ID of the service this task is part of.
  , taskSlot :: !(Maybe Int) -- ^ "Slot"
  , taskNodeId :: !(Maybe Text) -- ^ "NodeID" - The ID of the node that this task is on.
  , taskStatus :: !(Maybe TaskStatus) -- ^ "Status"
  , taskDesiredState :: !(Maybe TaskState) -- ^ "DesiredState"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Task
instance A.FromJSON Task where
  parseJSON = A.withObject "Task" $ \o ->
    Task
      <$> (o .:? "ID")
      <*> (o .:? "Version")
      <*> (o .:? "CreatedAt")
      <*> (o .:? "UpdatedAt")
      <*> (o .:? "Name")
      <*> (o .:? "Labels")
      <*> (o .:? "Spec")
      <*> (o .:? "ServiceID")
      <*> (o .:? "Slot")
      <*> (o .:? "NodeID")
      <*> (o .:? "Status")
      <*> (o .:? "DesiredState")

-- | ToJSON Task
instance A.ToJSON Task where
  toJSON Task {..} =
   _omitNulls
      [ "ID" .= taskId
      , "Version" .= taskVersion
      , "CreatedAt" .= taskCreatedAt
      , "UpdatedAt" .= taskUpdatedAt
      , "Name" .= taskName
      , "Labels" .= taskLabels
      , "Spec" .= taskSpec
      , "ServiceID" .= taskServiceId
      , "Slot" .= taskSlot
      , "NodeID" .= taskNodeId
      , "Status" .= taskStatus
      , "DesiredState" .= taskDesiredState
      ]


-- | Construct a value of type 'Task' (by applying it's required fields, if any)
mkTask
  :: Task
mkTask =
  Task
  { taskId = Nothing
  , taskVersion = Nothing
  , taskCreatedAt = Nothing
  , taskUpdatedAt = Nothing
  , taskName = Nothing
  , taskLabels = Nothing
  , taskSpec = Nothing
  , taskServiceId = Nothing
  , taskSlot = Nothing
  , taskNodeId = Nothing
  , taskStatus = Nothing
  , taskDesiredState = Nothing
  }

-- ** TaskSpec
-- | TaskSpec
-- User modifiable task configuration.
data TaskSpec = TaskSpec
  { taskSpecContainerSpec :: !(Maybe TaskSpecContainerSpec) -- ^ "ContainerSpec"
  , taskSpecResources :: !(Maybe TaskSpecResources) -- ^ "Resources"
  , taskSpecRestartPolicy :: !(Maybe TaskSpecRestartPolicy) -- ^ "RestartPolicy"
  , taskSpecPlacement :: !(Maybe TaskSpecPlacement) -- ^ "Placement"
  , taskSpecForceUpdate :: !(Maybe Int) -- ^ "ForceUpdate" - A counter that triggers an update even if no relevant parameters have been changed.
  , taskSpecNetworks :: !(Maybe [TaskSpecNetworks]) -- ^ "Networks"
  , taskSpecLogDriver :: !(Maybe TaskSpecLogDriver) -- ^ "LogDriver"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpec
instance A.FromJSON TaskSpec where
  parseJSON = A.withObject "TaskSpec" $ \o ->
    TaskSpec
      <$> (o .:? "ContainerSpec")
      <*> (o .:? "Resources")
      <*> (o .:? "RestartPolicy")
      <*> (o .:? "Placement")
      <*> (o .:? "ForceUpdate")
      <*> (o .:? "Networks")
      <*> (o .:? "LogDriver")

-- | ToJSON TaskSpec
instance A.ToJSON TaskSpec where
  toJSON TaskSpec {..} =
   _omitNulls
      [ "ContainerSpec" .= taskSpecContainerSpec
      , "Resources" .= taskSpecResources
      , "RestartPolicy" .= taskSpecRestartPolicy
      , "Placement" .= taskSpecPlacement
      , "ForceUpdate" .= taskSpecForceUpdate
      , "Networks" .= taskSpecNetworks
      , "LogDriver" .= taskSpecLogDriver
      ]


-- | Construct a value of type 'TaskSpec' (by applying it's required fields, if any)
mkTaskSpec
  :: TaskSpec
mkTaskSpec =
  TaskSpec
  { taskSpecContainerSpec = Nothing
  , taskSpecResources = Nothing
  , taskSpecRestartPolicy = Nothing
  , taskSpecPlacement = Nothing
  , taskSpecForceUpdate = Nothing
  , taskSpecNetworks = Nothing
  , taskSpecLogDriver = Nothing
  }

-- ** TaskSpecContainerSpec
-- | TaskSpecContainerSpec
data TaskSpecContainerSpec = TaskSpecContainerSpec
  { taskSpecContainerSpecImage :: !(Maybe Text) -- ^ "Image" - The image name to use for the container.
  , taskSpecContainerSpecCommand :: !(Maybe [Text]) -- ^ "Command" - The command to be run in the image.
  , taskSpecContainerSpecArgs :: !(Maybe [Text]) -- ^ "Args" - Arguments to the command.
  , taskSpecContainerSpecEnv :: !(Maybe [Text]) -- ^ "Env" - A list of environment variables in the form &#x60;VAR&#x3D;value&#x60;.
  , taskSpecContainerSpecDir :: !(Maybe Text) -- ^ "Dir" - The working directory for commands to run in.
  , taskSpecContainerSpecUser :: !(Maybe Text) -- ^ "User" - The user inside the container.
  , taskSpecContainerSpecLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value data.
  , taskSpecContainerSpecTty :: !(Maybe Bool) -- ^ "TTY" - Whether a pseudo-TTY should be allocated.
  , taskSpecContainerSpecMounts :: !(Maybe [Mount]) -- ^ "Mounts" - Specification for mounts to be added to containers created as part of the service.
  , taskSpecContainerSpecStopGracePeriod :: !(Maybe Integer) -- ^ "StopGracePeriod" - Amount of time to wait for the container to terminate before forcefully killing it.
  , taskSpecContainerSpecDnsConfig :: !(Maybe TaskSpecContainerSpecDNSConfig) -- ^ "DNSConfig"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecContainerSpec
instance A.FromJSON TaskSpecContainerSpec where
  parseJSON = A.withObject "TaskSpecContainerSpec" $ \o ->
    TaskSpecContainerSpec
      <$> (o .:? "Image")
      <*> (o .:? "Command")
      <*> (o .:? "Args")
      <*> (o .:? "Env")
      <*> (o .:? "Dir")
      <*> (o .:? "User")
      <*> (o .:? "Labels")
      <*> (o .:? "TTY")
      <*> (o .:? "Mounts")
      <*> (o .:? "StopGracePeriod")
      <*> (o .:? "DNSConfig")

-- | ToJSON TaskSpecContainerSpec
instance A.ToJSON TaskSpecContainerSpec where
  toJSON TaskSpecContainerSpec {..} =
   _omitNulls
      [ "Image" .= taskSpecContainerSpecImage
      , "Command" .= taskSpecContainerSpecCommand
      , "Args" .= taskSpecContainerSpecArgs
      , "Env" .= taskSpecContainerSpecEnv
      , "Dir" .= taskSpecContainerSpecDir
      , "User" .= taskSpecContainerSpecUser
      , "Labels" .= taskSpecContainerSpecLabels
      , "TTY" .= taskSpecContainerSpecTty
      , "Mounts" .= taskSpecContainerSpecMounts
      , "StopGracePeriod" .= taskSpecContainerSpecStopGracePeriod
      , "DNSConfig" .= taskSpecContainerSpecDnsConfig
      ]


-- | Construct a value of type 'TaskSpecContainerSpec' (by applying it's required fields, if any)
mkTaskSpecContainerSpec
  :: TaskSpecContainerSpec
mkTaskSpecContainerSpec =
  TaskSpecContainerSpec
  { taskSpecContainerSpecImage = Nothing
  , taskSpecContainerSpecCommand = Nothing
  , taskSpecContainerSpecArgs = Nothing
  , taskSpecContainerSpecEnv = Nothing
  , taskSpecContainerSpecDir = Nothing
  , taskSpecContainerSpecUser = Nothing
  , taskSpecContainerSpecLabels = Nothing
  , taskSpecContainerSpecTty = Nothing
  , taskSpecContainerSpecMounts = Nothing
  , taskSpecContainerSpecStopGracePeriod = Nothing
  , taskSpecContainerSpecDnsConfig = Nothing
  }

-- ** TaskSpecContainerSpecDNSConfig
-- | TaskSpecContainerSpecDNSConfig
-- Specification for DNS related configurations in resolver configuration file (`resolv.conf`).
data TaskSpecContainerSpecDNSConfig = TaskSpecContainerSpecDNSConfig
  { taskSpecContainerSpecDNSConfigNameservers :: !(Maybe [Text]) -- ^ "Nameservers" - The IP addresses of the name servers.
  , taskSpecContainerSpecDNSConfigSearch :: !(Maybe [Text]) -- ^ "Search" - A search list for host-name lookup.
  , taskSpecContainerSpecDNSConfigOptions :: !(Maybe [Text]) -- ^ "Options" - A list of internal resolver variables to be modified (e.g., &#x60;debug&#x60;, &#x60;ndots:3&#x60;, etc.).
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecContainerSpecDNSConfig
instance A.FromJSON TaskSpecContainerSpecDNSConfig where
  parseJSON = A.withObject "TaskSpecContainerSpecDNSConfig" $ \o ->
    TaskSpecContainerSpecDNSConfig
      <$> (o .:? "Nameservers")
      <*> (o .:? "Search")
      <*> (o .:? "Options")

-- | ToJSON TaskSpecContainerSpecDNSConfig
instance A.ToJSON TaskSpecContainerSpecDNSConfig where
  toJSON TaskSpecContainerSpecDNSConfig {..} =
   _omitNulls
      [ "Nameservers" .= taskSpecContainerSpecDNSConfigNameservers
      , "Search" .= taskSpecContainerSpecDNSConfigSearch
      , "Options" .= taskSpecContainerSpecDNSConfigOptions
      ]


-- | Construct a value of type 'TaskSpecContainerSpecDNSConfig' (by applying it's required fields, if any)
mkTaskSpecContainerSpecDNSConfig
  :: TaskSpecContainerSpecDNSConfig
mkTaskSpecContainerSpecDNSConfig =
  TaskSpecContainerSpecDNSConfig
  { taskSpecContainerSpecDNSConfigNameservers = Nothing
  , taskSpecContainerSpecDNSConfigSearch = Nothing
  , taskSpecContainerSpecDNSConfigOptions = Nothing
  }

-- ** TaskSpecLogDriver
-- | TaskSpecLogDriver
-- Specifies the log driver to use for tasks created from this spec. If not present, the default one for the swarm will be used, finally falling back to the engine default if not specified.
data TaskSpecLogDriver = TaskSpecLogDriver
  { taskSpecLogDriverName :: !(Maybe Text) -- ^ "Name"
  , taskSpecLogDriverOptions :: !(Maybe (Map.Map String Text)) -- ^ "Options"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecLogDriver
instance A.FromJSON TaskSpecLogDriver where
  parseJSON = A.withObject "TaskSpecLogDriver" $ \o ->
    TaskSpecLogDriver
      <$> (o .:? "Name")
      <*> (o .:? "Options")

-- | ToJSON TaskSpecLogDriver
instance A.ToJSON TaskSpecLogDriver where
  toJSON TaskSpecLogDriver {..} =
   _omitNulls
      [ "Name" .= taskSpecLogDriverName
      , "Options" .= taskSpecLogDriverOptions
      ]


-- | Construct a value of type 'TaskSpecLogDriver' (by applying it's required fields, if any)
mkTaskSpecLogDriver
  :: TaskSpecLogDriver
mkTaskSpecLogDriver =
  TaskSpecLogDriver
  { taskSpecLogDriverName = Nothing
  , taskSpecLogDriverOptions = Nothing
  }

-- ** TaskSpecNetworks
-- | TaskSpecNetworks
data TaskSpecNetworks = TaskSpecNetworks
  { taskSpecNetworksTarget :: !(Maybe Text) -- ^ "Target"
  , taskSpecNetworksAliases :: !(Maybe [Text]) -- ^ "Aliases"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecNetworks
instance A.FromJSON TaskSpecNetworks where
  parseJSON = A.withObject "TaskSpecNetworks" $ \o ->
    TaskSpecNetworks
      <$> (o .:? "Target")
      <*> (o .:? "Aliases")

-- | ToJSON TaskSpecNetworks
instance A.ToJSON TaskSpecNetworks where
  toJSON TaskSpecNetworks {..} =
   _omitNulls
      [ "Target" .= taskSpecNetworksTarget
      , "Aliases" .= taskSpecNetworksAliases
      ]


-- | Construct a value of type 'TaskSpecNetworks' (by applying it's required fields, if any)
mkTaskSpecNetworks
  :: TaskSpecNetworks
mkTaskSpecNetworks =
  TaskSpecNetworks
  { taskSpecNetworksTarget = Nothing
  , taskSpecNetworksAliases = Nothing
  }

-- ** TaskSpecPlacement
-- | TaskSpecPlacement
data TaskSpecPlacement = TaskSpecPlacement
  { taskSpecPlacementConstraints :: !(Maybe [Text]) -- ^ "Constraints" - An array of constraints.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecPlacement
instance A.FromJSON TaskSpecPlacement where
  parseJSON = A.withObject "TaskSpecPlacement" $ \o ->
    TaskSpecPlacement
      <$> (o .:? "Constraints")

-- | ToJSON TaskSpecPlacement
instance A.ToJSON TaskSpecPlacement where
  toJSON TaskSpecPlacement {..} =
   _omitNulls
      [ "Constraints" .= taskSpecPlacementConstraints
      ]


-- | Construct a value of type 'TaskSpecPlacement' (by applying it's required fields, if any)
mkTaskSpecPlacement
  :: TaskSpecPlacement
mkTaskSpecPlacement =
  TaskSpecPlacement
  { taskSpecPlacementConstraints = Nothing
  }

-- ** TaskSpecResources
-- | TaskSpecResources
-- Resource requirements which apply to each individual container created as part of the service.
data TaskSpecResources = TaskSpecResources
  { taskSpecResourcesLimits :: !(Maybe TaskSpecResourcesLimits) -- ^ "Limits"
  , taskSpecResourcesReservation :: !(Maybe TaskSpecResourcesReservation) -- ^ "Reservation"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecResources
instance A.FromJSON TaskSpecResources where
  parseJSON = A.withObject "TaskSpecResources" $ \o ->
    TaskSpecResources
      <$> (o .:? "Limits")
      <*> (o .:? "Reservation")

-- | ToJSON TaskSpecResources
instance A.ToJSON TaskSpecResources where
  toJSON TaskSpecResources {..} =
   _omitNulls
      [ "Limits" .= taskSpecResourcesLimits
      , "Reservation" .= taskSpecResourcesReservation
      ]


-- | Construct a value of type 'TaskSpecResources' (by applying it's required fields, if any)
mkTaskSpecResources
  :: TaskSpecResources
mkTaskSpecResources =
  TaskSpecResources
  { taskSpecResourcesLimits = Nothing
  , taskSpecResourcesReservation = Nothing
  }

-- ** TaskSpecResourcesLimits
-- | TaskSpecResourcesLimits
-- Define resources limits.
data TaskSpecResourcesLimits = TaskSpecResourcesLimits
  { taskSpecResourcesLimitsNanoCpUs :: !(Maybe Integer) -- ^ "NanoCPUs" - CPU limit in units of 10&lt;sup&gt;-9&lt;/sup&gt; CPU shares.
  , taskSpecResourcesLimitsMemoryBytes :: !(Maybe Integer) -- ^ "MemoryBytes" - Memory limit in Bytes.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecResourcesLimits
instance A.FromJSON TaskSpecResourcesLimits where
  parseJSON = A.withObject "TaskSpecResourcesLimits" $ \o ->
    TaskSpecResourcesLimits
      <$> (o .:? "NanoCPUs")
      <*> (o .:? "MemoryBytes")

-- | ToJSON TaskSpecResourcesLimits
instance A.ToJSON TaskSpecResourcesLimits where
  toJSON TaskSpecResourcesLimits {..} =
   _omitNulls
      [ "NanoCPUs" .= taskSpecResourcesLimitsNanoCpUs
      , "MemoryBytes" .= taskSpecResourcesLimitsMemoryBytes
      ]


-- | Construct a value of type 'TaskSpecResourcesLimits' (by applying it's required fields, if any)
mkTaskSpecResourcesLimits
  :: TaskSpecResourcesLimits
mkTaskSpecResourcesLimits =
  TaskSpecResourcesLimits
  { taskSpecResourcesLimitsNanoCpUs = Nothing
  , taskSpecResourcesLimitsMemoryBytes = Nothing
  }

-- ** TaskSpecResourcesReservation
-- | TaskSpecResourcesReservation
-- Define resources reservation.
data TaskSpecResourcesReservation = TaskSpecResourcesReservation
  { taskSpecResourcesReservationNanoCpUs :: !(Maybe Integer) -- ^ "NanoCPUs" - CPU reservation in units of 10&lt;sup&gt;-9&lt;/sup&gt; CPU shares.
  , taskSpecResourcesReservationMemoryBytes :: !(Maybe Integer) -- ^ "MemoryBytes" - Memory reservation in Bytes.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecResourcesReservation
instance A.FromJSON TaskSpecResourcesReservation where
  parseJSON = A.withObject "TaskSpecResourcesReservation" $ \o ->
    TaskSpecResourcesReservation
      <$> (o .:? "NanoCPUs")
      <*> (o .:? "MemoryBytes")

-- | ToJSON TaskSpecResourcesReservation
instance A.ToJSON TaskSpecResourcesReservation where
  toJSON TaskSpecResourcesReservation {..} =
   _omitNulls
      [ "NanoCPUs" .= taskSpecResourcesReservationNanoCpUs
      , "MemoryBytes" .= taskSpecResourcesReservationMemoryBytes
      ]


-- | Construct a value of type 'TaskSpecResourcesReservation' (by applying it's required fields, if any)
mkTaskSpecResourcesReservation
  :: TaskSpecResourcesReservation
mkTaskSpecResourcesReservation =
  TaskSpecResourcesReservation
  { taskSpecResourcesReservationNanoCpUs = Nothing
  , taskSpecResourcesReservationMemoryBytes = Nothing
  }

-- ** TaskSpecRestartPolicy
-- | TaskSpecRestartPolicy
-- Specification for the restart policy which applies to containers created as part of this service.
data TaskSpecRestartPolicy = TaskSpecRestartPolicy
  { taskSpecRestartPolicyCondition :: !(Maybe E'Condition) -- ^ "Condition" - Condition for restart.
  , taskSpecRestartPolicyDelay :: !(Maybe Integer) -- ^ "Delay" - Delay between restart attempts.
  , taskSpecRestartPolicyMaxAttempts :: !(Maybe Integer) -- ^ "MaxAttempts" - Maximum attempts to restart a given container before giving up (default value is 0, which is ignored).
  , taskSpecRestartPolicyWindow :: !(Maybe Integer) -- ^ "Window" - Windows is the time window used to evaluate the restart policy (default value is 0, which is unbounded).
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecRestartPolicy
instance A.FromJSON TaskSpecRestartPolicy where
  parseJSON = A.withObject "TaskSpecRestartPolicy" $ \o ->
    TaskSpecRestartPolicy
      <$> (o .:? "Condition")
      <*> (o .:? "Delay")
      <*> (o .:? "MaxAttempts")
      <*> (o .:? "Window")

-- | ToJSON TaskSpecRestartPolicy
instance A.ToJSON TaskSpecRestartPolicy where
  toJSON TaskSpecRestartPolicy {..} =
   _omitNulls
      [ "Condition" .= taskSpecRestartPolicyCondition
      , "Delay" .= taskSpecRestartPolicyDelay
      , "MaxAttempts" .= taskSpecRestartPolicyMaxAttempts
      , "Window" .= taskSpecRestartPolicyWindow
      ]


-- | Construct a value of type 'TaskSpecRestartPolicy' (by applying it's required fields, if any)
mkTaskSpecRestartPolicy
  :: TaskSpecRestartPolicy
mkTaskSpecRestartPolicy =
  TaskSpecRestartPolicy
  { taskSpecRestartPolicyCondition = Nothing
  , taskSpecRestartPolicyDelay = Nothing
  , taskSpecRestartPolicyMaxAttempts = Nothing
  , taskSpecRestartPolicyWindow = Nothing
  }

-- ** TaskStatus
-- | TaskStatus
data TaskStatus = TaskStatus
  { taskStatusTimestamp :: !(Maybe Text) -- ^ "Timestamp"
  , taskStatusState :: !(Maybe TaskState) -- ^ "State"
  , taskStatusMessage :: !(Maybe Text) -- ^ "Message"
  , taskStatusErr :: !(Maybe Text) -- ^ "Err"
  , taskStatusContainerStatus :: !(Maybe TaskStatusContainerStatus) -- ^ "ContainerStatus"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskStatus
instance A.FromJSON TaskStatus where
  parseJSON = A.withObject "TaskStatus" $ \o ->
    TaskStatus
      <$> (o .:? "Timestamp")
      <*> (o .:? "State")
      <*> (o .:? "Message")
      <*> (o .:? "Err")
      <*> (o .:? "ContainerStatus")

-- | ToJSON TaskStatus
instance A.ToJSON TaskStatus where
  toJSON TaskStatus {..} =
   _omitNulls
      [ "Timestamp" .= taskStatusTimestamp
      , "State" .= taskStatusState
      , "Message" .= taskStatusMessage
      , "Err" .= taskStatusErr
      , "ContainerStatus" .= taskStatusContainerStatus
      ]


-- | Construct a value of type 'TaskStatus' (by applying it's required fields, if any)
mkTaskStatus
  :: TaskStatus
mkTaskStatus =
  TaskStatus
  { taskStatusTimestamp = Nothing
  , taskStatusState = Nothing
  , taskStatusMessage = Nothing
  , taskStatusErr = Nothing
  , taskStatusContainerStatus = Nothing
  }

-- ** TaskStatusContainerStatus
-- | TaskStatusContainerStatus
data TaskStatusContainerStatus = TaskStatusContainerStatus
  { taskStatusContainerStatusContainerId :: !(Maybe Text) -- ^ "ContainerID"
  , taskStatusContainerStatusPid :: !(Maybe Int) -- ^ "PID"
  , taskStatusContainerStatusExitCode :: !(Maybe Int) -- ^ "ExitCode"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskStatusContainerStatus
instance A.FromJSON TaskStatusContainerStatus where
  parseJSON = A.withObject "TaskStatusContainerStatus" $ \o ->
    TaskStatusContainerStatus
      <$> (o .:? "ContainerID")
      <*> (o .:? "PID")
      <*> (o .:? "ExitCode")

-- | ToJSON TaskStatusContainerStatus
instance A.ToJSON TaskStatusContainerStatus where
  toJSON TaskStatusContainerStatus {..} =
   _omitNulls
      [ "ContainerID" .= taskStatusContainerStatusContainerId
      , "PID" .= taskStatusContainerStatusPid
      , "ExitCode" .= taskStatusContainerStatusExitCode
      ]


-- | Construct a value of type 'TaskStatusContainerStatus' (by applying it's required fields, if any)
mkTaskStatusContainerStatus
  :: TaskStatusContainerStatus
mkTaskStatusContainerStatus =
  TaskStatusContainerStatus
  { taskStatusContainerStatusContainerId = Nothing
  , taskStatusContainerStatusPid = Nothing
  , taskStatusContainerStatusExitCode = Nothing
  }

-- ** ThrottleDevice
-- | ThrottleDevice
data ThrottleDevice = ThrottleDevice
  { throttleDevicePath :: !(Maybe Text) -- ^ "Path" - Device path
  , throttleDeviceRate :: !(Maybe Integer) -- ^ "Rate" - Rate
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ThrottleDevice
instance A.FromJSON ThrottleDevice where
  parseJSON = A.withObject "ThrottleDevice" $ \o ->
    ThrottleDevice
      <$> (o .:? "Path")
      <*> (o .:? "Rate")

-- | ToJSON ThrottleDevice
instance A.ToJSON ThrottleDevice where
  toJSON ThrottleDevice {..} =
   _omitNulls
      [ "Path" .= throttleDevicePath
      , "Rate" .= throttleDeviceRate
      ]


-- | Construct a value of type 'ThrottleDevice' (by applying it's required fields, if any)
mkThrottleDevice
  :: ThrottleDevice
mkThrottleDevice =
  ThrottleDevice
  { throttleDevicePath = Nothing
  , throttleDeviceRate = Nothing
  }

-- ** Volume
-- | Volume
data Volume = Volume
  { volumeName :: !(Text) -- ^ /Required/ "Name" - Name of the volume.
  , volumeDriver :: !(Text) -- ^ /Required/ "Driver" - Name of the volume driver used by the volume.
  , volumeMountpoint :: !(Text) -- ^ /Required/ "Mountpoint" - Mount path of the volume on the host.
  , volumeStatus :: !(Maybe (Map.Map String A.Value)) -- ^ "Status" - Low-level details about the volume, provided by the volume driver. Details are returned as a map with key/value pairs: &#x60;{\&quot;key\&quot;:\&quot;value\&quot;,\&quot;key2\&quot;:\&quot;value2\&quot;}&#x60;.  The &#x60;Status&#x60; field is optional, and is omitted if the volume driver does not support this feature. 
  , volumeLabels :: !((Map.Map String Text)) -- ^ /Required/ "Labels" - User-defined key/value metadata.
  , volumeScope :: !(E'Scope) -- ^ /Required/ "Scope" - The level at which the volume exists. Either &#x60;global&#x60; for cluster-wide, or &#x60;local&#x60; for machine level.
  , volumeOptions :: !((Map.Map String Text)) -- ^ /Required/ "Options" - The driver specific options used when creating the volume.
  , volumeUsageData :: !(Maybe VolumeUsageData) -- ^ "UsageData"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Volume
instance A.FromJSON Volume where
  parseJSON = A.withObject "Volume" $ \o ->
    Volume
      <$> (o .:  "Name")
      <*> (o .:  "Driver")
      <*> (o .:  "Mountpoint")
      <*> (o .:? "Status")
      <*> (o .:  "Labels")
      <*> (o .:  "Scope")
      <*> (o .:  "Options")
      <*> (o .:? "UsageData")

-- | ToJSON Volume
instance A.ToJSON Volume where
  toJSON Volume {..} =
   _omitNulls
      [ "Name" .= volumeName
      , "Driver" .= volumeDriver
      , "Mountpoint" .= volumeMountpoint
      , "Status" .= volumeStatus
      , "Labels" .= volumeLabels
      , "Scope" .= volumeScope
      , "Options" .= volumeOptions
      , "UsageData" .= volumeUsageData
      ]


-- | Construct a value of type 'Volume' (by applying it's required fields, if any)
mkVolume
  :: Text -- ^ 'volumeName': Name of the volume.
  -> Text -- ^ 'volumeDriver': Name of the volume driver used by the volume.
  -> Text -- ^ 'volumeMountpoint': Mount path of the volume on the host.
  -> (Map.Map String Text) -- ^ 'volumeLabels': User-defined key/value metadata.
  -> E'Scope -- ^ 'volumeScope': The level at which the volume exists. Either `global` for cluster-wide, or `local` for machine level.
  -> (Map.Map String Text) -- ^ 'volumeOptions': The driver specific options used when creating the volume.
  -> Volume
mkVolume volumeName volumeDriver volumeMountpoint volumeLabels volumeScope volumeOptions =
  Volume
  { volumeName
  , volumeDriver
  , volumeMountpoint
  , volumeStatus = Nothing
  , volumeLabels
  , volumeScope
  , volumeOptions
  , volumeUsageData = Nothing
  }

-- ** VolumeConfig
-- | VolumeConfig
data VolumeConfig = VolumeConfig
  { volumeConfigName :: !(Maybe Text) -- ^ "Name" - The new volume&#39;s name. If not specified, Docker generates a name.
  , volumeConfigDriver :: !(Maybe Text) -- ^ "Driver" - Name of the volume driver to use.
  , volumeConfigDriverOpts :: !(Maybe (Map.Map String Text)) -- ^ "DriverOpts" - A mapping of driver options and values. These options are passed directly to the driver and are driver specific.
  , volumeConfigLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON VolumeConfig
instance A.FromJSON VolumeConfig where
  parseJSON = A.withObject "VolumeConfig" $ \o ->
    VolumeConfig
      <$> (o .:? "Name")
      <*> (o .:? "Driver")
      <*> (o .:? "DriverOpts")
      <*> (o .:? "Labels")

-- | ToJSON VolumeConfig
instance A.ToJSON VolumeConfig where
  toJSON VolumeConfig {..} =
   _omitNulls
      [ "Name" .= volumeConfigName
      , "Driver" .= volumeConfigDriver
      , "DriverOpts" .= volumeConfigDriverOpts
      , "Labels" .= volumeConfigLabels
      ]


-- | Construct a value of type 'VolumeConfig' (by applying it's required fields, if any)
mkVolumeConfig
  :: VolumeConfig
mkVolumeConfig =
  VolumeConfig
  { volumeConfigName = Nothing
  , volumeConfigDriver = Nothing
  , volumeConfigDriverOpts = Nothing
  , volumeConfigLabels = Nothing
  }

-- ** VolumeUsageData
-- | VolumeUsageData
data VolumeUsageData = VolumeUsageData
  { volumeUsageDataSize :: !(Int) -- ^ /Required/ "Size" - The disk space used by the volume (local driver only)
  , volumeUsageDataRefCount :: !(Int) -- ^ /Required/ "RefCount" - The number of containers referencing this volume.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON VolumeUsageData
instance A.FromJSON VolumeUsageData where
  parseJSON = A.withObject "VolumeUsageData" $ \o ->
    VolumeUsageData
      <$> (o .:  "Size")
      <*> (o .:  "RefCount")

-- | ToJSON VolumeUsageData
instance A.ToJSON VolumeUsageData where
  toJSON VolumeUsageData {..} =
   _omitNulls
      [ "Size" .= volumeUsageDataSize
      , "RefCount" .= volumeUsageDataRefCount
      ]


-- | Construct a value of type 'VolumeUsageData' (by applying it's required fields, if any)
mkVolumeUsageData
  :: Int -- ^ 'volumeUsageDataSize': The disk space used by the volume (local driver only)
  -> Int -- ^ 'volumeUsageDataRefCount': The number of containers referencing this volume.
  -> VolumeUsageData
mkVolumeUsageData volumeUsageDataSize volumeUsageDataRefCount =
  VolumeUsageData
  { volumeUsageDataSize
  , volumeUsageDataRefCount
  }

-- ** HostConfig
-- | HostConfig
-- Container configuration that depends on the host we are running on
data HostConfig = HostConfig
  { hostConfigCpuShares :: !(Maybe Int) -- ^ "CpuShares" - An integer value representing this container&#39;s relative CPU weight versus other containers.
  , hostConfigMemory :: !(Maybe Int) -- ^ "Memory" - Memory limit in bytes.
  , hostConfigCgroupParent :: !(Maybe Text) -- ^ "CgroupParent" - Path to &#x60;cgroups&#x60; under which the container&#39;s &#x60;cgroup&#x60; is created. If the path is not absolute, the path is considered to be relative to the &#x60;cgroups&#x60; path of the init process. Cgroups are created if they do not already exist.
  , hostConfigBlkioWeight :: !(Maybe Int) -- ^ "BlkioWeight" - Block IO weight (relative weight).
  , hostConfigBlkioWeightDevice :: !(Maybe [ResourcesBlkioWeightDevice]) -- ^ "BlkioWeightDevice" - Block IO weight (relative device weight) in the form &#x60;[{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Weight\&quot;: weight}]&#x60;. 
  , hostConfigBlkioDeviceReadBps :: !(Maybe [ThrottleDevice]) -- ^ "BlkioDeviceReadBps" - Limit read rate (bytes per second) from a device, in the form &#x60;[{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Rate\&quot;: rate}]&#x60;. 
  , hostConfigBlkioDeviceWriteBps :: !(Maybe [ThrottleDevice]) -- ^ "BlkioDeviceWriteBps" - Limit write rate (bytes per second) to a device, in the form &#x60;[{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Rate\&quot;: rate}]&#x60;. 
  , hostConfigBlkioDeviceReadIOps :: !(Maybe [ThrottleDevice]) -- ^ "BlkioDeviceReadIOps" - Limit read rate (IO per second) from a device, in the form &#x60;[{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Rate\&quot;: rate}]&#x60;. 
  , hostConfigBlkioDeviceWriteIOps :: !(Maybe [ThrottleDevice]) -- ^ "BlkioDeviceWriteIOps" - Limit write rate (IO per second) to a device, in the form &#x60;[{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Rate\&quot;: rate}]&#x60;. 
  , hostConfigCpuPeriod :: !(Maybe Integer) -- ^ "CpuPeriod" - The length of a CPU period in microseconds.
  , hostConfigCpuQuota :: !(Maybe Integer) -- ^ "CpuQuota" - Microseconds of CPU time that the container can get in a CPU period.
  , hostConfigCpuRealtimePeriod :: !(Maybe Integer) -- ^ "CpuRealtimePeriod" - The length of a CPU real-time period in microseconds. Set to 0 to allocate no time allocated to real-time tasks.
  , hostConfigCpuRealtimeRuntime :: !(Maybe Integer) -- ^ "CpuRealtimeRuntime" - The length of a CPU real-time runtime in microseconds. Set to 0 to allocate no time allocated to real-time tasks.
  , hostConfigCpusetCpus :: !(Maybe Text) -- ^ "CpusetCpus" - CPUs in which to allow execution (e.g., &#x60;0-3&#x60;, &#x60;0,1&#x60;)
  , hostConfigCpusetMems :: !(Maybe Text) -- ^ "CpusetMems" - Memory nodes (MEMs) in which to allow execution (0-3, 0,1). Only effective on NUMA systems.
  , hostConfigDevices :: !(Maybe [DeviceMapping]) -- ^ "Devices" - A list of devices to add to the container.
  , hostConfigDiskQuota :: !(Maybe Integer) -- ^ "DiskQuota" - Disk limit (in bytes).
  , hostConfigKernelMemory :: !(Maybe Integer) -- ^ "KernelMemory" - Kernel memory limit in bytes.
  , hostConfigMemoryReservation :: !(Maybe Integer) -- ^ "MemoryReservation" - Memory soft limit in bytes.
  , hostConfigMemorySwap :: !(Maybe Integer) -- ^ "MemorySwap" - Total memory limit (memory + swap). Set as &#x60;-1&#x60; to enable unlimited swap.
  , hostConfigMemorySwappiness :: !(Maybe Integer) -- ^ "MemorySwappiness" - Tune a container&#39;s memory swappiness behavior. Accepts an integer between 0 and 100.
  , hostConfigNanoCpUs :: !(Maybe Integer) -- ^ "NanoCPUs" - CPU quota in units of 10&lt;sup&gt;-9&lt;/sup&gt; CPUs.
  , hostConfigOomKillDisable :: !(Maybe Bool) -- ^ "OomKillDisable" - Disable OOM Killer for the container.
  , hostConfigPidsLimit :: !(Maybe Integer) -- ^ "PidsLimit" - Tune a container&#39;s pids limit. Set -1 for unlimited.
  , hostConfigUlimits :: !(Maybe [ResourcesUlimits]) -- ^ "Ulimits" - A list of resource limits to set in the container. For example: &#x60;{\&quot;Name\&quot;: \&quot;nofile\&quot;, \&quot;Soft\&quot;: 1024, \&quot;Hard\&quot;: 2048}&#x60;\&quot; 
  , hostConfigCpuCount :: !(Maybe Integer) -- ^ "CpuCount" - The number of usable CPUs (Windows only).  On Windows Server containers, the processor resource controls are mutually exclusive. The order of precedence is &#x60;CPUCount&#x60; first, then &#x60;CPUShares&#x60;, and &#x60;CPUPercent&#x60; last. 
  , hostConfigCpuPercent :: !(Maybe Integer) -- ^ "CpuPercent" - The usable percentage of the available CPUs (Windows only).  On Windows Server containers, the processor resource controls are mutually exclusive. The order of precedence is &#x60;CPUCount&#x60; first, then &#x60;CPUShares&#x60;, and &#x60;CPUPercent&#x60; last. 
  , hostConfigIoMaximumIOps :: !(Maybe Integer) -- ^ "IOMaximumIOps" - Maximum IOps for the container system drive (Windows only)
  , hostConfigIoMaximumBandwidth :: !(Maybe Integer) -- ^ "IOMaximumBandwidth" - Maximum IO in bytes per second for the container system drive (Windows only)
  , hostConfigBinds :: !(Maybe [Text]) -- ^ "Binds" - A list of volume bindings for this container. Each volume binding is a string in one of these forms:  - &#x60;host-src:container-dest&#x60; to bind-mount a host path into the container. Both &#x60;host-src&#x60;, and &#x60;container-dest&#x60; must be an _absolute_ path. - &#x60;host-src:container-dest:ro&#x60; to make the bind-mount read-only inside the container. Both &#x60;host-src&#x60;, and &#x60;container-dest&#x60; must be an _absolute_ path. - &#x60;volume-name:container-dest&#x60; to bind-mount a volume managed by a volume driver into the container. &#x60;container-dest&#x60; must be an _absolute_ path. - &#x60;volume-name:container-dest:ro&#x60; to mount the volume read-only inside the container.  &#x60;container-dest&#x60; must be an _absolute_ path. 
  , hostConfigContainerIdFile :: !(Maybe Text) -- ^ "ContainerIDFile" - Path to a file where the container ID is written
  , hostConfigLogConfig :: !(Maybe HostConfigLogConfig) -- ^ "LogConfig"
  , hostConfigNetworkMode :: !(Maybe Text) -- ^ "NetworkMode" - Network mode to use for this container. Supported standard values are: &#x60;bridge&#x60;, &#x60;host&#x60;, &#x60;none&#x60;, and &#x60;container:&lt;name|id&gt;&#x60;. Any other value is taken as a custom network&#39;s name to which this container should connect to.
  , hostConfigPortBindings :: !(Maybe (Map.Map String HostConfigPortBindings)) -- ^ "PortBindings" - A map of exposed container ports and the host port they should map to.
  , hostConfigRestartPolicy :: !(Maybe RestartPolicy) -- ^ "RestartPolicy"
  , hostConfigAutoRemove :: !(Maybe Bool) -- ^ "AutoRemove" - Automatically remove the container when the container&#39;s process exits. This has no effect if &#x60;RestartPolicy&#x60; is set.
  , hostConfigVolumeDriver :: !(Maybe Text) -- ^ "VolumeDriver" - Driver that this container uses to mount volumes.
  , hostConfigVolumesFrom :: !(Maybe [Text]) -- ^ "VolumesFrom" - A list of volumes to inherit from another container, specified in the form &#x60;&lt;container name&gt;[:&lt;ro|rw&gt;]&#x60;.
  , hostConfigMounts :: !(Maybe [Mount]) -- ^ "Mounts" - Specification for mounts to be added to the container.
  , hostConfigCapAdd :: !(Maybe [Text]) -- ^ "CapAdd" - A list of kernel capabilities to add to the container.
  , hostConfigCapDrop :: !(Maybe [Text]) -- ^ "CapDrop" - A list of kernel capabilities to drop from the container.
  , hostConfigDns :: !(Maybe [Text]) -- ^ "Dns" - A list of DNS servers for the container to use.
  , hostConfigDnsOptions :: !(Maybe [Text]) -- ^ "DnsOptions" - A list of DNS options.
  , hostConfigDnsSearch :: !(Maybe [Text]) -- ^ "DnsSearch" - A list of DNS search domains.
  , hostConfigExtraHosts :: !(Maybe [Text]) -- ^ "ExtraHosts" - A list of hostnames/IP mappings to add to the container&#39;s &#x60;/etc/hosts&#x60; file. Specified in the form &#x60;[\&quot;hostname:IP\&quot;]&#x60;. 
  , hostConfigGroupAdd :: !(Maybe [Text]) -- ^ "GroupAdd" - A list of additional groups that the container process will run as.
  , hostConfigIpcMode :: !(Maybe Text) -- ^ "IpcMode" - IPC namespace to use for the container.
  , hostConfigCgroup :: !(Maybe Text) -- ^ "Cgroup" - Cgroup to use for the container.
  , hostConfigLinks :: !(Maybe [Text]) -- ^ "Links" - A list of links for the container in the form &#x60;container_name:alias&#x60;.
  , hostConfigOomScoreAdj :: !(Maybe Int) -- ^ "OomScoreAdj" - An integer value containing the score given to the container in order to tune OOM killer preferences.
  , hostConfigPidMode :: !(Maybe Text) -- ^ "PidMode" - Set the PID (Process) Namespace mode for the container. It can be either:  - &#x60;\&quot;container:&lt;name|id&gt;\&quot;&#x60;: joins another container&#39;s PID namespace - &#x60;\&quot;host\&quot;&#x60;: use the host&#39;s PID namespace inside the container 
  , hostConfigPrivileged :: !(Maybe Bool) -- ^ "Privileged" - Gives the container full access to the host.
  , hostConfigPublishAllPorts :: !(Maybe Bool) -- ^ "PublishAllPorts" - Allocates a random host port for all of a container&#39;s exposed ports.
  , hostConfigReadonlyRootfs :: !(Maybe Bool) -- ^ "ReadonlyRootfs" - Mount the container&#39;s root filesystem as read only.
  , hostConfigSecurityOpt :: !(Maybe [Text]) -- ^ "SecurityOpt" - A list of string values to customize labels for MLS systems, such as SELinux.
  , hostConfigStorageOpt :: !(Maybe (Map.Map String Text)) -- ^ "StorageOpt" - Storage driver options for this container, in the form &#x60;{\&quot;size\&quot;: \&quot;120G\&quot;}&#x60;. 
  , hostConfigTmpfs :: !(Maybe (Map.Map String Text)) -- ^ "Tmpfs" - A map of container directories which should be replaced by tmpfs mounts, and their corresponding mount options. For example: &#x60;{ \&quot;/run\&quot;: \&quot;rw,noexec,nosuid,size&#x3D;65536k\&quot; }&#x60;. 
  , hostConfigUtsMode :: !(Maybe Text) -- ^ "UTSMode" - UTS namespace to use for the container.
  , hostConfigUsernsMode :: !(Maybe Text) -- ^ "UsernsMode" - Sets the usernamespace mode for the container when usernamespace remapping option is enabled.
  , hostConfigShmSize :: !(Maybe Int) -- ^ "ShmSize" - Size of &#x60;/dev/shm&#x60; in bytes. If omitted, the system uses 64MB.
  , hostConfigSysctls :: !(Maybe (Map.Map String Text)) -- ^ "Sysctls" - A list of kernel parameters (sysctls) to set in the container. For example: &#x60;{\&quot;net.ipv4.ip_forward\&quot;: \&quot;1\&quot;}&#x60; 
  , hostConfigRuntime :: !(Maybe Text) -- ^ "Runtime" - Runtime to use with this container.
  , hostConfigConsoleSize :: !(Maybe [Int]) -- ^ "ConsoleSize" - Initial console size, as an &#x60;[height, width]&#x60; array. (Windows only)
  , hostConfigIsolation :: !(Maybe E'Isolation) -- ^ "Isolation" - Isolation technology of the container. (Windows only)
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON HostConfig
instance A.FromJSON HostConfig where
  parseJSON = A.withObject "HostConfig" $ \o ->
    HostConfig
      <$> (o .:? "CpuShares")
      <*> (o .:? "Memory")
      <*> (o .:? "CgroupParent")
      <*> (o .:? "BlkioWeight")
      <*> (o .:? "BlkioWeightDevice")
      <*> (o .:? "BlkioDeviceReadBps")
      <*> (o .:? "BlkioDeviceWriteBps")
      <*> (o .:? "BlkioDeviceReadIOps")
      <*> (o .:? "BlkioDeviceWriteIOps")
      <*> (o .:? "CpuPeriod")
      <*> (o .:? "CpuQuota")
      <*> (o .:? "CpuRealtimePeriod")
      <*> (o .:? "CpuRealtimeRuntime")
      <*> (o .:? "CpusetCpus")
      <*> (o .:? "CpusetMems")
      <*> (o .:? "Devices")
      <*> (o .:? "DiskQuota")
      <*> (o .:? "KernelMemory")
      <*> (o .:? "MemoryReservation")
      <*> (o .:? "MemorySwap")
      <*> (o .:? "MemorySwappiness")
      <*> (o .:? "NanoCPUs")
      <*> (o .:? "OomKillDisable")
      <*> (o .:? "PidsLimit")
      <*> (o .:? "Ulimits")
      <*> (o .:? "CpuCount")
      <*> (o .:? "CpuPercent")
      <*> (o .:? "IOMaximumIOps")
      <*> (o .:? "IOMaximumBandwidth")
      <*> (o .:? "Binds")
      <*> (o .:? "ContainerIDFile")
      <*> (o .:? "LogConfig")
      <*> (o .:? "NetworkMode")
      <*> (o .:? "PortBindings")
      <*> (o .:? "RestartPolicy")
      <*> (o .:? "AutoRemove")
      <*> (o .:? "VolumeDriver")
      <*> (o .:? "VolumesFrom")
      <*> (o .:? "Mounts")
      <*> (o .:? "CapAdd")
      <*> (o .:? "CapDrop")
      <*> (o .:? "Dns")
      <*> (o .:? "DnsOptions")
      <*> (o .:? "DnsSearch")
      <*> (o .:? "ExtraHosts")
      <*> (o .:? "GroupAdd")
      <*> (o .:? "IpcMode")
      <*> (o .:? "Cgroup")
      <*> (o .:? "Links")
      <*> (o .:? "OomScoreAdj")
      <*> (o .:? "PidMode")
      <*> (o .:? "Privileged")
      <*> (o .:? "PublishAllPorts")
      <*> (o .:? "ReadonlyRootfs")
      <*> (o .:? "SecurityOpt")
      <*> (o .:? "StorageOpt")
      <*> (o .:? "Tmpfs")
      <*> (o .:? "UTSMode")
      <*> (o .:? "UsernsMode")
      <*> (o .:? "ShmSize")
      <*> (o .:? "Sysctls")
      <*> (o .:? "Runtime")
      <*> (o .:? "ConsoleSize")
      <*> (o .:? "Isolation")

-- | ToJSON HostConfig
instance A.ToJSON HostConfig where
  toJSON HostConfig {..} =
   _omitNulls
      [ "CpuShares" .= hostConfigCpuShares
      , "Memory" .= hostConfigMemory
      , "CgroupParent" .= hostConfigCgroupParent
      , "BlkioWeight" .= hostConfigBlkioWeight
      , "BlkioWeightDevice" .= hostConfigBlkioWeightDevice
      , "BlkioDeviceReadBps" .= hostConfigBlkioDeviceReadBps
      , "BlkioDeviceWriteBps" .= hostConfigBlkioDeviceWriteBps
      , "BlkioDeviceReadIOps" .= hostConfigBlkioDeviceReadIOps
      , "BlkioDeviceWriteIOps" .= hostConfigBlkioDeviceWriteIOps
      , "CpuPeriod" .= hostConfigCpuPeriod
      , "CpuQuota" .= hostConfigCpuQuota
      , "CpuRealtimePeriod" .= hostConfigCpuRealtimePeriod
      , "CpuRealtimeRuntime" .= hostConfigCpuRealtimeRuntime
      , "CpusetCpus" .= hostConfigCpusetCpus
      , "CpusetMems" .= hostConfigCpusetMems
      , "Devices" .= hostConfigDevices
      , "DiskQuota" .= hostConfigDiskQuota
      , "KernelMemory" .= hostConfigKernelMemory
      , "MemoryReservation" .= hostConfigMemoryReservation
      , "MemorySwap" .= hostConfigMemorySwap
      , "MemorySwappiness" .= hostConfigMemorySwappiness
      , "NanoCPUs" .= hostConfigNanoCpUs
      , "OomKillDisable" .= hostConfigOomKillDisable
      , "PidsLimit" .= hostConfigPidsLimit
      , "Ulimits" .= hostConfigUlimits
      , "CpuCount" .= hostConfigCpuCount
      , "CpuPercent" .= hostConfigCpuPercent
      , "IOMaximumIOps" .= hostConfigIoMaximumIOps
      , "IOMaximumBandwidth" .= hostConfigIoMaximumBandwidth
      , "Binds" .= hostConfigBinds
      , "ContainerIDFile" .= hostConfigContainerIdFile
      , "LogConfig" .= hostConfigLogConfig
      , "NetworkMode" .= hostConfigNetworkMode
      , "PortBindings" .= hostConfigPortBindings
      , "RestartPolicy" .= hostConfigRestartPolicy
      , "AutoRemove" .= hostConfigAutoRemove
      , "VolumeDriver" .= hostConfigVolumeDriver
      , "VolumesFrom" .= hostConfigVolumesFrom
      , "Mounts" .= hostConfigMounts
      , "CapAdd" .= hostConfigCapAdd
      , "CapDrop" .= hostConfigCapDrop
      , "Dns" .= hostConfigDns
      , "DnsOptions" .= hostConfigDnsOptions
      , "DnsSearch" .= hostConfigDnsSearch
      , "ExtraHosts" .= hostConfigExtraHosts
      , "GroupAdd" .= hostConfigGroupAdd
      , "IpcMode" .= hostConfigIpcMode
      , "Cgroup" .= hostConfigCgroup
      , "Links" .= hostConfigLinks
      , "OomScoreAdj" .= hostConfigOomScoreAdj
      , "PidMode" .= hostConfigPidMode
      , "Privileged" .= hostConfigPrivileged
      , "PublishAllPorts" .= hostConfigPublishAllPorts
      , "ReadonlyRootfs" .= hostConfigReadonlyRootfs
      , "SecurityOpt" .= hostConfigSecurityOpt
      , "StorageOpt" .= hostConfigStorageOpt
      , "Tmpfs" .= hostConfigTmpfs
      , "UTSMode" .= hostConfigUtsMode
      , "UsernsMode" .= hostConfigUsernsMode
      , "ShmSize" .= hostConfigShmSize
      , "Sysctls" .= hostConfigSysctls
      , "Runtime" .= hostConfigRuntime
      , "ConsoleSize" .= hostConfigConsoleSize
      , "Isolation" .= hostConfigIsolation
      ]


-- | Construct a value of type 'HostConfig' (by applying it's required fields, if any)
mkHostConfig
  :: HostConfig
mkHostConfig =
  HostConfig
  { hostConfigCpuShares = Nothing
  , hostConfigMemory = Nothing
  , hostConfigCgroupParent = Nothing
  , hostConfigBlkioWeight = Nothing
  , hostConfigBlkioWeightDevice = Nothing
  , hostConfigBlkioDeviceReadBps = Nothing
  , hostConfigBlkioDeviceWriteBps = Nothing
  , hostConfigBlkioDeviceReadIOps = Nothing
  , hostConfigBlkioDeviceWriteIOps = Nothing
  , hostConfigCpuPeriod = Nothing
  , hostConfigCpuQuota = Nothing
  , hostConfigCpuRealtimePeriod = Nothing
  , hostConfigCpuRealtimeRuntime = Nothing
  , hostConfigCpusetCpus = Nothing
  , hostConfigCpusetMems = Nothing
  , hostConfigDevices = Nothing
  , hostConfigDiskQuota = Nothing
  , hostConfigKernelMemory = Nothing
  , hostConfigMemoryReservation = Nothing
  , hostConfigMemorySwap = Nothing
  , hostConfigMemorySwappiness = Nothing
  , hostConfigNanoCpUs = Nothing
  , hostConfigOomKillDisable = Nothing
  , hostConfigPidsLimit = Nothing
  , hostConfigUlimits = Nothing
  , hostConfigCpuCount = Nothing
  , hostConfigCpuPercent = Nothing
  , hostConfigIoMaximumIOps = Nothing
  , hostConfigIoMaximumBandwidth = Nothing
  , hostConfigBinds = Nothing
  , hostConfigContainerIdFile = Nothing
  , hostConfigLogConfig = Nothing
  , hostConfigNetworkMode = Nothing
  , hostConfigPortBindings = Nothing
  , hostConfigRestartPolicy = Nothing
  , hostConfigAutoRemove = Nothing
  , hostConfigVolumeDriver = Nothing
  , hostConfigVolumesFrom = Nothing
  , hostConfigMounts = Nothing
  , hostConfigCapAdd = Nothing
  , hostConfigCapDrop = Nothing
  , hostConfigDns = Nothing
  , hostConfigDnsOptions = Nothing
  , hostConfigDnsSearch = Nothing
  , hostConfigExtraHosts = Nothing
  , hostConfigGroupAdd = Nothing
  , hostConfigIpcMode = Nothing
  , hostConfigCgroup = Nothing
  , hostConfigLinks = Nothing
  , hostConfigOomScoreAdj = Nothing
  , hostConfigPidMode = Nothing
  , hostConfigPrivileged = Nothing
  , hostConfigPublishAllPorts = Nothing
  , hostConfigReadonlyRootfs = Nothing
  , hostConfigSecurityOpt = Nothing
  , hostConfigStorageOpt = Nothing
  , hostConfigTmpfs = Nothing
  , hostConfigUtsMode = Nothing
  , hostConfigUsernsMode = Nothing
  , hostConfigShmSize = Nothing
  , hostConfigSysctls = Nothing
  , hostConfigRuntime = Nothing
  , hostConfigConsoleSize = Nothing
  , hostConfigIsolation = Nothing
  }


-- * Enums


-- ** E'Availability

-- | Enum of 'Text' . 
-- Availability of the node.
data E'Availability
  = E'Availability'Active -- ^ @"active"@
  | E'Availability'Pause -- ^ @"pause"@
  | E'Availability'Drain -- ^ @"drain"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Availability where toJSON = A.toJSON . fromE'Availability
instance A.FromJSON E'Availability where parseJSON o = P.either P.fail (pure . P.id) . toE'Availability =<< A.parseJSON o
instance WH.ToHttpApiData E'Availability where toQueryParam = WH.toQueryParam . fromE'Availability
instance WH.FromHttpApiData E'Availability where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Availability
instance MimeRender MimeMultipartFormData E'Availability where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Availability' enum
fromE'Availability :: E'Availability -> Text
fromE'Availability = \case
  E'Availability'Active -> "active"
  E'Availability'Pause -> "pause"
  E'Availability'Drain -> "drain"

-- | parse 'E'Availability' enum
toE'Availability :: Text -> P.Either String E'Availability
toE'Availability = \case
  "active" -> P.Right E'Availability'Active
  "pause" -> P.Right E'Availability'Pause
  "drain" -> P.Right E'Availability'Drain
  s -> P.Left $ "toE'Availability: enum parse failure: " P.++ P.show s


-- ** E'Condition

-- | Enum of 'Text' . 
-- Condition for restart.
data E'Condition
  = E'Condition'None -- ^ @"none"@
  | E'Condition'On_failure -- ^ @"on-failure"@
  | E'Condition'Any -- ^ @"any"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Condition where toJSON = A.toJSON . fromE'Condition
instance A.FromJSON E'Condition where parseJSON o = P.either P.fail (pure . P.id) . toE'Condition =<< A.parseJSON o
instance WH.ToHttpApiData E'Condition where toQueryParam = WH.toQueryParam . fromE'Condition
instance WH.FromHttpApiData E'Condition where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Condition
instance MimeRender MimeMultipartFormData E'Condition where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Condition' enum
fromE'Condition :: E'Condition -> Text
fromE'Condition = \case
  E'Condition'None -> "none"
  E'Condition'On_failure -> "on-failure"
  E'Condition'Any -> "any"

-- | parse 'E'Condition' enum
toE'Condition :: Text -> P.Either String E'Condition
toE'Condition = \case
  "none" -> P.Right E'Condition'None
  "on-failure" -> P.Right E'Condition'On_failure
  "any" -> P.Right E'Condition'Any
  s -> P.Left $ "toE'Condition: enum parse failure: " P.++ P.show s


-- ** E'ContentType

-- | Enum of 'Text'
data E'ContentType
  = E'ContentType'Tar -- ^ @"application/tar"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'ContentType where toJSON = A.toJSON . fromE'ContentType
instance A.FromJSON E'ContentType where parseJSON o = P.either P.fail (pure . P.id) . toE'ContentType =<< A.parseJSON o
instance WH.ToHttpApiData E'ContentType where toQueryParam = WH.toQueryParam . fromE'ContentType
instance WH.FromHttpApiData E'ContentType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'ContentType
instance MimeRender MimeMultipartFormData E'ContentType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'ContentType' enum
fromE'ContentType :: E'ContentType -> Text
fromE'ContentType = \case
  E'ContentType'Tar -> "application/tar"

-- | parse 'E'ContentType' enum
toE'ContentType :: Text -> P.Either String E'ContentType
toE'ContentType = \case
  "application/tar" -> P.Right E'ContentType'Tar
  s -> P.Left $ "toE'ContentType: enum parse failure: " P.++ P.show s


-- ** E'FailureAction

-- | Enum of 'Text' . 
-- Action to take if an updated task fails to run, or stops running during the update.
data E'FailureAction
  = E'FailureAction'Continue -- ^ @"continue"@
  | E'FailureAction'Pause -- ^ @"pause"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'FailureAction where toJSON = A.toJSON . fromE'FailureAction
instance A.FromJSON E'FailureAction where parseJSON o = P.either P.fail (pure . P.id) . toE'FailureAction =<< A.parseJSON o
instance WH.ToHttpApiData E'FailureAction where toQueryParam = WH.toQueryParam . fromE'FailureAction
instance WH.FromHttpApiData E'FailureAction where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'FailureAction
instance MimeRender MimeMultipartFormData E'FailureAction where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'FailureAction' enum
fromE'FailureAction :: E'FailureAction -> Text
fromE'FailureAction = \case
  E'FailureAction'Continue -> "continue"
  E'FailureAction'Pause -> "pause"

-- | parse 'E'FailureAction' enum
toE'FailureAction :: Text -> P.Either String E'FailureAction
toE'FailureAction = \case
  "continue" -> P.Right E'FailureAction'Continue
  "pause" -> P.Right E'FailureAction'Pause
  s -> P.Left $ "toE'FailureAction: enum parse failure: " P.++ P.show s


-- ** E'Isolation

-- | Enum of 'Text' . 
-- Isolation technology of the container. (Windows only)
data E'Isolation
  = E'Isolation'Default -- ^ @"default"@
  | E'Isolation'Process -- ^ @"process"@
  | E'Isolation'Hyperv -- ^ @"hyperv"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Isolation where toJSON = A.toJSON . fromE'Isolation
instance A.FromJSON E'Isolation where parseJSON o = P.either P.fail (pure . P.id) . toE'Isolation =<< A.parseJSON o
instance WH.ToHttpApiData E'Isolation where toQueryParam = WH.toQueryParam . fromE'Isolation
instance WH.FromHttpApiData E'Isolation where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Isolation
instance MimeRender MimeMultipartFormData E'Isolation where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Isolation' enum
fromE'Isolation :: E'Isolation -> Text
fromE'Isolation = \case
  E'Isolation'Default -> "default"
  E'Isolation'Process -> "process"
  E'Isolation'Hyperv -> "hyperv"

-- | parse 'E'Isolation' enum
toE'Isolation :: Text -> P.Either String E'Isolation
toE'Isolation = \case
  "default" -> P.Right E'Isolation'Default
  "process" -> P.Right E'Isolation'Process
  "hyperv" -> P.Right E'Isolation'Hyperv
  s -> P.Left $ "toE'Isolation: enum parse failure: " P.++ P.show s


-- ** E'Mode

-- | Enum of 'Text' . 
-- The mode of resolution to use for internal load balancing between tasks.
data E'Mode
  = E'Mode'Vip -- ^ @"vip"@
  | E'Mode'Dnsrr -- ^ @"dnsrr"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Mode where toJSON = A.toJSON . fromE'Mode
instance A.FromJSON E'Mode where parseJSON o = P.either P.fail (pure . P.id) . toE'Mode =<< A.parseJSON o
instance WH.ToHttpApiData E'Mode where toQueryParam = WH.toQueryParam . fromE'Mode
instance WH.FromHttpApiData E'Mode where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Mode
instance MimeRender MimeMultipartFormData E'Mode where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Mode' enum
fromE'Mode :: E'Mode -> Text
fromE'Mode = \case
  E'Mode'Vip -> "vip"
  E'Mode'Dnsrr -> "dnsrr"

-- | parse 'E'Mode' enum
toE'Mode :: Text -> P.Either String E'Mode
toE'Mode = \case
  "vip" -> P.Right E'Mode'Vip
  "dnsrr" -> P.Right E'Mode'Dnsrr
  s -> P.Left $ "toE'Mode: enum parse failure: " P.++ P.show s


-- ** E'Name

-- | Enum of 'Text' . 
-- - `always` Always restart - `unless-stopped` Restart always except when the user has manually stopped the container - `on-failure` Restart only when the container exit code is non-zero 
data E'Name
  = E'Name'Always -- ^ @"always"@
  | E'Name'Unless_stopped -- ^ @"unless-stopped"@
  | E'Name'On_failure -- ^ @"on-failure"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Name where toJSON = A.toJSON . fromE'Name
instance A.FromJSON E'Name where parseJSON o = P.either P.fail (pure . P.id) . toE'Name =<< A.parseJSON o
instance WH.ToHttpApiData E'Name where toQueryParam = WH.toQueryParam . fromE'Name
instance WH.FromHttpApiData E'Name where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Name
instance MimeRender MimeMultipartFormData E'Name where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Name' enum
fromE'Name :: E'Name -> Text
fromE'Name = \case
  E'Name'Always -> "always"
  E'Name'Unless_stopped -> "unless-stopped"
  E'Name'On_failure -> "on-failure"

-- | parse 'E'Name' enum
toE'Name :: Text -> P.Either String E'Name
toE'Name = \case
  "always" -> P.Right E'Name'Always
  "unless-stopped" -> P.Right E'Name'Unless_stopped
  "on-failure" -> P.Right E'Name'On_failure
  s -> P.Left $ "toE'Name: enum parse failure: " P.++ P.show s


-- ** E'Protocol

-- | Enum of 'Text' . 
-- Protocol for communication with the external CA (currently only `cfssl` is supported).
data E'Protocol
  = E'Protocol'Cfssl -- ^ @"cfssl"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Protocol where toJSON = A.toJSON . fromE'Protocol
instance A.FromJSON E'Protocol where parseJSON o = P.either P.fail (pure . P.id) . toE'Protocol =<< A.parseJSON o
instance WH.ToHttpApiData E'Protocol where toQueryParam = WH.toQueryParam . fromE'Protocol
instance WH.FromHttpApiData E'Protocol where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Protocol
instance MimeRender MimeMultipartFormData E'Protocol where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Protocol' enum
fromE'Protocol :: E'Protocol -> Text
fromE'Protocol = \case
  E'Protocol'Cfssl -> "cfssl"

-- | parse 'E'Protocol' enum
toE'Protocol :: Text -> P.Either String E'Protocol
toE'Protocol = \case
  "cfssl" -> P.Right E'Protocol'Cfssl
  s -> P.Left $ "toE'Protocol: enum parse failure: " P.++ P.show s


-- ** E'Role

-- | Enum of 'Text' . 
-- Role of the node.
data E'Role
  = E'Role'Worker -- ^ @"worker"@
  | E'Role'Manager -- ^ @"manager"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Role where toJSON = A.toJSON . fromE'Role
instance A.FromJSON E'Role where parseJSON o = P.either P.fail (pure . P.id) . toE'Role =<< A.parseJSON o
instance WH.ToHttpApiData E'Role where toQueryParam = WH.toQueryParam . fromE'Role
instance WH.FromHttpApiData E'Role where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Role
instance MimeRender MimeMultipartFormData E'Role where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Role' enum
fromE'Role :: E'Role -> Text
fromE'Role = \case
  E'Role'Worker -> "worker"
  E'Role'Manager -> "manager"

-- | parse 'E'Role' enum
toE'Role :: Text -> P.Either String E'Role
toE'Role = \case
  "worker" -> P.Right E'Role'Worker
  "manager" -> P.Right E'Role'Manager
  s -> P.Left $ "toE'Role: enum parse failure: " P.++ P.show s


-- ** E'Scope

-- | Enum of 'Text' . 
-- The level at which the volume exists. Either `global` for cluster-wide, or `local` for machine level.
data E'Scope
  = E'Scope'Local -- ^ @"local"@
  | E'Scope'Global -- ^ @"global"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Scope where toJSON = A.toJSON . fromE'Scope
instance A.FromJSON E'Scope where parseJSON o = P.either P.fail (pure . P.id) . toE'Scope =<< A.parseJSON o
instance WH.ToHttpApiData E'Scope where toQueryParam = WH.toQueryParam . fromE'Scope
instance WH.FromHttpApiData E'Scope where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Scope
instance MimeRender MimeMultipartFormData E'Scope where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Scope' enum
fromE'Scope :: E'Scope -> Text
fromE'Scope = \case
  E'Scope'Local -> "local"
  E'Scope'Global -> "global"

-- | parse 'E'Scope' enum
toE'Scope :: Text -> P.Either String E'Scope
toE'Scope = \case
  "local" -> P.Right E'Scope'Local
  "global" -> P.Right E'Scope'Global
  s -> P.Left $ "toE'Scope: enum parse failure: " P.++ P.show s


-- ** E'State

-- | Enum of 'Text'
data E'State
  = E'State'Updating -- ^ @"updating"@
  | E'State'Paused -- ^ @"paused"@
  | E'State'Completed -- ^ @"completed"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'State where toJSON = A.toJSON . fromE'State
instance A.FromJSON E'State where parseJSON o = P.either P.fail (pure . P.id) . toE'State =<< A.parseJSON o
instance WH.ToHttpApiData E'State where toQueryParam = WH.toQueryParam . fromE'State
instance WH.FromHttpApiData E'State where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'State
instance MimeRender MimeMultipartFormData E'State where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'State' enum
fromE'State :: E'State -> Text
fromE'State = \case
  E'State'Updating -> "updating"
  E'State'Paused -> "paused"
  E'State'Completed -> "completed"

-- | parse 'E'State' enum
toE'State :: Text -> P.Either String E'State
toE'State = \case
  "updating" -> P.Right E'State'Updating
  "paused" -> P.Right E'State'Paused
  "completed" -> P.Right E'State'Completed
  s -> P.Left $ "toE'State: enum parse failure: " P.++ P.show s


-- ** E'Type

-- | Enum of 'Text'
data E'Type
  = E'Type'Tcp -- ^ @"tcp"@
  | E'Type'Udp -- ^ @"udp"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type where toJSON = A.toJSON . fromE'Type
instance A.FromJSON E'Type where parseJSON o = P.either P.fail (pure . P.id) . toE'Type =<< A.parseJSON o
instance WH.ToHttpApiData E'Type where toQueryParam = WH.toQueryParam . fromE'Type
instance WH.FromHttpApiData E'Type where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type
instance MimeRender MimeMultipartFormData E'Type where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type' enum
fromE'Type :: E'Type -> Text
fromE'Type = \case
  E'Type'Tcp -> "tcp"
  E'Type'Udp -> "udp"

-- | parse 'E'Type' enum
toE'Type :: Text -> P.Either String E'Type
toE'Type = \case
  "tcp" -> P.Right E'Type'Tcp
  "udp" -> P.Right E'Type'Udp
  s -> P.Left $ "toE'Type: enum parse failure: " P.++ P.show s


-- ** E'Type2

-- | Enum of 'Text' . 
-- The mount type. Available types:  - `bind` Mounts a file or directory from the host into the container. Must exist prior to creating the container. - `volume` Creates a volume with the given name and options (or uses a pre-existing volume with the same name and options). These are **not** removed when the container is removed. - `tmpfs` Create a tmpfs with the given options. The mount source cannot be specified for tmpfs. 
data E'Type2
  = E'Type2'Bind -- ^ @"bind"@
  | E'Type2'Volume -- ^ @"volume"@
  | E'Type2'Tmpfs -- ^ @"tmpfs"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type2 where toJSON = A.toJSON . fromE'Type2
instance A.FromJSON E'Type2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type2 where toQueryParam = WH.toQueryParam . fromE'Type2
instance WH.FromHttpApiData E'Type2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type2
instance MimeRender MimeMultipartFormData E'Type2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type2' enum
fromE'Type2 :: E'Type2 -> Text
fromE'Type2 = \case
  E'Type2'Bind -> "bind"
  E'Type2'Volume -> "volume"
  E'Type2'Tmpfs -> "tmpfs"

-- | parse 'E'Type2' enum
toE'Type2 :: Text -> P.Either String E'Type2
toE'Type2 = \case
  "bind" -> P.Right E'Type2'Bind
  "volume" -> P.Right E'Type2'Volume
  "tmpfs" -> P.Right E'Type2'Tmpfs
  s -> P.Left $ "toE'Type2: enum parse failure: " P.++ P.show s


-- ** E'Type3

-- | Enum of 'Text'
data E'Type3
  = E'Type3'Json_file -- ^ @"json-file"@
  | E'Type3'Syslog -- ^ @"syslog"@
  | E'Type3'Journald -- ^ @"journald"@
  | E'Type3'Gelf -- ^ @"gelf"@
  | E'Type3'Fluentd -- ^ @"fluentd"@
  | E'Type3'Awslogs -- ^ @"awslogs"@
  | E'Type3'Splunk -- ^ @"splunk"@
  | E'Type3'Etwlogs -- ^ @"etwlogs"@
  | E'Type3'None -- ^ @"none"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type3 where toJSON = A.toJSON . fromE'Type3
instance A.FromJSON E'Type3 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type3 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type3 where toQueryParam = WH.toQueryParam . fromE'Type3
instance WH.FromHttpApiData E'Type3 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type3
instance MimeRender MimeMultipartFormData E'Type3 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type3' enum
fromE'Type3 :: E'Type3 -> Text
fromE'Type3 = \case
  E'Type3'Json_file -> "json-file"
  E'Type3'Syslog -> "syslog"
  E'Type3'Journald -> "journald"
  E'Type3'Gelf -> "gelf"
  E'Type3'Fluentd -> "fluentd"
  E'Type3'Awslogs -> "awslogs"
  E'Type3'Splunk -> "splunk"
  E'Type3'Etwlogs -> "etwlogs"
  E'Type3'None -> "none"

-- | parse 'E'Type3' enum
toE'Type3 :: Text -> P.Either String E'Type3
toE'Type3 = \case
  "json-file" -> P.Right E'Type3'Json_file
  "syslog" -> P.Right E'Type3'Syslog
  "journald" -> P.Right E'Type3'Journald
  "gelf" -> P.Right E'Type3'Gelf
  "fluentd" -> P.Right E'Type3'Fluentd
  "awslogs" -> P.Right E'Type3'Awslogs
  "splunk" -> P.Right E'Type3'Splunk
  "etwlogs" -> P.Right E'Type3'Etwlogs
  "none" -> P.Right E'Type3'None
  s -> P.Left $ "toE'Type3: enum parse failure: " P.++ P.show s


-- ** TaskState

-- | Enum of 'Text'
data TaskState
  = TaskState'New -- ^ @"new"@
  | TaskState'Allocated -- ^ @"allocated"@
  | TaskState'Pending -- ^ @"pending"@
  | TaskState'Assigned -- ^ @"assigned"@
  | TaskState'Accepted -- ^ @"accepted"@
  | TaskState'Preparing -- ^ @"preparing"@
  | TaskState'Ready -- ^ @"ready"@
  | TaskState'Starting -- ^ @"starting"@
  | TaskState'Running -- ^ @"running"@
  | TaskState'Complete -- ^ @"complete"@
  | TaskState'Shutdown -- ^ @"shutdown"@
  | TaskState'Failed -- ^ @"failed"@
  | TaskState'Rejected -- ^ @"rejected"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON TaskState where toJSON = A.toJSON . fromTaskState
instance A.FromJSON TaskState where parseJSON o = P.either P.fail (pure . P.id) . toTaskState =<< A.parseJSON o
instance WH.ToHttpApiData TaskState where toQueryParam = WH.toQueryParam . fromTaskState
instance WH.FromHttpApiData TaskState where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toTaskState
instance MimeRender MimeMultipartFormData TaskState where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'TaskState' enum
fromTaskState :: TaskState -> Text
fromTaskState = \case
  TaskState'New -> "new"
  TaskState'Allocated -> "allocated"
  TaskState'Pending -> "pending"
  TaskState'Assigned -> "assigned"
  TaskState'Accepted -> "accepted"
  TaskState'Preparing -> "preparing"
  TaskState'Ready -> "ready"
  TaskState'Starting -> "starting"
  TaskState'Running -> "running"
  TaskState'Complete -> "complete"
  TaskState'Shutdown -> "shutdown"
  TaskState'Failed -> "failed"
  TaskState'Rejected -> "rejected"

-- | parse 'TaskState' enum
toTaskState :: Text -> P.Either String TaskState
toTaskState = \case
  "new" -> P.Right TaskState'New
  "allocated" -> P.Right TaskState'Allocated
  "pending" -> P.Right TaskState'Pending
  "assigned" -> P.Right TaskState'Assigned
  "accepted" -> P.Right TaskState'Accepted
  "preparing" -> P.Right TaskState'Preparing
  "ready" -> P.Right TaskState'Ready
  "starting" -> P.Right TaskState'Starting
  "running" -> P.Right TaskState'Running
  "complete" -> P.Right TaskState'Complete
  "shutdown" -> P.Right TaskState'Shutdown
  "failed" -> P.Right TaskState'Failed
  "rejected" -> P.Right TaskState'Rejected
  s -> P.Left $ "toTaskState: enum parse failure: " P.++ P.show s

{-
   Docker Engine API

   The Engine API is an HTTP API served by Docker Engine. It is the API the Docker client uses to communicate with the Engine, so everything the Docker client can do can be done with the API.  Most of the client's commands map directly to API endpoints (e.g. `docker ps` is `GET /containers/json`). The notable exception is running containers, which consists of several API calls.  # Errors  The API uses standard HTTP status codes to indicate the success or failure of the API call. The body of the response will be JSON in the following format:  ``` {   \"message\": \"page not found\" } ```  # Versioning  The API is usually changed in each release of Docker, so API calls are versioned to ensure that clients don't break.  For Docker Engine 1.13, the API version is 1.25. To lock to this version, you prefix the URL with `/v1.25`. For example, calling `/info` is the same as calling `/v1.25/info`.  Engine releases in the near future should support this version of the API, so your client will continue to work even if it is talking to a newer Engine.  In previous versions of Docker, it was possible to access the API without providing a version. This behaviour is now deprecated will be removed in a future version of Docker.  The API uses an open schema model, which means server may add extra properties to responses. Likewise, the server will ignore any extra query parameters and request body properties. When you write clients, you need to ignore additional properties in responses to ensure they do not break when talking to newer Docker daemons.  This documentation is for version 1.25 of the API, which was introduced with Docker 1.13. Use this table to find documentation for previous versions of the API:  Docker version  | API version | Changes ----------------|-------------|--------- 1.12.x | [1.24](https://docs.docker.com/engine/api/v1.24/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-24-api-changes) 1.11.x | [1.23](https://docs.docker.com/engine/api/v1.23/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-23-api-changes) 1.10.x | [1.22](https://docs.docker.com/engine/api/v1.22/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-22-api-changes) 1.9.x | [1.21](https://docs.docker.com/engine/api/v1.21/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-21-api-changes) 1.8.x | [1.20](https://docs.docker.com/engine/api/v1.20/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-20-api-changes) 1.7.x | [1.19](https://docs.docker.com/engine/api/v1.19/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-19-api-changes) 1.6.x | [1.18](https://docs.docker.com/engine/api/v1.18/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-18-api-changes)  # Authentication  Authentication for registries is handled client side. The client has to send authentication details to various endpoints that need to communicate with registries, such as `POST /images/(name)/push`. These are sent as `X-Registry-Auth` header as a Base64 encoded (JSON) string with the following structure:  ``` {   \"username\": \"string\",   \"password\": \"string\",   \"email\": \"string\",   \"serveraddress\": \"string\" } ```  The `serveraddress` is a domain/IP without a protocol. Throughout this structure, double quotes are required.  If you have already got an identity token from the [`/auth` endpoint](#operation/SystemAuth), you can just pass this instead of credentials:  ``` {   \"identitytoken\": \"9cbaf023786cd7...\" } ```

   OpenAPI spec version: 2.0
   Docker Engine API API version: 1.25
   Generated by Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
-}

{-|
Module : DockerEngine.API
-}

{-# LANGUAGE ConstraintKinds #-}
{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE InstanceSigs #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing -fno-warn-unused-binds -fno-warn-unused-imports #-}

module DockerEngine.API where

import DockerEngine.Core
import DockerEngine.MimeTypes
import DockerEngine.Model as M

import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Proxy as P (Proxy(..))
import qualified Data.Set as Set
import qualified Data.String as P
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Text.Lazy as TL
import qualified Data.Text.Lazy.Encoding as TL
import qualified Data.Time as TI
import qualified GHC.Base as P (Alternative)
import qualified Lens.Micro as L
import qualified Network.HTTP.Client.MultipartFormData as NH
import qualified Network.HTTP.Media as ME
import qualified Network.HTTP.Types as NH
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import GHC.Base ((<|>))

import Prelude ((==),(/=),($), (.),(<$>),(<*>),(>>=),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)
import qualified Prelude as P

-- * Operations


-- ** Container

-- *** containerArchiveHead

-- | @HEAD \/containers\/{id}\/archive@
--
-- Get information about files in a container
--
-- A response header `X-Docker-Container-Path-Stat` is return containing a base64 - encoded JSON object with some filesystem header information about the path.
--
-- Note: Has 'Produces' instances, but no response schema
--
containerArchiveHead
  :: Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  ID or name of the container
  -> Path -- ^ "path" -  Resource in the container’s filesystem to archive.
  -> DockerEngineRequest ContainerArchiveHead MimeNoContent res accept
containerArchiveHead  _ (Id id) (Path path) =
  _mkRequest "HEAD" ["/containers/",toPath id,"/archive"]
    `setQuery` toQuery ("path", Just path)

data ContainerArchiveHead

-- | @application/json@
instance Consumes ContainerArchiveHead MimeJSON
-- | @text/plain@
instance Consumes ContainerArchiveHead MimePlainText

-- | @application/json@
instance Produces ContainerArchiveHead MimeJSON
-- | @text/plain@
instance Produces ContainerArchiveHead MimePlainText


-- *** containerAttach

-- | @POST \/containers\/{id}\/attach@
--
-- Attach to a container
--
-- Attach to a container to read its output or send it input. You can attach to the same container multiple times and you can reattach to containers that have been detached.  Either the `stream` or `logs` parameter must be `true` for this endpoint to do anything.  See [the documentation for the `docker attach` command](https://docs.docker.com/engine/reference/commandline/attach/) for more details.  ### Hijacking  This endpoint hijacks the HTTP connection to transport `stdin`, `stdout`, and `stderr` on the same socket.  This is the response from the daemon for an attach request:  ``` HTTP/1.1 200 OK Content-Type: application/vnd.docker.raw-stream  [STREAM] ```  After the headers and two new lines, the TCP connection can now be used for raw, bidirectional communication between the client and server.  To hint potential proxies about connection hijacking, the Docker client can also optionally send connection upgrade headers.  For example, the client sends this request to upgrade the connection:  ``` POST /containers/16253994b7c4/attach?stream=1&stdout=1 HTTP/1.1 Upgrade: tcp Connection: Upgrade ```  The Docker daemon will respond with a `101 UPGRADED` response, and will similarly follow with the raw stream:  ``` HTTP/1.1 101 UPGRADED Content-Type: application/vnd.docker.raw-stream Connection: Upgrade Upgrade: tcp  [STREAM] ```  ### Stream format  When the TTY setting is disabled in [`POST /containers/create`](#operation/ContainerCreate), the stream over the hijacked connected is multiplexed to separate out `stdout` and `stderr`. The stream consists of a series of frames, each containing a header and a payload.  The header contains the information which the stream writes (`stdout` or `stderr`). It also contains the size of the associated frame encoded in the last four bytes (`uint32`).  It is encoded on the first eight bytes like this:  ```go header := [8]byte{STREAM_TYPE, 0, 0, 0, SIZE1, SIZE2, SIZE3, SIZE4} ```  `STREAM_TYPE` can be:  - 0: `stdin` (is written on `stdout`) - 1: `stdout` - 2: `stderr`  `SIZE1, SIZE2, SIZE3, SIZE4` are the four bytes of the `uint32` size encoded as big endian.  Following the header is the payload, which is the specified number of bytes of `STREAM_TYPE`.  The simplest way to implement this protocol is the following:  1. Read 8 bytes. 2. Choose `stdout` or `stderr` depending on the first byte. 3. Extract the frame size from the last four bytes. 4. Read the extracted size and output it on the correct output. 5. Goto 1.  ### Stream format when using a TTY  When the TTY setting is enabled in [`POST /containers/create`](#operation/ContainerCreate), the stream is not multiplexed. The data exchanged over the hijacked connection is simply the raw data from the process PTY and client's `stdin`.
--
-- Note: Has 'Produces' instances, but no response schema
--
containerAttach
  :: Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  ID or name of the container
  -> DockerEngineRequest ContainerAttach MimeNoContent res accept
containerAttach  _ (Id id) =
  _mkRequest "POST" ["/containers/",toPath id,"/attach"]

data ContainerAttach

-- | /Optional Param/ "detachKeys" - Override the key sequence for detaching a container.Format is a single character `[a-Z]` or `ctrl-<value>` where `<value>` is one of: `a-z`, `@`, `^`, `[`, `,` or `_`.
instance HasOptionalParam ContainerAttach DetachKeys where
  applyOptionalParam req (DetachKeys xs) =
    req `setQuery` toQuery ("detachKeys", Just xs)

-- | /Optional Param/ "logs" - Replay previous logs from the container.  This is useful for attaching to a container that has started and you want to output everything since the container started.  If `stream` is also enabled, once all the previous output has been returned, it will seamlessly transition into streaming current output.
instance HasOptionalParam ContainerAttach Logs where
  applyOptionalParam req (Logs xs) =
    req `setQuery` toQuery ("logs", Just xs)

-- | /Optional Param/ "stream" - Stream attached streams from the the time the request was made onwards
instance HasOptionalParam ContainerAttach Stream where
  applyOptionalParam req (Stream xs) =
    req `setQuery` toQuery ("stream", Just xs)

-- | /Optional Param/ "stdin" - Attach to `stdin`
instance HasOptionalParam ContainerAttach Stdin where
  applyOptionalParam req (Stdin xs) =
    req `setQuery` toQuery ("stdin", Just xs)

-- | /Optional Param/ "stdout" - Attach to `stdout`
instance HasOptionalParam ContainerAttach Stdout where
  applyOptionalParam req (Stdout xs) =
    req `setQuery` toQuery ("stdout", Just xs)

-- | /Optional Param/ "stderr" - Attach to `stderr`
instance HasOptionalParam ContainerAttach Stderr where
  applyOptionalParam req (Stderr xs) =
    req `setQuery` toQuery ("stderr", Just xs)

-- | @application/json@
instance Consumes ContainerAttach MimeJSON
-- | @text/plain@
instance Consumes ContainerAttach MimePlainText

-- | @application/vnd.docker.raw-stream@
instance Produces ContainerAttach MimeVndDockerRawStream


-- *** containerAttachWebsocket

-- | @GET \/containers\/{id}\/attach\/ws@
--
-- Attach to a container via a websocket
--
-- Note: Has 'Produces' instances, but no response schema
--
containerAttachWebsocket
  :: Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  ID or name of the container
  -> DockerEngineRequest ContainerAttachWebsocket MimeNoContent res accept
containerAttachWebsocket  _ (Id id) =
  _mkRequest "GET" ["/containers/",toPath id,"/attach/ws"]

data ContainerAttachWebsocket

-- | /Optional Param/ "detachKeys" - Override the key sequence for detaching a container.Format is a single character `[a-Z]` or `ctrl-<value>` where `<value>` is one of: `a-z`, `@`, `^`, `[`, `,`, or `_`.
instance HasOptionalParam ContainerAttachWebsocket DetachKeys where
  applyOptionalParam req (DetachKeys xs) =
    req `setQuery` toQuery ("detachKeys", Just xs)

-- | /Optional Param/ "logs" - Return logs
instance HasOptionalParam ContainerAttachWebsocket Logs where
  applyOptionalParam req (Logs xs) =
    req `setQuery` toQuery ("logs", Just xs)

-- | /Optional Param/ "stream" - Return stream
instance HasOptionalParam ContainerAttachWebsocket Stream where
  applyOptionalParam req (Stream xs) =
    req `setQuery` toQuery ("stream", Just xs)

-- | /Optional Param/ "stdin" - Attach to `stdin`
instance HasOptionalParam ContainerAttachWebsocket Stdin where
  applyOptionalParam req (Stdin xs) =
    req `setQuery` toQuery ("stdin", Just xs)

-- | /Optional Param/ "stdout" - Attach to `stdout`
instance HasOptionalParam ContainerAttachWebsocket Stdout where
  applyOptionalParam req (Stdout xs) =
    req `setQuery` toQuery ("stdout", Just xs)

-- | /Optional Param/ "stderr" - Attach to `stderr`
instance HasOptionalParam ContainerAttachWebsocket Stderr where
  applyOptionalParam req (Stderr xs) =
    req `setQuery` toQuery ("stderr", Just xs)

-- | @application/json@
instance Consumes ContainerAttachWebsocket MimeJSON
-- | @text/plain@
instance Consumes ContainerAttachWebsocket MimePlainText

-- | @application/json@
instance Produces ContainerAttachWebsocket MimeJSON
-- | @text/plain@
instance Produces ContainerAttachWebsocket MimePlainText


-- *** containerChanges

-- | @GET \/containers\/{id}\/changes@
--
-- Get changes on a container’s filesystem
--
-- Returns which files in a container's filesystem have been added, deleted, or modified. The `Kind` of modification can be one of:  - `0`: Modified - `1`: Added - `2`: Deleted
--
containerChanges
  :: Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  ID or name of the container
  -> DockerEngineRequest ContainerChanges MimeNoContent [InlineResponse2002] accept
containerChanges  _ (Id id) =
  _mkRequest "GET" ["/containers/",toPath id,"/changes"]

data ContainerChanges

-- | @application/json@
instance Consumes ContainerChanges MimeJSON
-- | @text/plain@
instance Consumes ContainerChanges MimePlainText

-- | @application/json@
instance Produces ContainerChanges MimeJSON


-- *** containerCreate

-- | @POST \/containers\/create@
--
-- Create a container
--
containerCreate
  :: (Consumes ContainerCreate contentType, MimeRender contentType )
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> body -- ^ "body" -  Container to create
  -> DockerEngineRequest ContainerCreate contentType InlineResponse201 accept
containerCreate _  _ body =
  _mkRequest "POST" ["/containers/create"]
    `setBodyParam` body

data ContainerCreate

-- | /Body Param/ "body" - Container to create
instance HasBodyParam ContainerCreate

-- | /Optional Param/ "name" - Assign the specified name to the container. Must match `/?[a-zA-Z0-9_-]+`.
instance HasOptionalParam ContainerCreate Name where
  applyOptionalParam req (Name xs) =
    req `setQuery` toQuery ("name", Just xs)

-- | @application/json@
instance Consumes ContainerCreate MimeJSON
-- | @application/octet-stream@
instance Consumes ContainerCreate MimeOctetStream

-- | @application/json@
instance Produces ContainerCreate MimeJSON


-- *** containerDelete

-- | @DELETE \/containers\/{id}@
--
-- Remove a container
--
-- Note: Has 'Produces' instances, but no response schema
--
containerDelete
  :: Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  ID or name of the container
  -> DockerEngineRequest ContainerDelete MimeNoContent res accept
containerDelete  _ (Id id) =
  _mkRequest "DELETE" ["/containers/",toPath id]

data ContainerDelete

-- | /Optional Param/ "v" - Remove the volumes associated with the container.
instance HasOptionalParam ContainerDelete V where
  applyOptionalParam req (V xs) =
    req `setQuery` toQuery ("v", Just xs)

-- | /Optional Param/ "force" - If the container is running, kill it before removing it.
instance HasOptionalParam ContainerDelete Force where
  applyOptionalParam req (Force xs) =
    req `setQuery` toQuery ("force", Just xs)

-- | @application/json@
instance Consumes ContainerDelete MimeJSON
-- | @text/plain@
instance Consumes ContainerDelete MimePlainText

-- | @application/json@
instance Produces ContainerDelete MimeJSON
-- | @text/plain@
instance Produces ContainerDelete MimePlainText


-- *** containerExport

-- | @GET \/containers\/{id}\/export@
--
-- Export a container
--
-- Export the contents of a container as a tarball.
--
-- Note: Has 'Produces' instances, but no response schema
--
containerExport
  :: Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  ID or name of the container
  -> DockerEngineRequest ContainerExport MimeNoContent res accept
containerExport  _ (Id id) =
  _mkRequest "GET" ["/containers/",toPath id,"/export"]

data ContainerExport

-- | @application/json@
instance Consumes ContainerExport MimeJSON
-- | @text/plain@
instance Consumes ContainerExport MimePlainText

-- | @application/octet-stream@
instance Produces ContainerExport MimeOctetStream


-- *** containerGetArchive

-- | @GET \/containers\/{id}\/archive@
--
-- Get an archive of a filesystem resource in a container
--
-- Get an tar archive of a resource in the filesystem of container id.
--
-- Note: Has 'Produces' instances, but no response schema
--
containerGetArchive
  :: Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  ID or name of the container
  -> Path -- ^ "path" -  Resource in the container’s filesystem to archive.
  -> DockerEngineRequest ContainerGetArchive MimeNoContent res accept
containerGetArchive  _ (Id id) (Path path) =
  _mkRequest "GET" ["/containers/",toPath id,"/archive"]
    `setQuery` toQuery ("path", Just path)

data ContainerGetArchive

-- | @application/json@
instance Consumes ContainerGetArchive MimeJSON
-- | @text/plain@
instance Consumes ContainerGetArchive MimePlainText

-- | @application/x-tar@
instance Produces ContainerGetArchive MimeXTar


-- *** containerInspect

-- | @GET \/containers\/{id}\/json@
--
-- Inspect a container
--
-- Return low-level information about a container.
--
containerInspect
  :: Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  ID or name of the container
  -> DockerEngineRequest ContainerInspect MimeNoContent InlineResponse200 accept
containerInspect  _ (Id id) =
  _mkRequest "GET" ["/containers/",toPath id,"/json"]

data ContainerInspect

-- | /Optional Param/ "size" - Return the size of container as fields `SizeRw` and `SizeRootFs`
instance HasOptionalParam ContainerInspect Size where
  applyOptionalParam req (Size xs) =
    req `setQuery` toQuery ("size", Just xs)

-- | @application/json@
instance Consumes ContainerInspect MimeJSON
-- | @text/plain@
instance Consumes ContainerInspect MimePlainText

-- | @application/json@
instance Produces ContainerInspect MimeJSON


-- *** containerKill

-- | @POST \/containers\/{id}\/kill@
--
-- Kill a container
--
-- Send a POSIX signal to a container, defaulting to killing to the container.
--
-- Note: Has 'Produces' instances, but no response schema
--
containerKill
  :: Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  ID or name of the container
  -> DockerEngineRequest ContainerKill MimeNoContent res accept
containerKill  _ (Id id) =
  _mkRequest "POST" ["/containers/",toPath id,"/kill"]

data ContainerKill

-- | /Optional Param/ "signal" - Signal to send to the container as an integer or string (e.g. `SIGINT`)
instance HasOptionalParam ContainerKill Signal where
  applyOptionalParam req (Signal xs) =
    req `setQuery` toQuery ("signal", Just xs)

-- | @application/json@
instance Consumes ContainerKill MimeJSON
-- | @text/plain@
instance Consumes ContainerKill MimePlainText

-- | @application/json@
instance Produces ContainerKill MimeJSON
-- | @text/plain@
instance Produces ContainerKill MimePlainText


-- *** containerList

-- | @GET \/containers\/json@
--
-- List containers
--
containerList
  :: Accept accept -- ^ request accept ('MimeType')
  -> DockerEngineRequest ContainerList MimeNoContent ContainerSummary accept
containerList  _ =
  _mkRequest "GET" ["/containers/json"]

data ContainerList

-- | /Optional Param/ "all" - Return all containers. By default, only running containers are shown
instance HasOptionalParam ContainerList All where
  applyOptionalParam req (All xs) =
    req `setQuery` toQuery ("all", Just xs)

-- | /Optional Param/ "limit" - Return this number of most recently created containers, including non-running ones.
instance HasOptionalParam ContainerList Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "size" - Return the size of container as fields `SizeRw` and `SizeRootFs`.
instance HasOptionalParam ContainerList Size where
  applyOptionalParam req (Size xs) =
    req `setQuery` toQuery ("size", Just xs)

-- | /Optional Param/ "filters" - Filters to process on the container list, encoded as JSON (a `map[string][]string`). For example, `{\"status\": [\"paused\"]}` will only return paused containers.  Available filters: - `exited=<int>` containers with exit code of `<int>` - `status=`(`created`|`restarting`|`running`|`removing`|`paused`|`exited`|`dead`) - `label=key` or `label=\"key=value\"` of a container label - `isolation=`(`default`|`process`|`hyperv`) (Windows daemon only) - `id=<ID>` a container's ID - `name=<name>` a container's name - `is-task=`(`true`|`false`) - `ancestor`=(`<image-name>[:<tag>]`, `<image id>`, or `<image@digest>`) - `before`=(`<container id>` or `<container name>`) - `since`=(`<container id>` or `<container name>`) - `volume`=(`<volume name>` or `<mount point destination>`) - `network`=(`<network id>` or `<network name>`) - `health`=(`starting`|`healthy`|`unhealthy`|`none`)
instance HasOptionalParam ContainerList Filters where
  applyOptionalParam req (Filters xs) =
    req `setQuery` toQuery ("filters", Just xs)

-- | @application/json@
instance Consumes ContainerList MimeJSON
-- | @text/plain@
instance Consumes ContainerList MimePlainText

-- | @application/json@
instance Produces ContainerList MimeJSON


-- *** containerLogs

-- | @GET \/containers\/{id}\/logs@
--
-- Get container logs
--
-- Get `stdout` and `stderr` logs from a container.  Note: This endpoint works only for containers with the `json-file` or `journald` logging driver.
--
containerLogs
  :: Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  ID or name of the container
  -> DockerEngineRequest ContainerLogs MimeNoContent Text accept
containerLogs  _ (Id id) =
  _mkRequest "GET" ["/containers/",toPath id,"/logs"]

data ContainerLogs

-- | /Optional Param/ "follow" - Return the logs as a stream.  This will return a `101` HTTP response with a `Connection: upgrade` header, then hijack the HTTP connection to send raw output. For more information about hijacking and the stream format, [see the documentation for the attach endpoint](#operation/ContainerAttach).
instance HasOptionalParam ContainerLogs Follow where
  applyOptionalParam req (Follow xs) =
    req `setQuery` toQuery ("follow", Just xs)

-- | /Optional Param/ "stdout" - Return logs from `stdout`
instance HasOptionalParam ContainerLogs Stdout where
  applyOptionalParam req (Stdout xs) =
    req `setQuery` toQuery ("stdout", Just xs)

-- | /Optional Param/ "stderr" - Return logs from `stderr`
instance HasOptionalParam ContainerLogs Stderr where
  applyOptionalParam req (Stderr xs) =
    req `setQuery` toQuery ("stderr", Just xs)

-- | /Optional Param/ "since" - Only return logs since this time, as a UNIX timestamp
instance HasOptionalParam ContainerLogs Since where
  applyOptionalParam req (Since xs) =
    req `setQuery` toQuery ("since", Just xs)

-- | /Optional Param/ "timestamps" - Add timestamps to every log line
instance HasOptionalParam ContainerLogs Timestamps where
  applyOptionalParam req (Timestamps xs) =
    req `setQuery` toQuery ("timestamps", Just xs)

-- | /Optional Param/ "tail" - Only return this number of log lines from the end of the logs. Specify as an integer or `all` to output all log lines.
instance HasOptionalParam ContainerLogs Tail where
  applyOptionalParam req (Tail xs) =
    req `setQuery` toQuery ("tail", Just xs)

-- | @application/json@
instance Consumes ContainerLogs MimeJSON
-- | @text/plain@
instance Consumes ContainerLogs MimePlainText

-- | @application/json@
instance Produces ContainerLogs MimeJSON
-- | @text/plain@
instance Produces ContainerLogs MimePlainText


-- *** containerPause

-- | @POST \/containers\/{id}\/pause@
--
-- Pause a container
--
-- Use the cgroups freezer to suspend all processes in a container.  Traditionally, when suspending a process the `SIGSTOP` signal is used, which is observable by the process being suspended. With the cgroups freezer the process is unaware, and unable to capture, that it is being suspended, and subsequently resumed.
--
-- Note: Has 'Produces' instances, but no response schema
--
containerPause
  :: Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  ID or name of the container
  -> DockerEngineRequest ContainerPause MimeNoContent res accept
containerPause  _ (Id id) =
  _mkRequest "POST" ["/containers/",toPath id,"/pause"]

data ContainerPause

-- | @application/json@
instance Consumes ContainerPause MimeJSON
-- | @text/plain@
instance Consumes ContainerPause MimePlainText

-- | @application/json@
instance Produces ContainerPause MimeJSON
-- | @text/plain@
instance Produces ContainerPause MimePlainText


-- *** containerPrune

-- | @POST \/containers\/prune@
--
-- Delete stopped containers
--
containerPrune
  :: Accept accept -- ^ request accept ('MimeType')
  -> DockerEngineRequest ContainerPrune MimeNoContent InlineResponse2005 accept
containerPrune  _ =
  _mkRequest "POST" ["/containers/prune"]

data ContainerPrune

-- | /Optional Param/ "filters" - Filters to process on the prune list, encoded as JSON (a `map[string][]string`).  Available filters:
instance HasOptionalParam ContainerPrune Filters where
  applyOptionalParam req (Filters xs) =
    req `setQuery` toQuery ("filters", Just xs)

-- | @application/json@
instance Consumes ContainerPrune MimeJSON
-- | @text/plain@
instance Consumes ContainerPrune MimePlainText

-- | @application/json@
instance Produces ContainerPrune MimeJSON


-- *** containerPutArchive

-- | @PUT \/containers\/{id}\/archive@
--
-- Extract an archive of files or folders to a directory in a container
--
-- Upload a tar archive to be extracted to a path in the filesystem of container id.
--
-- Note: Has 'Produces' instances, but no response schema
--
containerPutArchive
  :: (Consumes ContainerPutArchive contentType, MimeRender contentType InputStream2)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  ID or name of the container
  -> Path -- ^ "path" -  Path to a directory in the container to extract the archive’s contents into.
  -> InputStream2 -- ^ "inputStream" -  The input stream must be a tar archive compressed with one of the following algorithms: identity (no compression), gzip, bzip2, xz.
  -> DockerEngineRequest ContainerPutArchive contentType res accept
containerPutArchive _  _ (Id id) (Path path) inputStream =
  _mkRequest "PUT" ["/containers/",toPath id,"/archive"]
    `setQuery` toQuery ("path", Just path)
    `setBodyParam` inputStream

data ContainerPutArchive

-- | /Body Param/ "inputStream" - The input stream must be a tar archive compressed with one of the following algorithms: identity (no compression), gzip, bzip2, xz.
instance HasBodyParam ContainerPutArchive InputStream2

-- | /Optional Param/ "noOverwriteDirNonDir" - If “1”, “true”, or “True” then it will be an error if unpacking the given content would cause an existing directory to be replaced with a non-directory and vice versa.
instance HasOptionalParam ContainerPutArchive NoOverwriteDirNonDir where
  applyOptionalParam req (NoOverwriteDirNonDir xs) =
    req `setQuery` toQuery ("noOverwriteDirNonDir", Just xs)

-- | @application/x-tar@
instance Consumes ContainerPutArchive MimeXTar
-- | @application/octet-stream@
instance Consumes ContainerPutArchive MimeOctetStream

-- | @application/json@
instance Produces ContainerPutArchive MimeJSON
-- | @text/plain@
instance Produces ContainerPutArchive MimePlainText


-- *** containerRename

-- | @POST \/containers\/{id}\/rename@
--
-- Rename a container
--
-- Note: Has 'Produces' instances, but no response schema
--
containerRename
  :: Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  ID or name of the container
  -> Name -- ^ "name" -  New name for the container
  -> DockerEngineRequest ContainerRename MimeNoContent res accept
containerRename  _ (Id id) (Name name) =
  _mkRequest "POST" ["/containers/",toPath id,"/rename"]
    `setQuery` toQuery ("name", Just name)

data ContainerRename

-- | @application/json@
instance Consumes ContainerRename MimeJSON
-- | @text/plain@
instance Consumes ContainerRename MimePlainText

-- | @application/json@
instance Produces ContainerRename MimeJSON
-- | @text/plain@
instance Produces ContainerRename MimePlainText


-- *** containerResize

-- | @POST \/containers\/{id}\/resize@
--
-- Resize a container TTY
--
-- Resize the TTY for a container. You must restart the container for the resize to take effect.
--
-- Note: Has 'Produces' instances, but no response schema
--
containerResize
  :: Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  ID or name of the container
  -> DockerEngineRequest ContainerResize MimeNoContent res accept
containerResize  _ (Id id) =
  _mkRequest "POST" ["/containers/",toPath id,"/resize"]

data ContainerResize

-- | /Optional Param/ "h" - Height of the tty session in characters
instance HasOptionalParam ContainerResize H where
  applyOptionalParam req (H xs) =
    req `setQuery` toQuery ("h", Just xs)

-- | /Optional Param/ "w" - Width of the tty session in characters
instance HasOptionalParam ContainerResize W where
  applyOptionalParam req (W xs) =
    req `setQuery` toQuery ("w", Just xs)

-- | @application/octet-stream@
instance Consumes ContainerResize MimeOctetStream

-- | @text/plain@
instance Produces ContainerResize MimePlainText


-- *** containerRestart

-- | @POST \/containers\/{id}\/restart@
--
-- Restart a container
--
-- Note: Has 'Produces' instances, but no response schema
--
containerRestart
  :: Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  ID or name of the container
  -> DockerEngineRequest ContainerRestart MimeNoContent res accept
containerRestart  _ (Id id) =
  _mkRequest "POST" ["/containers/",toPath id,"/restart"]

data ContainerRestart

-- | /Optional Param/ "t" - Number of seconds to wait before killing the container
instance HasOptionalParam ContainerRestart T where
  applyOptionalParam req (T xs) =
    req `setQuery` toQuery ("t", Just xs)

-- | @application/json@
instance Consumes ContainerRestart MimeJSON
-- | @text/plain@
instance Consumes ContainerRestart MimePlainText

-- | @application/json@
instance Produces ContainerRestart MimeJSON
-- | @text/plain@
instance Produces ContainerRestart MimePlainText


-- *** containerStart

-- | @POST \/containers\/{id}\/start@
--
-- Start a container
--
-- Note: Has 'Produces' instances, but no response schema
--
containerStart
  :: Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  ID or name of the container
  -> DockerEngineRequest ContainerStart MimeNoContent res accept
containerStart  _ (Id id) =
  _mkRequest "POST" ["/containers/",toPath id,"/start"]

data ContainerStart

-- | /Optional Param/ "detachKeys" - Override the key sequence for detaching a container. Format is a single character `[a-Z]` or `ctrl-<value>` where `<value>` is one of: `a-z`, `@`, `^`, `[`, `,` or `_`.
instance HasOptionalParam ContainerStart DetachKeys where
  applyOptionalParam req (DetachKeys xs) =
    req `setQuery` toQuery ("detachKeys", Just xs)

-- | @application/json@
instance Consumes ContainerStart MimeJSON
-- | @text/plain@
instance Consumes ContainerStart MimePlainText

-- | @application/json@
instance Produces ContainerStart MimeJSON
-- | @text/plain@
instance Produces ContainerStart MimePlainText


-- *** containerStats

-- | @GET \/containers\/{id}\/stats@
--
-- Get container stats based on resource usage
--
-- This endpoint returns a live stream of a container’s resource usage statistics.  The `precpu_stats` is the CPU statistic of last read, which is used for calculating the CPU usage percentage. It is not the same as the `cpu_stats` field.
--
containerStats
  :: Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  ID or name of the container
  -> DockerEngineRequest ContainerStats MimeNoContent A.Value accept
containerStats  _ (Id id) =
  _mkRequest "GET" ["/containers/",toPath id,"/stats"]

data ContainerStats

-- | /Optional Param/ "stream" - Stream the output. If false, the stats will be output once and then it will disconnect.
instance HasOptionalParam ContainerStats Stream where
  applyOptionalParam req (Stream xs) =
    req `setQuery` toQuery ("stream", Just xs)

-- | @application/json@
instance Consumes ContainerStats MimeJSON
-- | @text/plain@
instance Consumes ContainerStats MimePlainText

-- | @application/json@
instance Produces ContainerStats MimeJSON


-- *** containerStop

-- | @POST \/containers\/{id}\/stop@
--
-- Stop a container
--
-- Note: Has 'Produces' instances, but no response schema
--
containerStop
  :: Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  ID or name of the container
  -> DockerEngineRequest ContainerStop MimeNoContent res accept
containerStop  _ (Id id) =
  _mkRequest "POST" ["/containers/",toPath id,"/stop"]

data ContainerStop

-- | /Optional Param/ "t" - Number of seconds to wait before killing the container
instance HasOptionalParam ContainerStop T where
  applyOptionalParam req (T xs) =
    req `setQuery` toQuery ("t", Just xs)

-- | @application/json@
instance Consumes ContainerStop MimeJSON
-- | @text/plain@
instance Consumes ContainerStop MimePlainText

-- | @application/json@
instance Produces ContainerStop MimeJSON
-- | @text/plain@
instance Produces ContainerStop MimePlainText


-- *** containerTop

-- | @GET \/containers\/{id}\/top@
--
-- List processes running inside a container
--
-- On Unix systems, this is done by running the `ps` command. This endpoint is not supported on Windows.
--
containerTop
  :: Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  ID or name of the container
  -> DockerEngineRequest ContainerTop MimeNoContent InlineResponse2001 accept
containerTop  _ (Id id) =
  _mkRequest "GET" ["/containers/",toPath id,"/top"]

data ContainerTop

-- | /Optional Param/ "ps_args" - The arguments to pass to `ps`. For example, `aux`
instance HasOptionalParam ContainerTop PsArgs where
  applyOptionalParam req (PsArgs xs) =
    req `setQuery` toQuery ("ps_args", Just xs)

-- | @application/json@
instance Consumes ContainerTop MimeJSON
-- | @text/plain@
instance Consumes ContainerTop MimePlainText

-- | @application/json@
instance Produces ContainerTop MimeJSON
-- | @text/plain@
instance Produces ContainerTop MimePlainText


-- *** containerUnpause

-- | @POST \/containers\/{id}\/unpause@
--
-- Unpause a container
--
-- Resume a container which has been paused.
--
-- Note: Has 'Produces' instances, but no response schema
--
containerUnpause
  :: Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  ID or name of the container
  -> DockerEngineRequest ContainerUnpause MimeNoContent res accept
containerUnpause  _ (Id id) =
  _mkRequest "POST" ["/containers/",toPath id,"/unpause"]

data ContainerUnpause

-- | @application/json@
instance Consumes ContainerUnpause MimeJSON
-- | @text/plain@
instance Consumes ContainerUnpause MimePlainText

-- | @application/json@
instance Produces ContainerUnpause MimeJSON
-- | @text/plain@
instance Produces ContainerUnpause MimePlainText


-- *** containerUpdate

-- | @POST \/containers\/{id}\/update@
--
-- Update a container
--
-- Change various configuration options of a container without having to recreate it.
--
containerUpdate
  :: (Consumes ContainerUpdate contentType, MimeRender contentType )
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  ID or name of the container
  -> update -- ^ "update"
  -> DockerEngineRequest ContainerUpdate contentType InlineResponse2003 accept
containerUpdate _  _ (Id id) update =
  _mkRequest "POST" ["/containers/",toPath id,"/update"]
    `setBodyParam` update

data ContainerUpdate
instance HasBodyParam ContainerUpdate

-- | @application/json@
instance Consumes ContainerUpdate MimeJSON

-- | @application/json@
instance Produces ContainerUpdate MimeJSON


-- *** containerWait

-- | @POST \/containers\/{id}\/wait@
--
-- Wait for a container
--
-- Block until a container stops, then returns the exit code.
--
containerWait
  :: Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  ID or name of the container
  -> DockerEngineRequest ContainerWait MimeNoContent InlineResponse2004 accept
containerWait  _ (Id id) =
  _mkRequest "POST" ["/containers/",toPath id,"/wait"]

data ContainerWait

-- | @application/json@
instance Consumes ContainerWait MimeJSON
-- | @text/plain@
instance Consumes ContainerWait MimePlainText

-- | @application/json@
instance Produces ContainerWait MimeJSON


-- ** Exec

-- *** containerExec

-- | @POST \/containers\/{id}\/exec@
--
-- Create an exec instance
--
-- Run a command inside a running container.
--
containerExec
  :: (Consumes ContainerExec contentType, MimeRender contentType ExecConfig)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> ExecConfig -- ^ "execConfig" -  Exec configuration
  -> Id -- ^ "id" -  ID or name of container
  -> DockerEngineRequest ContainerExec contentType IdResponse accept
containerExec _  _ execConfig (Id id) =
  _mkRequest "POST" ["/containers/",toPath id,"/exec"]
    `setBodyParam` execConfig

data ContainerExec

-- | /Body Param/ "execConfig" - Exec configuration
instance HasBodyParam ContainerExec ExecConfig

-- | @application/json@
instance Consumes ContainerExec MimeJSON

-- | @application/json@
instance Produces ContainerExec MimeJSON


-- *** execInspect

-- | @GET \/exec\/{id}\/json@
--
-- Inspect an exec instance
--
-- Return low-level information about an exec instance.
--
execInspect
  :: Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  Exec instance ID
  -> DockerEngineRequest ExecInspect MimeNoContent InlineResponse20014 accept
execInspect  _ (Id id) =
  _mkRequest "GET" ["/exec/",toPath id,"/json"]

data ExecInspect

-- | @application/json@
instance Consumes ExecInspect MimeJSON
-- | @text/plain@
instance Consumes ExecInspect MimePlainText

-- | @application/json@
instance Produces ExecInspect MimeJSON


-- *** execResize

-- | @POST \/exec\/{id}\/resize@
--
-- Resize an exec instance
--
-- Resize the TTY session used by an exec instance. This endpoint only works if `tty` was specified as part of creating and starting the exec instance.
--
-- Note: Has 'Produces' instances, but no response schema
--
execResize
  :: Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  Exec instance ID
  -> DockerEngineRequest ExecResize MimeNoContent res accept
execResize  _ (Id id) =
  _mkRequest "POST" ["/exec/",toPath id,"/resize"]

data ExecResize

-- | /Optional Param/ "h" - Height of the TTY session in characters
instance HasOptionalParam ExecResize H where
  applyOptionalParam req (H xs) =
    req `setQuery` toQuery ("h", Just xs)

-- | /Optional Param/ "w" - Width of the TTY session in characters
instance HasOptionalParam ExecResize W where
  applyOptionalParam req (W xs) =
    req `setQuery` toQuery ("w", Just xs)

-- | @application/json@
instance Consumes ExecResize MimeJSON
-- | @text/plain@
instance Consumes ExecResize MimePlainText

-- | @application/json@
instance Produces ExecResize MimeJSON
-- | @text/plain@
instance Produces ExecResize MimePlainText


-- *** execStart

-- | @POST \/exec\/{id}\/start@
--
-- Start an exec instance
--
-- Starts a previously set up exec instance. If detach is true, this endpoint returns immediately after starting the command. Otherwise, it sets up an interactive session with the command.
--
-- Note: Has 'Produces' instances, but no response schema
--
execStart
  :: (Consumes ExecStart contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  Exec instance ID
  -> DockerEngineRequest ExecStart contentType res accept
execStart _  _ (Id id) =
  _mkRequest "POST" ["/exec/",toPath id,"/start"]

data ExecStart
instance HasBodyParam ExecStart ExecStartConfig

-- | @application/json@
instance Consumes ExecStart MimeJSON

-- | @application/vnd.docker.raw-stream@
instance Produces ExecStart MimeVndDockerRawStream


-- ** Image

-- *** imageBuild

-- | @POST \/build@
--
-- Build an image
--
-- Build an image from a tar archive with a `Dockerfile` in it.  The `Dockerfile` specifies how the image is built from the tar archive. It is typically in the archive's root, but can be at a different path or have a different name by specifying the `dockerfile` parameter. [See the `Dockerfile` reference for more information](https://docs.docker.com/engine/reference/builder/).  The Docker daemon performs a preliminary validation of the `Dockerfile` before starting the build, and returns an error if the syntax is incorrect. After that, each instruction is run one-by-one until the ID of the new image is output.  The build is canceled if the client drops the connection by quitting or being killed.
--
-- Note: Has 'Produces' instances, but no response schema
--
imageBuild
  :: (Consumes ImageBuild contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> DockerEngineRequest ImageBuild contentType res accept
imageBuild _  _ =
  _mkRequest "POST" ["/build"]

data ImageBuild

-- | /Body Param/ "inputStream" - A tar archive compressed with one of the following algorithms: identity (no compression), gzip, bzip2, xz.
instance HasBodyParam ImageBuild InputStream4

-- | /Optional Param/ "dockerfile" - Path within the build context to the `Dockerfile`. This is ignored if `remote` is specified and points to an external `Dockerfile`.
instance HasOptionalParam ImageBuild Dockerfile where
  applyOptionalParam req (Dockerfile xs) =
    req `setQuery` toQuery ("dockerfile", Just xs)

-- | /Optional Param/ "t" - A name and optional tag to apply to the image in the `name:tag` format. If you omit the tag the default `latest` value is assumed. You can provide several `t` parameters.
instance HasOptionalParam ImageBuild TText where
  applyOptionalParam req (TText xs) =
    req `setQuery` toQuery ("t", Just xs)

-- | /Optional Param/ "remote" - A Git repository URI or HTTP/HTTPS context URI. If the URI points to a single text file, the file’s contents are placed into a file called `Dockerfile` and the image is built from that file. If the URI points to a tarball, the file is downloaded by the daemon and the contents therein used as the context for the build. If the URI points to a tarball and the `dockerfile` parameter is also specified, there must be a file with the corresponding path inside the tarball.
instance HasOptionalParam ImageBuild Remote where
  applyOptionalParam req (Remote xs) =
    req `setQuery` toQuery ("remote", Just xs)

-- | /Optional Param/ "q" - Suppress verbose build output.
instance HasOptionalParam ImageBuild Q where
  applyOptionalParam req (Q xs) =
    req `setQuery` toQuery ("q", Just xs)

-- | /Optional Param/ "nocache" - Do not use the cache when building the image.
instance HasOptionalParam ImageBuild Nocache where
  applyOptionalParam req (Nocache xs) =
    req `setQuery` toQuery ("nocache", Just xs)

-- | /Optional Param/ "cachefrom" - JSON array of images used for build cache resolution.
instance HasOptionalParam ImageBuild Cachefrom where
  applyOptionalParam req (Cachefrom xs) =
    req `setQuery` toQuery ("cachefrom", Just xs)

-- | /Optional Param/ "pull" - Attempt to pull the image even if an older image exists locally.
instance HasOptionalParam ImageBuild Pull where
  applyOptionalParam req (Pull xs) =
    req `setQuery` toQuery ("pull", Just xs)

-- | /Optional Param/ "rm" - Remove intermediate containers after a successful build.
instance HasOptionalParam ImageBuild Rm where
  applyOptionalParam req (Rm xs) =
    req `setQuery` toQuery ("rm", Just xs)

-- | /Optional Param/ "forcerm" - Always remove intermediate containers, even upon failure.
instance HasOptionalParam ImageBuild Forcerm where
  applyOptionalParam req (Forcerm xs) =
    req `setQuery` toQuery ("forcerm", Just xs)

-- | /Optional Param/ "memory" - Set memory limit for build.
instance HasOptionalParam ImageBuild Memory where
  applyOptionalParam req (Memory xs) =
    req `setQuery` toQuery ("memory", Just xs)

-- | /Optional Param/ "memswap" - Total memory (memory + swap). Set as `-1` to disable swap.
instance HasOptionalParam ImageBuild Memswap where
  applyOptionalParam req (Memswap xs) =
    req `setQuery` toQuery ("memswap", Just xs)

-- | /Optional Param/ "cpushares" - CPU shares (relative weight).
instance HasOptionalParam ImageBuild Cpushares where
  applyOptionalParam req (Cpushares xs) =
    req `setQuery` toQuery ("cpushares", Just xs)

-- | /Optional Param/ "cpusetcpus" - CPUs in which to allow execution (e.g., `0-3`, `0,1`).
instance HasOptionalParam ImageBuild Cpusetcpus where
  applyOptionalParam req (Cpusetcpus xs) =
    req `setQuery` toQuery ("cpusetcpus", Just xs)

-- | /Optional Param/ "cpuperiod" - The length of a CPU period in microseconds.
instance HasOptionalParam ImageBuild Cpuperiod where
  applyOptionalParam req (Cpuperiod xs) =
    req `setQuery` toQuery ("cpuperiod", Just xs)

-- | /Optional Param/ "cpuquota" - Microseconds of CPU time that the container can get in a CPU period.
instance HasOptionalParam ImageBuild Cpuquota where
  applyOptionalParam req (Cpuquota xs) =
    req `setQuery` toQuery ("cpuquota", Just xs)

-- | /Optional Param/ "buildargs" - JSON map of string pairs for build-time variables. Users pass these values at build-time. Docker uses the buildargs as the environment context for commands run via the `Dockerfile` RUN instruction, or for variable expansion in other `Dockerfile` instructions. This is not meant for passing secret values. [Read more about the buildargs instruction.](https://docs.docker.com/engine/reference/builder/#arg)
instance HasOptionalParam ImageBuild Buildargs where
  applyOptionalParam req (Buildargs xs) =
    req `setQuery` toQuery ("buildargs", Just xs)

-- | /Optional Param/ "shmsize" - Size of `/dev/shm` in bytes. The size must be greater than 0. If omitted the system uses 64MB.
instance HasOptionalParam ImageBuild Shmsize where
  applyOptionalParam req (Shmsize xs) =
    req `setQuery` toQuery ("shmsize", Just xs)

-- | /Optional Param/ "squash" - Squash the resulting images layers into a single layer. *(Experimental release only.)*
instance HasOptionalParam ImageBuild Squash where
  applyOptionalParam req (Squash xs) =
    req `setQuery` toQuery ("squash", Just xs)

-- | /Optional Param/ "labels" - Arbitrary key/value labels to set on the image, as a JSON map of string pairs.
instance HasOptionalParam ImageBuild Labels where
  applyOptionalParam req (Labels xs) =
    req `setQuery` toQuery ("labels", Just xs)

-- | /Optional Param/ "networkmode" - Sets the networking mode for the run commands during build. Supported standard values are: `bridge`, `host`, `none`, and `container:<name|id>`. Any other value is taken as a custom network's name to which this container should connect to.
instance HasOptionalParam ImageBuild Networkmode where
  applyOptionalParam req (Networkmode xs) =
    req `setQuery` toQuery ("networkmode", Just xs)
instance HasOptionalParam ImageBuild ParamContentType where
  applyOptionalParam req (ParamContentType xs) =
    req `setHeader` toHeader ("Content-type", xs)

-- | /Optional Param/ "X-Registry-Config" - This is a base64-encoded JSON object with auth configurations for multiple registries that a build may refer to.  The key is a registry URL, and the value is an auth configuration object, [as described in the authentication section](#section/Authentication). For example:  ``` {   \"docker.example.com\": {     \"username\": \"janedoe\",     \"password\": \"hunter2\"   },   \"https://index.docker.io/v1/\": {     \"username\": \"mobydock\",     \"password\": \"conta1n3rize14\"   } } ```  Only the registry domain name (and port if not the default 443) are required. However, for legacy reasons, the Docker Hub registry must be specified with both a `https://` prefix and a `/v1/` suffix even though Docker will prefer to use the v2 registry API.
instance HasOptionalParam ImageBuild XRegistryConfig where
  applyOptionalParam req (XRegistryConfig xs) =
    req `setHeader` toHeader ("X-Registry-Config", xs)

-- | @application/octet-stream@
instance Consumes ImageBuild MimeOctetStream

-- | @application/json@
instance Produces ImageBuild MimeJSON


-- *** imageCommit

-- | @POST \/commit@
--
-- Create a new image from a container
--
imageCommit
  :: (Consumes ImageCommit contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> DockerEngineRequest ImageCommit contentType IdResponse accept
imageCommit _  _ =
  _mkRequest "POST" ["/commit"]

data ImageCommit

-- | /Body Param/ "containerConfig" - The container configuration
instance HasBodyParam ImageCommit Config

-- | /Optional Param/ "container" - The ID or name of the container to commit
instance HasOptionalParam ImageCommit Container2 where
  applyOptionalParam req (Container2 xs) =
    req `setQuery` toQuery ("container", Just xs)

-- | /Optional Param/ "repo" - Repository name for the created image
instance HasOptionalParam ImageCommit Repo where
  applyOptionalParam req (Repo xs) =
    req `setQuery` toQuery ("repo", Just xs)

-- | /Optional Param/ "tag" - Tag name for the create image
instance HasOptionalParam ImageCommit Tag where
  applyOptionalParam req (Tag xs) =
    req `setQuery` toQuery ("tag", Just xs)

-- | /Optional Param/ "comment" - Commit message
instance HasOptionalParam ImageCommit Comment where
  applyOptionalParam req (Comment xs) =
    req `setQuery` toQuery ("comment", Just xs)

-- | /Optional Param/ "author" - Author of the image (e.g., `John Hannibal Smith <hannibal@a-team.com>`)
instance HasOptionalParam ImageCommit Author where
  applyOptionalParam req (Author xs) =
    req `setQuery` toQuery ("author", Just xs)

-- | /Optional Param/ "pause" - Whether to pause the container before committing
instance HasOptionalParam ImageCommit Pause where
  applyOptionalParam req (Pause xs) =
    req `setQuery` toQuery ("pause", Just xs)

-- | /Optional Param/ "changes" - `Dockerfile` instructions to apply while committing
instance HasOptionalParam ImageCommit Changes where
  applyOptionalParam req (Changes xs) =
    req `setQuery` toQuery ("changes", Just xs)

-- | @application/json@
instance Consumes ImageCommit MimeJSON

-- | @application/json@
instance Produces ImageCommit MimeJSON


-- *** imageCreate

-- | @POST \/images\/create@
--
-- Create an image
--
-- Create an image by either pulling it from a registry or importing it.
--
-- Note: Has 'Produces' instances, but no response schema
--
imageCreate
  :: (Consumes ImageCreate contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> DockerEngineRequest ImageCreate contentType res accept
imageCreate _  _ =
  _mkRequest "POST" ["/images/create"]

data ImageCreate

-- | /Body Param/ "inputImage" - Image content if the value `-` has been specified in fromSrc query parameter
instance HasBodyParam ImageCreate InputImage2

-- | /Optional Param/ "fromImage" - Name of the image to pull. The name may include a tag or digest. This parameter may only be used when pulling an image. The pull is cancelled if the HTTP connection is closed.
instance HasOptionalParam ImageCreate FromImage where
  applyOptionalParam req (FromImage xs) =
    req `setQuery` toQuery ("fromImage", Just xs)

-- | /Optional Param/ "fromSrc" - Source to import. The value may be a URL from which the image can be retrieved or `-` to read the image from the request body. This parameter may only be used when importing an image.
instance HasOptionalParam ImageCreate FromSrc where
  applyOptionalParam req (FromSrc xs) =
    req `setQuery` toQuery ("fromSrc", Just xs)

-- | /Optional Param/ "repo" - Repository name given to an image when it is imported. The repo may include a tag. This parameter may only be used when importing an image.
instance HasOptionalParam ImageCreate Repo where
  applyOptionalParam req (Repo xs) =
    req `setQuery` toQuery ("repo", Just xs)

-- | /Optional Param/ "tag" - Tag or digest. If empty when pulling an image, this causes all tags for the given image to be pulled.
instance HasOptionalParam ImageCreate Tag where
  applyOptionalParam req (Tag xs) =
    req `setQuery` toQuery ("tag", Just xs)

-- | /Optional Param/ "X-Registry-Auth" - A base64-encoded auth configuration. [See the authentication section for details.](#section/Authentication)
instance HasOptionalParam ImageCreate XRegistryAuth where
  applyOptionalParam req (XRegistryAuth xs) =
    req `setHeader` toHeader ("X-Registry-Auth", xs)

-- | @text/plain@
instance Consumes ImageCreate MimePlainText
-- | @application/octet-stream@
instance Consumes ImageCreate MimeOctetStream

-- | @application/json@
instance Produces ImageCreate MimeJSON


-- *** imageDelete

-- | @DELETE \/images\/{name}@
--
-- Remove an image
--
-- Remove an image, along with any untagged parent images that were referenced by that image.  Images can't be removed if they have descendant images, are being used by a running container or are being used by a build.
--
imageDelete
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  Image name or ID
  -> DockerEngineRequest ImageDelete MimeNoContent [ImageDeleteResponse] accept
imageDelete  _ (Name name) =
  _mkRequest "DELETE" ["/images/",toPath name]

data ImageDelete

-- | /Optional Param/ "force" - Remove the image even if it is being used by stopped containers or has other tags
instance HasOptionalParam ImageDelete Force where
  applyOptionalParam req (Force xs) =
    req `setQuery` toQuery ("force", Just xs)

-- | /Optional Param/ "noprune" - Do not delete untagged parent images
instance HasOptionalParam ImageDelete Noprune where
  applyOptionalParam req (Noprune xs) =
    req `setQuery` toQuery ("noprune", Just xs)

-- | @application/json@
instance Consumes ImageDelete MimeJSON
-- | @text/plain@
instance Consumes ImageDelete MimePlainText

-- | @application/json@
instance Produces ImageDelete MimeJSON


-- *** imageGet

-- | @GET \/images\/{name}\/get@
--
-- Export an image
--
-- Get a tarball containing all images and metadata for a repository.  If `name` is a specific name and tag (e.g. `ubuntu:latest`), then only that image (and its parents) are returned. If `name` is an image ID, similarly only that image (and its parents) are returned, but with the exclusion of the `repositories` file in the tarball, as there were no image names referenced.  ### Image tarball format  An image tarball contains one directory per image layer (named using its long ID), each containing these files:  - `VERSION`: currently `1.0` - the file format version - `json`: detailed layer information, similar to `docker inspect layer_id` - `layer.tar`: A tarfile containing the filesystem changes in this layer  The `layer.tar` file contains `aufs` style `.wh..wh.aufs` files and directories for storing attribute changes and deletions.  If the tarball defines a repository, the tarball should also include a `repositories` file at the root that contains a list of repository and tag names mapped to layer IDs.  ```json {   \"hello-world\": {     \"latest\": \"565a9d68a73f6706862bfe8409a7f659776d4d60a8d096eb4a3cbce6999cc2a1\"   } } ```
--
imageGet
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  Image name or ID
  -> DockerEngineRequest ImageGet MimeNoContent Binary accept
imageGet  _ (Name name) =
  _mkRequest "GET" ["/images/",toPath name,"/get"]

data ImageGet

-- | @application/json@
instance Consumes ImageGet MimeJSON
-- | @text/plain@
instance Consumes ImageGet MimePlainText

-- | @application/x-tar@
instance Produces ImageGet MimeXTar


-- *** imageGetAll

-- | @GET \/images\/get@
--
-- Export several images
--
-- Get a tarball containing all images and metadata for several image repositories.  For each value of the `names` parameter: if it is a specific name and tag (e.g. `ubuntu:latest`), then only that image (and its parents) are returned; if it is an image ID, similarly only that image (and its parents) are returned and there would be no names referenced in the 'repositories' file for this image ID.  For details on the format, see [the export image endpoint](#operation/ImageGet).
--
imageGetAll
  :: Accept accept -- ^ request accept ('MimeType')
  -> DockerEngineRequest ImageGetAll MimeNoContent Binary accept
imageGetAll  _ =
  _mkRequest "GET" ["/images/get"]

data ImageGetAll

-- | /Optional Param/ "names" - Image names to filter by
instance HasOptionalParam ImageGetAll Names where
  applyOptionalParam req (Names xs) =
    req `setQuery` toQueryColl CommaSeparated ("names", Just xs)

-- | @application/json@
instance Consumes ImageGetAll MimeJSON
-- | @text/plain@
instance Consumes ImageGetAll MimePlainText

-- | @application/x-tar@
instance Produces ImageGetAll MimeXTar


-- *** imageHistory

-- | @GET \/images\/{name}\/history@
--
-- Get the history of an image
--
-- Return parent layers of an image.
--
imageHistory
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  Image name or ID
  -> DockerEngineRequest ImageHistory MimeNoContent [InlineResponse2006] accept
imageHistory  _ (Name name) =
  _mkRequest "GET" ["/images/",toPath name,"/history"]

data ImageHistory

-- | @application/json@
instance Consumes ImageHistory MimeJSON
-- | @text/plain@
instance Consumes ImageHistory MimePlainText

-- | @application/json@
instance Produces ImageHistory MimeJSON


-- *** imageInspect

-- | @GET \/images\/{name}\/json@
--
-- Inspect an image
--
-- Return low-level information about an image.
--
imageInspect
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  Image name or id
  -> DockerEngineRequest ImageInspect MimeNoContent Image accept
imageInspect  _ (Name name) =
  _mkRequest "GET" ["/images/",toPath name,"/json"]

data ImageInspect

-- | @application/json@
instance Consumes ImageInspect MimeJSON
-- | @text/plain@
instance Consumes ImageInspect MimePlainText

-- | @application/json@
instance Produces ImageInspect MimeJSON


-- *** imageList

-- | @GET \/images\/json@
--
-- List Images
--
-- Returns a list of images on the server. Note that it uses a different, smaller representation of an image than inspecting a single image.
--
imageList
  :: Accept accept -- ^ request accept ('MimeType')
  -> DockerEngineRequest ImageList MimeNoContent [ImageSummary] accept
imageList  _ =
  _mkRequest "GET" ["/images/json"]

data ImageList

-- | /Optional Param/ "all" - Show all images. Only images from a final layer (no children) are shown by default.
instance HasOptionalParam ImageList All where
  applyOptionalParam req (All xs) =
    req `setQuery` toQuery ("all", Just xs)

-- | /Optional Param/ "filters" - A JSON encoded value of the filters (a `map[string][]string`) to process on the images list.  Available filters: - `dangling=true` - `label=key` or `label=\"key=value\"` of an image label - `before`=(`<image-name>[:<tag>]`,  `<image id>` or `<image@digest>`) - `since`=(`<image-name>[:<tag>]`,  `<image id>` or `<image@digest>`) - `reference`=(`<image-name>[:<tag>]`)
instance HasOptionalParam ImageList Filters where
  applyOptionalParam req (Filters xs) =
    req `setQuery` toQuery ("filters", Just xs)

-- | /Optional Param/ "digests" - Show digest information as a `RepoDigests` field on each image.
instance HasOptionalParam ImageList Digests where
  applyOptionalParam req (Digests xs) =
    req `setQuery` toQuery ("digests", Just xs)

-- | @application/json@
instance Consumes ImageList MimeJSON
-- | @text/plain@
instance Consumes ImageList MimePlainText

-- | @application/json@
instance Produces ImageList MimeJSON


-- *** imageLoad

-- | @POST \/images\/load@
--
-- Import images
--
-- Load a set of images and tags into a repository.  For details on the format, see [the export image endpoint](#operation/ImageGet).
--
-- Note: Has 'Produces' instances, but no response schema
--
imageLoad
  :: (Consumes ImageLoad contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> DockerEngineRequest ImageLoad contentType res accept
imageLoad _  _ =
  _mkRequest "POST" ["/images/load"]

data ImageLoad

-- | /Body Param/ "imagesTarball" - Tar archive containing images
instance HasBodyParam ImageLoad ImagesTarball2

-- | /Optional Param/ "quiet" - Suppress progress details during load.
instance HasOptionalParam ImageLoad Quiet where
  applyOptionalParam req (Quiet xs) =
    req `setQuery` toQuery ("quiet", Just xs)

-- | @application/x-tar@
instance Consumes ImageLoad MimeXTar

-- | @application/json@
instance Produces ImageLoad MimeJSON


-- *** imagePrune

-- | @POST \/images\/prune@
--
-- Delete unused images
--
imagePrune
  :: Accept accept -- ^ request accept ('MimeType')
  -> DockerEngineRequest ImagePrune MimeNoContent InlineResponse2008 accept
imagePrune  _ =
  _mkRequest "POST" ["/images/prune"]

data ImagePrune

-- | /Optional Param/ "filters" - Filters to process on the prune list, encoded as JSON (a `map[string][]string`).  Available filters: - `dangling=<boolean>` When set to `true` (or `1`), prune only    unused *and* untagged images. When set to `false`    (or `0`), all unused images are pruned.
instance HasOptionalParam ImagePrune Filters where
  applyOptionalParam req (Filters xs) =
    req `setQuery` toQuery ("filters", Just xs)

-- | @application/json@
instance Consumes ImagePrune MimeJSON
-- | @text/plain@
instance Consumes ImagePrune MimePlainText

-- | @application/json@
instance Produces ImagePrune MimeJSON


-- *** imagePush

-- | @POST \/images\/{name}\/push@
--
-- Push an image
--
-- Push an image to a registry.  If you wish to push an image on to a private registry, that image must already have a tag which references the registry. For example, `registry.example.com/myimage:latest`.  The push is cancelled if the HTTP connection is closed.
--
-- Note: Has 'Produces' instances, but no response schema
--
imagePush
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  Image name or ID.
  -> XRegistryAuth -- ^ "xRegistryAuth" -  A base64-encoded auth configuration. [See the authentication section for details.](#section/Authentication)
  -> DockerEngineRequest ImagePush MimeNoContent res accept
imagePush  _ (Name name) (XRegistryAuth xRegistryAuth) =
  _mkRequest "POST" ["/images/",toPath name,"/push"]
    `setHeader` toHeader ("X-Registry-Auth", xRegistryAuth)

data ImagePush

-- | /Optional Param/ "tag" - The tag to associate with the image on the registry.
instance HasOptionalParam ImagePush Tag where
  applyOptionalParam req (Tag xs) =
    req `setQuery` toQuery ("tag", Just xs)

-- | @application/octet-stream@
instance Consumes ImagePush MimeOctetStream

-- | @application/json@
instance Produces ImagePush MimeJSON
-- | @text/plain@
instance Produces ImagePush MimePlainText


-- *** imageSearch

-- | @GET \/images\/search@
--
-- Search images
--
-- Search for an image on Docker Hub.
--
imageSearch
  :: Accept accept -- ^ request accept ('MimeType')
  -> Term -- ^ "term" -  Term to search
  -> DockerEngineRequest ImageSearch MimeNoContent [InlineResponse2007] accept
imageSearch  _ (Term term) =
  _mkRequest "GET" ["/images/search"]
    `setQuery` toQuery ("term", Just term)

data ImageSearch

-- | /Optional Param/ "limit" - Maximum number of results to return
instance HasOptionalParam ImageSearch Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "filters" - A JSON encoded value of the filters (a `map[string][]string`) to process on the images list. Available filters:  - `stars=<number>` - `is-automated=(true|false)` - `is-official=(true|false)`
instance HasOptionalParam ImageSearch Filters where
  applyOptionalParam req (Filters xs) =
    req `setQuery` toQuery ("filters", Just xs)

-- | @application/json@
instance Consumes ImageSearch MimeJSON
-- | @text/plain@
instance Consumes ImageSearch MimePlainText

-- | @application/json@
instance Produces ImageSearch MimeJSON


-- *** imageTag

-- | @POST \/images\/{name}\/tag@
--
-- Tag an image
--
-- Tag an image so that it becomes part of a repository.
--
-- Note: Has 'Produces' instances, but no response schema
--
imageTag
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  Image name or ID to tag.
  -> DockerEngineRequest ImageTag MimeNoContent res accept
imageTag  _ (Name name) =
  _mkRequest "POST" ["/images/",toPath name,"/tag"]

data ImageTag

-- | /Optional Param/ "repo" - The repository to tag in. For example, `someuser/someimage`.
instance HasOptionalParam ImageTag Repo where
  applyOptionalParam req (Repo xs) =
    req `setQuery` toQuery ("repo", Just xs)

-- | /Optional Param/ "tag" - The name of the new tag.
instance HasOptionalParam ImageTag Tag where
  applyOptionalParam req (Tag xs) =
    req `setQuery` toQuery ("tag", Just xs)

-- | @application/json@
instance Consumes ImageTag MimeJSON
-- | @text/plain@
instance Consumes ImageTag MimePlainText

-- | @application/json@
instance Produces ImageTag MimeJSON
-- | @text/plain@
instance Produces ImageTag MimePlainText


-- ** Network

-- *** networkConnect

-- | @POST \/networks\/{id}\/connect@
--
-- Connect a container to a network
--
-- Note: Has 'Produces' instances, but no response schema
--
networkConnect
  :: (Consumes NetworkConnect contentType, MimeRender contentType Container)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  Network ID or name
  -> Container -- ^ "container"
  -> DockerEngineRequest NetworkConnect contentType res accept
networkConnect _  _ (Id id) container =
  _mkRequest "POST" ["/networks/",toPath id,"/connect"]
    `setBodyParam` container

data NetworkConnect
instance HasBodyParam NetworkConnect Container

-- | @application/octet-stream@
instance Consumes NetworkConnect MimeOctetStream

-- | @application/json@
instance Produces NetworkConnect MimeJSON
-- | @text/plain@
instance Produces NetworkConnect MimePlainText


-- *** networkCreate

-- | @POST \/networks\/create@
--
-- Create a network
--
networkCreate
  :: (Consumes NetworkCreate contentType, MimeRender contentType NetworkConfig2)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> NetworkConfig2 -- ^ "networkConfig" -  Network configuration
  -> DockerEngineRequest NetworkCreate contentType InlineResponse2011 accept
networkCreate _  _ networkConfig =
  _mkRequest "POST" ["/networks/create"]
    `setBodyParam` networkConfig

data NetworkCreate

-- | /Body Param/ "networkConfig" - Network configuration
instance HasBodyParam NetworkCreate NetworkConfig2

-- | @application/json@
instance Consumes NetworkCreate MimeJSON

-- | @application/json@
instance Produces NetworkCreate MimeJSON


-- *** networkDelete

-- | @DELETE \/networks\/{id}@
--
-- Remove a network
--
-- Note: Has 'Produces' instances, but no response schema
--
networkDelete
  :: Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  Network ID or name
  -> DockerEngineRequest NetworkDelete MimeNoContent res accept
networkDelete  _ (Id id) =
  _mkRequest "DELETE" ["/networks/",toPath id]

data NetworkDelete

-- | @application/json@
instance Consumes NetworkDelete MimeJSON
-- | @text/plain@
instance Consumes NetworkDelete MimePlainText

-- | @application/json@
instance Produces NetworkDelete MimeJSON
-- | @text/plain@
instance Produces NetworkDelete MimePlainText


-- *** networkDisconnect

-- | @POST \/networks\/{id}\/disconnect@
--
-- Disconnect a container from a network
--
-- Note: Has 'Produces' instances, but no response schema
--
networkDisconnect
  :: (Consumes NetworkDisconnect contentType, MimeRender contentType Container1)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  Network ID or name
  -> Container1 -- ^ "container"
  -> DockerEngineRequest NetworkDisconnect contentType res accept
networkDisconnect _  _ (Id id) container =
  _mkRequest "POST" ["/networks/",toPath id,"/disconnect"]
    `setBodyParam` container

data NetworkDisconnect
instance HasBodyParam NetworkDisconnect Container1

-- | @application/json@
instance Consumes NetworkDisconnect MimeJSON

-- | @application/json@
instance Produces NetworkDisconnect MimeJSON
-- | @text/plain@
instance Produces NetworkDisconnect MimePlainText


-- *** networkInspect

-- | @GET \/networks\/{id}@
--
-- Inspect a network
--
networkInspect
  :: Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  Network ID or name
  -> DockerEngineRequest NetworkInspect MimeNoContent Network accept
networkInspect  _ (Id id) =
  _mkRequest "GET" ["/networks/",toPath id]

data NetworkInspect

-- | @application/json@
instance Consumes NetworkInspect MimeJSON
-- | @text/plain@
instance Consumes NetworkInspect MimePlainText

-- | @application/json@
instance Produces NetworkInspect MimeJSON


-- *** networkList

-- | @GET \/networks@
--
-- List networks
--
networkList
  :: Accept accept -- ^ request accept ('MimeType')
  -> DockerEngineRequest NetworkList MimeNoContent [Network] accept
networkList  _ =
  _mkRequest "GET" ["/networks"]

data NetworkList

-- | /Optional Param/ "filters" - JSON encoded value of the filters (a `map[string][]string`) to process on the networks list. Available filters:  - `driver=<driver-name>` Matches a network's driver. - `id=<network-id>` Matches all or part of a network ID. - `label=<key>` or `label=<key>=<value>` of a network label. - `name=<network-name>` Matches all or part of a network name. - `type=[\"custom\"|\"builtin\"]` Filters networks by type. The `custom` keyword returns all user-defined networks.
instance HasOptionalParam NetworkList Filters where
  applyOptionalParam req (Filters xs) =
    req `setQuery` toQuery ("filters", Just xs)

-- | @application/json@
instance Consumes NetworkList MimeJSON
-- | @text/plain@
instance Consumes NetworkList MimePlainText

-- | @application/json@
instance Produces NetworkList MimeJSON


-- *** networkPrune

-- | @POST \/networks\/prune@
--
-- Delete unused networks
--
networkPrune
  :: Accept accept -- ^ request accept ('MimeType')
  -> DockerEngineRequest NetworkPrune MimeNoContent InlineResponse20017 accept
networkPrune  _ =
  _mkRequest "POST" ["/networks/prune"]

data NetworkPrune

-- | /Optional Param/ "filters" - Filters to process on the prune list, encoded as JSON (a `map[string][]string`).  Available filters:
instance HasOptionalParam NetworkPrune Filters where
  applyOptionalParam req (Filters xs) =
    req `setQuery` toQuery ("filters", Just xs)

-- | @application/json@
instance Consumes NetworkPrune MimeJSON

-- | @application/json@
instance Produces NetworkPrune MimeJSON


-- ** Node

-- *** nodeDelete

-- | @DELETE \/nodes\/{id}@
--
-- Delete a node
--
-- Note: Has 'Produces' instances, but no response schema
--
nodeDelete
  :: Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  The ID or name of the node
  -> DockerEngineRequest NodeDelete MimeNoContent res accept
nodeDelete  _ (Id id) =
  _mkRequest "DELETE" ["/nodes/",toPath id]

data NodeDelete

-- | /Optional Param/ "force" - Force remove a node from the swarm
instance HasOptionalParam NodeDelete Force where
  applyOptionalParam req (Force xs) =
    req `setQuery` toQuery ("force", Just xs)

-- | @application/json@
instance Consumes NodeDelete MimeJSON
-- | @text/plain@
instance Consumes NodeDelete MimePlainText

-- | @application/json@
instance Produces NodeDelete MimeJSON
-- | @text/plain@
instance Produces NodeDelete MimePlainText


-- *** nodeInspect

-- | @GET \/nodes\/{id}@
--
-- Inspect a node
--
nodeInspect
  :: Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  The ID or name of the node
  -> DockerEngineRequest NodeInspect MimeNoContent Node accept
nodeInspect  _ (Id id) =
  _mkRequest "GET" ["/nodes/",toPath id]

data NodeInspect

-- | @application/json@
instance Consumes NodeInspect MimeJSON
-- | @text/plain@
instance Consumes NodeInspect MimePlainText

-- | @application/json@
instance Produces NodeInspect MimeJSON
-- | @text/plain@
instance Produces NodeInspect MimePlainText


-- *** nodeList

-- | @GET \/nodes@
--
-- List nodes
--
nodeList
  :: Accept accept -- ^ request accept ('MimeType')
  -> DockerEngineRequest NodeList MimeNoContent [Node] accept
nodeList  _ =
  _mkRequest "GET" ["/nodes"]

data NodeList

-- | /Optional Param/ "filters" - Filters to process on the nodes list, encoded as JSON (a `map[string][]string`).  Available filters: - `id=<node id>` - `label=<engine label>` - `membership=`(`accepted`|`pending`)` - `name=<node name>` - `role=`(`manager`|`worker`)`
instance HasOptionalParam NodeList Filters where
  applyOptionalParam req (Filters xs) =
    req `setQuery` toQuery ("filters", Just xs)

-- | @application/json@
instance Consumes NodeList MimeJSON
-- | @text/plain@
instance Consumes NodeList MimePlainText

-- | @application/json@
instance Produces NodeList MimeJSON
-- | @text/plain@
instance Produces NodeList MimePlainText


-- *** nodeUpdate

-- | @POST \/nodes\/{id}\/update@
--
-- Update a node
--
-- Note: Has 'Produces' instances, but no response schema
--
nodeUpdate
  :: (Consumes NodeUpdate contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  The ID of the node
  -> Version -- ^ "version" -  The version number of the node object being updated. This is required to avoid conflicting writes.
  -> DockerEngineRequest NodeUpdate contentType res accept
nodeUpdate _  _ (Id id) (Version version) =
  _mkRequest "POST" ["/nodes/",toPath id,"/update"]
    `setQuery` toQuery ("version", Just version)

data NodeUpdate
instance HasBodyParam NodeUpdate NodeSpec

-- | @application/json@
instance Consumes NodeUpdate MimeJSON
-- | @text/plain@
instance Consumes NodeUpdate MimePlainText

-- | @application/json@
instance Produces NodeUpdate MimeJSON
-- | @text/plain@
instance Produces NodeUpdate MimePlainText


-- ** Plugin

-- *** getPluginPrivileges

-- | @GET \/plugins\/privileges@
--
-- Get plugin privileges
--
getPluginPrivileges
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  The name of the plugin. The `:latest` tag is optional, and is the default if omitted.
  -> DockerEngineRequest GetPluginPrivileges MimeNoContent [InlineResponse20018] accept
getPluginPrivileges  _ (Name name) =
  _mkRequest "GET" ["/plugins/privileges"]
    `setQuery` toQuery ("name", Just name)

data GetPluginPrivileges

-- | @application/json@
instance Consumes GetPluginPrivileges MimeJSON
-- | @text/plain@
instance Consumes GetPluginPrivileges MimePlainText

-- | @application/json@
instance Produces GetPluginPrivileges MimeJSON
-- | @text/plain@
instance Produces GetPluginPrivileges MimePlainText


-- *** pluginCreate

-- | @POST \/plugins\/create@
--
-- Create a plugin
--
-- Note: Has 'Produces' instances, but no response schema
--
pluginCreate
  :: (Consumes PluginCreate contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  The name of the plugin. The `:latest` tag is optional, and is the default if omitted.
  -> DockerEngineRequest PluginCreate contentType res accept
pluginCreate _  _ (Name name) =
  _mkRequest "POST" ["/plugins/create"]
    `setQuery` toQuery ("name", Just name)

data PluginCreate

-- | /Body Param/ "tarContext" - Path to tar containing plugin rootfs and manifest
instance HasBodyParam PluginCreate TarContext2

-- | @application/x-tar@
instance Consumes PluginCreate MimeXTar

-- | @application/json@
instance Produces PluginCreate MimeJSON
-- | @text/plain@
instance Produces PluginCreate MimePlainText


-- *** pluginDelete

-- | @DELETE \/plugins\/{name}@
--
-- Remove a plugin
--
pluginDelete
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  The name of the plugin. The `:latest` tag is optional, and is the default if omitted.
  -> DockerEngineRequest PluginDelete MimeNoContent Plugin accept
pluginDelete  _ (Name name) =
  _mkRequest "DELETE" ["/plugins/",toPath name]

data PluginDelete

-- | /Optional Param/ "force" - Disable the plugin before removing. This may result in issues if the plugin is in use by a container.
instance HasOptionalParam PluginDelete Force where
  applyOptionalParam req (Force xs) =
    req `setQuery` toQuery ("force", Just xs)

-- | @application/json@
instance Consumes PluginDelete MimeJSON
-- | @text/plain@
instance Consumes PluginDelete MimePlainText

-- | @application/json@
instance Produces PluginDelete MimeJSON
-- | @text/plain@
instance Produces PluginDelete MimePlainText


-- *** pluginDisable

-- | @POST \/plugins\/{name}\/disable@
--
-- Disable a plugin
--
-- Note: Has 'Produces' instances, but no response schema
--
pluginDisable
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  The name of the plugin. The `:latest` tag is optional, and is the default if omitted.
  -> DockerEngineRequest PluginDisable MimeNoContent res accept
pluginDisable  _ (Name name) =
  _mkRequest "POST" ["/plugins/",toPath name,"/disable"]

data PluginDisable

-- | @application/json@
instance Consumes PluginDisable MimeJSON
-- | @text/plain@
instance Consumes PluginDisable MimePlainText

-- | @application/json@
instance Produces PluginDisable MimeJSON
-- | @text/plain@
instance Produces PluginDisable MimePlainText


-- *** pluginEnable

-- | @POST \/plugins\/{name}\/enable@
--
-- Enable a plugin
--
-- Note: Has 'Produces' instances, but no response schema
--
pluginEnable
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  The name of the plugin. The `:latest` tag is optional, and is the default if omitted.
  -> DockerEngineRequest PluginEnable MimeNoContent res accept
pluginEnable  _ (Name name) =
  _mkRequest "POST" ["/plugins/",toPath name,"/enable"]

data PluginEnable

-- | /Optional Param/ "timeout" - Set the HTTP client timeout (in seconds)
instance HasOptionalParam PluginEnable Timeout where
  applyOptionalParam req (Timeout xs) =
    req `setQuery` toQuery ("timeout", Just xs)

-- | @application/json@
instance Consumes PluginEnable MimeJSON
-- | @text/plain@
instance Consumes PluginEnable MimePlainText

-- | @application/json@
instance Produces PluginEnable MimeJSON
-- | @text/plain@
instance Produces PluginEnable MimePlainText


-- *** pluginInspect

-- | @GET \/plugins\/{name}\/json@
--
-- Inspect a plugin
--
pluginInspect
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  The name of the plugin. The `:latest` tag is optional, and is the default if omitted.
  -> DockerEngineRequest PluginInspect MimeNoContent Plugin accept
pluginInspect  _ (Name name) =
  _mkRequest "GET" ["/plugins/",toPath name,"/json"]

data PluginInspect

-- | @application/json@
instance Consumes PluginInspect MimeJSON
-- | @text/plain@
instance Consumes PluginInspect MimePlainText

-- | @application/json@
instance Produces PluginInspect MimeJSON
-- | @text/plain@
instance Produces PluginInspect MimePlainText


-- *** pluginList

-- | @GET \/plugins@
--
-- List plugins
--
-- Returns information about installed plugins.
--
pluginList
  :: Accept accept -- ^ request accept ('MimeType')
  -> DockerEngineRequest PluginList MimeNoContent [Plugin] accept
pluginList  _ =
  _mkRequest "GET" ["/plugins"]

data PluginList

-- | @application/json@
instance Consumes PluginList MimeJSON
-- | @text/plain@
instance Consumes PluginList MimePlainText

-- | @application/json@
instance Produces PluginList MimeJSON


-- *** pluginPull

-- | @POST \/plugins\/pull@
--
-- Install a plugin
--
-- Pulls and installs a plugin. After the plugin is installed, it can be enabled using the [`POST /plugins/{name}/enable` endpoint](#operation/PostPluginsEnable).
--
-- Note: Has 'Produces' instances, but no response schema
--
pluginPull
  :: (Consumes PluginPull contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Remote -- ^ "remote" -  Remote reference for plugin to install.  The `:latest` tag is optional, and is used as the default if omitted.
  -> DockerEngineRequest PluginPull contentType res accept
pluginPull _  _ (Remote remote) =
  _mkRequest "POST" ["/plugins/pull"]
    `setQuery` toQuery ("remote", Just remote)

data PluginPull
instance HasBodyParam PluginPull Body4

-- | /Optional Param/ "name" - Local name for the pulled plugin.  The `:latest` tag is optional, and is used as the default if omitted.
instance HasOptionalParam PluginPull Name where
  applyOptionalParam req (Name xs) =
    req `setQuery` toQuery ("name", Just xs)

-- | /Optional Param/ "X-Registry-Auth" - A base64-encoded auth configuration to use when pulling a plugin from a registry. [See the authentication section for details.](#section/Authentication)
instance HasOptionalParam PluginPull XRegistryAuth where
  applyOptionalParam req (XRegistryAuth xs) =
    req `setHeader` toHeader ("X-Registry-Auth", xs)

-- | @application/json@
instance Consumes PluginPull MimeJSON
-- | @text/plain@
instance Consumes PluginPull MimePlainText

-- | @application/json@
instance Produces PluginPull MimeJSON


-- *** pluginPush

-- | @POST \/plugins\/{name}\/push@
--
-- Push a plugin
--
-- Push a plugin to the registry.
--
-- Note: Has 'Produces' instances, but no response schema
--
pluginPush
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  The name of the plugin. The `:latest` tag is optional, and is the default if omitted.
  -> DockerEngineRequest PluginPush MimeNoContent res accept
pluginPush  _ (Name name) =
  _mkRequest "POST" ["/plugins/",toPath name,"/push"]

data PluginPush

-- | @application/json@
instance Consumes PluginPush MimeJSON
-- | @text/plain@
instance Consumes PluginPush MimePlainText

-- | @application/json@
instance Produces PluginPush MimeJSON
-- | @text/plain@
instance Produces PluginPush MimePlainText


-- *** pluginSet

-- | @POST \/plugins\/{name}\/set@
--
-- Configure a plugin
--
-- Note: Has 'Produces' instances, but no response schema
--
pluginSet
  :: (Consumes PluginSet contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  The name of the plugin. The `:latest` tag is optional, and is the default if omitted.
  -> DockerEngineRequest PluginSet contentType res accept
pluginSet _  _ (Name name) =
  _mkRequest "POST" ["/plugins/",toPath name,"/set"]

data PluginSet
instance HasBodyParam PluginSet Body5

-- | @application/json@
instance Consumes PluginSet MimeJSON

-- | @application/json@
instance Produces PluginSet MimeJSON
-- | @text/plain@
instance Produces PluginSet MimePlainText


-- ** Secret

-- *** secretCreate

-- | @POST \/secrets\/create@
--
-- Create a secret
--
secretCreate
  :: (Consumes SecretCreate contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> DockerEngineRequest SecretCreate contentType InlineResponse2013 accept
secretCreate _  _ =
  _mkRequest "POST" ["/secrets/create"]

data SecretCreate
instance HasBodyParam SecretCreate

-- | @application/json@
instance Consumes SecretCreate MimeJSON

-- | @application/json@
instance Produces SecretCreate MimeJSON


-- *** secretDelete

-- | @DELETE \/secrets\/{id}@
--
-- Delete a secret
--
-- Note: Has 'Produces' instances, but no response schema
--
secretDelete
  :: Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  ID of the secret
  -> DockerEngineRequest SecretDelete MimeNoContent res accept
secretDelete  _ (Id id) =
  _mkRequest "DELETE" ["/secrets/",toPath id]

data SecretDelete

-- | @application/json@
instance Consumes SecretDelete MimeJSON
-- | @text/plain@
instance Consumes SecretDelete MimePlainText

-- | @application/json@
instance Produces SecretDelete MimeJSON


-- *** secretInspect

-- | @GET \/secrets\/{id}@
--
-- Inspect a secret
--
secretInspect
  :: Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  ID of the secret
  -> DockerEngineRequest SecretInspect MimeNoContent Secret accept
secretInspect  _ (Id id) =
  _mkRequest "GET" ["/secrets/",toPath id]

data SecretInspect

-- | @application/json@
instance Consumes SecretInspect MimeJSON
-- | @text/plain@
instance Consumes SecretInspect MimePlainText

-- | @application/json@
instance Produces SecretInspect MimeJSON


-- *** secretList

-- | @GET \/secrets@
--
-- List secrets
--
secretList
  :: Accept accept -- ^ request accept ('MimeType')
  -> DockerEngineRequest SecretList MimeNoContent [Secret] accept
secretList  _ =
  _mkRequest "GET" ["/secrets"]

data SecretList

-- | /Optional Param/ "filters" - A JSON encoded value of the filters (a `map[string][]string`) to process on the secrets list. Available filters:  - `names=<secret name>`
instance HasOptionalParam SecretList Filters where
  applyOptionalParam req (Filters xs) =
    req `setQuery` toQuery ("filters", Just xs)

-- | @application/json@
instance Consumes SecretList MimeJSON
-- | @text/plain@
instance Consumes SecretList MimePlainText

-- | @application/json@
instance Produces SecretList MimeJSON


-- ** Service

-- *** serviceCreate

-- | @POST \/services\/create@
--
-- Create a service
--
serviceCreate
  :: (Consumes ServiceCreate contentType, MimeRender contentType )
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> body -- ^ "body"
  -> DockerEngineRequest ServiceCreate contentType InlineResponse2012 accept
serviceCreate _  _ body =
  _mkRequest "POST" ["/services/create"]
    `setBodyParam` body

data ServiceCreate
instance HasBodyParam ServiceCreate

-- | /Optional Param/ "X-Registry-Auth" - A base64-encoded auth configuration for pulling from private registries. [See the authentication section for details.](#section/Authentication)
instance HasOptionalParam ServiceCreate XRegistryAuth where
  applyOptionalParam req (XRegistryAuth xs) =
    req `setHeader` toHeader ("X-Registry-Auth", xs)

-- | @application/json@
instance Consumes ServiceCreate MimeJSON

-- | @application/json@
instance Produces ServiceCreate MimeJSON


-- *** serviceDelete

-- | @DELETE \/services\/{id}@
--
-- Delete a service
--
-- Note: Has 'Produces' instances, but no response schema
--
serviceDelete
  :: Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  ID or name of service.
  -> DockerEngineRequest ServiceDelete MimeNoContent res accept
serviceDelete  _ (Id id) =
  _mkRequest "DELETE" ["/services/",toPath id]

data ServiceDelete

-- | @application/json@
instance Consumes ServiceDelete MimeJSON
-- | @text/plain@
instance Consumes ServiceDelete MimePlainText

-- | @application/json@
instance Produces ServiceDelete MimeJSON
-- | @text/plain@
instance Produces ServiceDelete MimePlainText


-- *** serviceInspect

-- | @GET \/services\/{id}@
--
-- Inspect a service
--
serviceInspect
  :: Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  ID or name of service.
  -> DockerEngineRequest ServiceInspect MimeNoContent Service accept
serviceInspect  _ (Id id) =
  _mkRequest "GET" ["/services/",toPath id]

data ServiceInspect

-- | @application/json@
instance Consumes ServiceInspect MimeJSON
-- | @text/plain@
instance Consumes ServiceInspect MimePlainText

-- | @application/json@
instance Produces ServiceInspect MimeJSON
-- | @text/plain@
instance Produces ServiceInspect MimePlainText


-- *** serviceList

-- | @GET \/services@
--
-- List services
--
serviceList
  :: Accept accept -- ^ request accept ('MimeType')
  -> DockerEngineRequest ServiceList MimeNoContent [Service] accept
serviceList  _ =
  _mkRequest "GET" ["/services"]

data ServiceList

-- | /Optional Param/ "filters" - A JSON encoded value of the filters (a `map[string][]string`) to process on the services list. Available filters:  - `id=<service id>` - `name=<service name>` - `label=<service label>`
instance HasOptionalParam ServiceList Filters where
  applyOptionalParam req (Filters xs) =
    req `setQuery` toQuery ("filters", Just xs)

-- | @application/json@
instance Consumes ServiceList MimeJSON
-- | @text/plain@
instance Consumes ServiceList MimePlainText

-- | @application/json@
instance Produces ServiceList MimeJSON
-- | @text/plain@
instance Produces ServiceList MimePlainText


-- *** serviceLogs

-- | @GET \/services\/{id}\/logs@
--
-- Get service logs
--
-- Get `stdout` and `stderr` logs from a service.  **Note**: This endpoint works only for services with the `json-file` or `journald` logging drivers.
--
serviceLogs
  :: Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  ID or name of the container
  -> DockerEngineRequest ServiceLogs MimeNoContent Text accept
serviceLogs  _ (Id id) =
  _mkRequest "GET" ["/services/",toPath id,"/logs"]

data ServiceLogs

-- | /Optional Param/ "details" - Show extra details provided to logs.
instance HasOptionalParam ServiceLogs Details where
  applyOptionalParam req (Details xs) =
    req `setQuery` toQuery ("details", Just xs)

-- | /Optional Param/ "follow" - Return the logs as a stream.  This will return a `101` HTTP response with a `Connection: upgrade` header, then hijack the HTTP connection to send raw output. For more information about hijacking and the stream format, [see the documentation for the attach endpoint](#operation/ContainerAttach).
instance HasOptionalParam ServiceLogs Follow where
  applyOptionalParam req (Follow xs) =
    req `setQuery` toQuery ("follow", Just xs)

-- | /Optional Param/ "stdout" - Return logs from `stdout`
instance HasOptionalParam ServiceLogs Stdout where
  applyOptionalParam req (Stdout xs) =
    req `setQuery` toQuery ("stdout", Just xs)

-- | /Optional Param/ "stderr" - Return logs from `stderr`
instance HasOptionalParam ServiceLogs Stderr where
  applyOptionalParam req (Stderr xs) =
    req `setQuery` toQuery ("stderr", Just xs)

-- | /Optional Param/ "since" - Only return logs since this time, as a UNIX timestamp
instance HasOptionalParam ServiceLogs Since where
  applyOptionalParam req (Since xs) =
    req `setQuery` toQuery ("since", Just xs)

-- | /Optional Param/ "timestamps" - Add timestamps to every log line
instance HasOptionalParam ServiceLogs Timestamps where
  applyOptionalParam req (Timestamps xs) =
    req `setQuery` toQuery ("timestamps", Just xs)

-- | /Optional Param/ "tail" - Only return this number of log lines from the end of the logs. Specify as an integer or `all` to output all log lines.
instance HasOptionalParam ServiceLogs Tail where
  applyOptionalParam req (Tail xs) =
    req `setQuery` toQuery ("tail", Just xs)

-- | @application/json@
instance Consumes ServiceLogs MimeJSON
-- | @text/plain@
instance Consumes ServiceLogs MimePlainText

-- | @application/vnd.docker.raw-stream@
instance Produces ServiceLogs MimeVndDockerRawStream
-- | @application/json@
instance Produces ServiceLogs MimeJSON


-- *** serviceUpdate

-- | @POST \/services\/{id}\/update@
--
-- Update a service
--
serviceUpdate
  :: (Consumes ServiceUpdate contentType, MimeRender contentType )
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  ID or name of service.
  -> body  -- ^ "body"
  -> VersionInt -- ^ "version" -  The version number of the service object being updated. This is required to avoid conflicting writes.
  -> DockerEngineRequest ServiceUpdate contentType ImageDeleteResponse accept
serviceUpdate _  _ (Id id) body (VersionInt version) =
  _mkRequest "POST" ["/services/",toPath id,"/update"]
    `setBodyParam` body
    `setQuery` toQuery ("version", Just version)

data ServiceUpdate
instance HasBodyParam ServiceUpdate

-- | /Optional Param/ "registryAuthFrom" - If the X-Registry-Auth header is not specified, this parameter indicates where to find registry authorization credentials. The valid values are `spec` and `previous-spec`.
instance HasOptionalParam ServiceUpdate RegistryAuthFrom where
  applyOptionalParam req (RegistryAuthFrom xs) =
    req `setQuery` toQuery ("registryAuthFrom", Just xs)

-- | /Optional Param/ "X-Registry-Auth" - A base64-encoded auth configuration for pulling from private registries. [See the authentication section for details.](#section/Authentication)
instance HasOptionalParam ServiceUpdate XRegistryAuth where
  applyOptionalParam req (XRegistryAuth xs) =
    req `setHeader` toHeader ("X-Registry-Auth", xs)

-- | @application/json@
instance Consumes ServiceUpdate MimeJSON

-- | @application/json@
instance Produces ServiceUpdate MimeJSON


-- ** Swarm

-- *** swarmInit

-- | @POST \/swarm\/init@
--
-- Initialize a new swarm
--
swarmInit
  :: (Consumes SwarmInit contentType, MimeRender contentType Body1)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Body1 -- ^ "body"
  -> DockerEngineRequest SwarmInit contentType Text accept
swarmInit _  _ body =
  _mkRequest "POST" ["/swarm/init"]
    `setBodyParam` body

data SwarmInit
instance HasBodyParam SwarmInit Body1

-- | @application/json@
instance Consumes SwarmInit MimeJSON
-- | @text/plain@
instance Consumes SwarmInit MimePlainText

-- | @application/json@
instance Produces SwarmInit MimeJSON
-- | @text/plain@
instance Produces SwarmInit MimePlainText


-- *** swarmInspect

-- | @GET \/swarm@
--
-- Inspect swarm
--
-- Note: Has 'Produces' instances, but no response schema
--
swarmInspect
  :: Accept accept -- ^ request accept ('MimeType')
  -> DockerEngineRequest SwarmInspect MimeNoContent res accept
swarmInspect  _ =
  _mkRequest "GET" ["/swarm"]

data SwarmInspect

-- | @application/json@
instance Consumes SwarmInspect MimeJSON
-- | @text/plain@
instance Consumes SwarmInspect MimePlainText

-- | @application/json@
instance Produces SwarmInspect MimeJSON
-- | @text/plain@
instance Produces SwarmInspect MimePlainText


-- *** swarmJoin

-- | @POST \/swarm\/join@
--
-- Join an existing swarm
--
-- Note: Has 'Produces' instances, but no response schema
--
swarmJoin
  :: (Consumes SwarmJoin contentType, MimeRender contentType Body2)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Body2 -- ^ "body"
  -> DockerEngineRequest SwarmJoin contentType res accept
swarmJoin _  _ body =
  _mkRequest "POST" ["/swarm/join"]
    `setBodyParam` body

data SwarmJoin
instance HasBodyParam SwarmJoin Body2

-- | @application/json@
instance Consumes SwarmJoin MimeJSON
-- | @text/plain@
instance Consumes SwarmJoin MimePlainText

-- | @application/json@
instance Produces SwarmJoin MimeJSON
-- | @text/plain@
instance Produces SwarmJoin MimePlainText


-- *** swarmLeave

-- | @POST \/swarm\/leave@
--
-- Leave a swarm
--
-- Note: Has 'Produces' instances, but no response schema
--
swarmLeave
  :: Accept accept -- ^ request accept ('MimeType')
  -> DockerEngineRequest SwarmLeave MimeNoContent res accept
swarmLeave  _ =
  _mkRequest "POST" ["/swarm/leave"]

data SwarmLeave

-- | /Optional Param/ "force" - Force leave swarm, even if this is the last manager or that it will break the cluster.
instance HasOptionalParam SwarmLeave Force where
  applyOptionalParam req (Force xs) =
    req `setQuery` toQuery ("force", Just xs)

-- | @application/json@
instance Consumes SwarmLeave MimeJSON
-- | @text/plain@
instance Consumes SwarmLeave MimePlainText

-- | @application/json@
instance Produces SwarmLeave MimeJSON
-- | @text/plain@
instance Produces SwarmLeave MimePlainText


-- *** swarmUnlock

-- | @POST \/swarm\/unlock@
--
-- Unlock a locked manager
--
-- Note: Has 'Produces' instances, but no response schema
--
swarmUnlock
  :: (Consumes SwarmUnlock contentType, MimeRender contentType Body3)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Body3 -- ^ "body"
  -> DockerEngineRequest SwarmUnlock contentType res accept
swarmUnlock _  _ body =
  _mkRequest "POST" ["/swarm/unlock"]
    `setBodyParam` body

data SwarmUnlock
instance HasBodyParam SwarmUnlock Body3

-- | @application/json@
instance Consumes SwarmUnlock MimeJSON

-- | @application/json@
instance Produces SwarmUnlock MimeJSON


-- *** swarmUnlockkey

-- | @GET \/swarm\/unlockkey@
--
-- Get the unlock key
--
swarmUnlockkey
  :: Accept accept -- ^ request accept ('MimeType')
  -> DockerEngineRequest SwarmUnlockkey MimeNoContent InlineResponse20019 accept
swarmUnlockkey  _ =
  _mkRequest "GET" ["/swarm/unlockkey"]

data SwarmUnlockkey

-- | @application/json@
instance Consumes SwarmUnlockkey MimeJSON

-- | @application/json@
instance Produces SwarmUnlockkey MimeJSON
-- | @text/plain@
instance Produces SwarmUnlockkey MimePlainText


-- *** swarmUpdate

-- | @POST \/swarm\/update@
--
-- Update a swarm
--
-- Note: Has 'Produces' instances, but no response schema
--
swarmUpdate
  :: (Consumes SwarmUpdate contentType, MimeRender contentType SwarmSpec)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> SwarmSpec -- ^ "body"
  -> Version -- ^ "version" -  The version number of the swarm object being updated. This is required to avoid conflicting writes.
  -> DockerEngineRequest SwarmUpdate contentType res accept
swarmUpdate _  _ body (Version version) =
  _mkRequest "POST" ["/swarm/update"]
    `setBodyParam` body
    `setQuery` toQuery ("version", Just version)

data SwarmUpdate
instance HasBodyParam SwarmUpdate SwarmSpec

-- | /Optional Param/ "rotateWorkerToken" - Rotate the worker join token.
instance HasOptionalParam SwarmUpdate RotateWorkerToken where
  applyOptionalParam req (RotateWorkerToken xs) =
    req `setQuery` toQuery ("rotateWorkerToken", Just xs)

-- | /Optional Param/ "rotateManagerToken" - Rotate the manager join token.
instance HasOptionalParam SwarmUpdate RotateManagerToken where
  applyOptionalParam req (RotateManagerToken xs) =
    req `setQuery` toQuery ("rotateManagerToken", Just xs)

-- | /Optional Param/ "rotateManagerUnlockKey" - Rotate the manager unlock key.
instance HasOptionalParam SwarmUpdate RotateManagerUnlockKey where
  applyOptionalParam req (RotateManagerUnlockKey xs) =
    req `setQuery` toQuery ("rotateManagerUnlockKey", Just xs)

-- | @application/json@
instance Consumes SwarmUpdate MimeJSON
-- | @text/plain@
instance Consumes SwarmUpdate MimePlainText

-- | @application/json@
instance Produces SwarmUpdate MimeJSON
-- | @text/plain@
instance Produces SwarmUpdate MimePlainText


-- ** System

-- *** systemAuth

-- | @POST \/auth@
--
-- Check auth configuration
--
-- Validate credentials for a registry and, if available, get an identity token for accessing the registry without password.
--
systemAuth
  :: (Consumes SystemAuth contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> DockerEngineRequest SystemAuth contentType InlineResponse2009 accept
systemAuth _  _ =
  _mkRequest "POST" ["/auth"]

data SystemAuth

-- | /Body Param/ "authConfig" - Authentication to check
instance HasBodyParam SystemAuth AuthConfig

-- | @application/json@
instance Consumes SystemAuth MimeJSON

-- | @application/json@
instance Produces SystemAuth MimeJSON


-- *** systemDataUsage

-- | @GET \/system\/df@
--
-- Get data usage information
--
systemDataUsage
  :: Accept accept -- ^ request accept ('MimeType')
  -> DockerEngineRequest SystemDataUsage MimeNoContent InlineResponse20013 accept
systemDataUsage  _ =
  _mkRequest "GET" ["/system/df"]

data SystemDataUsage

-- | @application/json@
instance Consumes SystemDataUsage MimeJSON
-- | @text/plain@
instance Consumes SystemDataUsage MimePlainText

-- | @application/json@
instance Produces SystemDataUsage MimeJSON
-- | @text/plain@
instance Produces SystemDataUsage MimePlainText


-- *** systemEvents

-- | @GET \/events@
--
-- Monitor events
--
-- Stream real-time events from the server.  Various objects within Docker report events when something happens to them.  Containers report these events: `attach, commit, copy, create, destroy, detach, die, exec_create, exec_detach, exec_start, export, kill, oom, pause, rename, resize, restart, start, stop, top, unpause, update`  Images report these events: `delete, import, load, pull, push, save, tag, untag`  Volumes report these events: `create, mount, unmount, destroy`  Networks report these events: `create, connect, disconnect, destroy`  The Docker daemon reports these events: `reload`
--
systemEvents
  :: Accept accept -- ^ request accept ('MimeType')
  -> DockerEngineRequest SystemEvents MimeNoContent InlineResponse20012 accept
systemEvents  _ =
  _mkRequest "GET" ["/events"]

data SystemEvents

-- | /Optional Param/ "since" - Show events created since this timestamp then stream new events.
instance HasOptionalParam SystemEvents SinceText where
  applyOptionalParam req (SinceText xs) =
    req `setQuery` toQuery ("since", Just xs)

-- | /Optional Param/ "until" - Show events created until this timestamp then stop streaming.
instance HasOptionalParam SystemEvents Until where
  applyOptionalParam req (Until xs) =
    req `setQuery` toQuery ("until", Just xs)

-- | /Optional Param/ "filters" - A JSON encoded value of filters (a `map[string][]string`) to process on the event list. Available filters:  - `container=<string>` container name or ID - `event=<string>` event type - `image=<string>` image name or ID - `label=<string>` image or container label - `type=<string>` object to filter by, one of `container`, `image`, `volume`, `network`, or `daemon` - `volume=<string>` volume name or ID - `network=<string>` network name or ID - `daemon=<string>` daemon name or ID
instance HasOptionalParam SystemEvents Filters where
  applyOptionalParam req (Filters xs) =
    req `setQuery` toQuery ("filters", Just xs)

-- | @application/json@
instance Consumes SystemEvents MimeJSON
-- | @text/plain@
instance Consumes SystemEvents MimePlainText

-- | @application/json@
instance Produces SystemEvents MimeJSON


-- *** systemInfo

-- | @GET \/info@
--
-- Get system information
--
systemInfo
  :: Accept accept -- ^ request accept ('MimeType')
  -> DockerEngineRequest SystemInfo MimeNoContent InlineResponse20010 accept
systemInfo  _ =
  _mkRequest "GET" ["/info"]

data SystemInfo

-- | @application/json@
instance Consumes SystemInfo MimeJSON
-- | @text/plain@
instance Consumes SystemInfo MimePlainText

-- | @application/json@
instance Produces SystemInfo MimeJSON


-- *** systemPing

-- | @GET \/_ping@
--
-- Ping
--
-- This is a dummy endpoint you can use to test if the server is accessible.
--
systemPing
  :: Accept accept -- ^ request accept ('MimeType')
  -> DockerEngineRequest SystemPing MimeNoContent Text accept
systemPing  _ =
  _mkRequest "GET" ["/_ping"]

data SystemPing

-- | @application/json@
instance Consumes SystemPing MimeJSON
-- | @text/plain@
instance Consumes SystemPing MimePlainText

-- | @text/plain@
instance Produces SystemPing MimePlainText


-- *** systemVersion

-- | @GET \/version@
--
-- Get version
--
-- Returns the version of Docker that is running and various information about the system that Docker is running on.
--
systemVersion
  :: Accept accept -- ^ request accept ('MimeType')
  -> DockerEngineRequest SystemVersion MimeNoContent InlineResponse20011 accept
systemVersion  _ =
  _mkRequest "GET" ["/version"]

data SystemVersion

-- | @application/json@
instance Consumes SystemVersion MimeJSON
-- | @text/plain@
instance Consumes SystemVersion MimePlainText

-- | @application/json@
instance Produces SystemVersion MimeJSON


-- ** Task

-- *** taskInspect

-- | @GET \/tasks\/{id}@
--
-- Inspect a task
--
taskInspect
  :: Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  ID of the task
  -> DockerEngineRequest TaskInspect MimeNoContent Task accept
taskInspect  _ (Id id) =
  _mkRequest "GET" ["/tasks/",toPath id]

data TaskInspect

-- | @application/json@
instance Consumes TaskInspect MimeJSON
-- | @text/plain@
instance Consumes TaskInspect MimePlainText

-- | @application/json@
instance Produces TaskInspect MimeJSON


-- *** taskList

-- | @GET \/tasks@
--
-- List tasks
--
taskList
  :: Accept accept -- ^ request accept ('MimeType')
  -> DockerEngineRequest TaskList MimeNoContent [Task] accept
taskList  _ =
  _mkRequest "GET" ["/tasks"]

data TaskList

-- | /Optional Param/ "filters" - A JSON encoded value of the filters (a `map[string][]string`) to process on the tasks list. Available filters:  - `id=<task id>` - `name=<task name>` - `service=<service name>` - `node=<node id or name>` - `label=key` or `label=\"key=value\"` - `desired-state=(running | shutdown | accepted)`
instance HasOptionalParam TaskList Filters where
  applyOptionalParam req (Filters xs) =
    req `setQuery` toQuery ("filters", Just xs)

-- | @application/json@
instance Consumes TaskList MimeJSON
-- | @text/plain@
instance Consumes TaskList MimePlainText

-- | @application/json@
instance Produces TaskList MimeJSON


-- ** Volume

-- *** volumeCreate

-- | @POST \/volumes\/create@
--
-- Create a volume
--
volumeCreate
  :: (Consumes VolumeCreate contentType, MimeRender contentType VolumeConfig)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> VolumeConfig -- ^ "volumeConfig" -  Volume configuration
  -> DockerEngineRequest VolumeCreate contentType Volume accept
volumeCreate _  _ volumeConfig =
  _mkRequest "POST" ["/volumes/create"]
    `setBodyParam` volumeConfig

data VolumeCreate

-- | /Body Param/ "volumeConfig" - Volume configuration
instance HasBodyParam VolumeCreate VolumeConfig

-- | @application/json@
instance Consumes VolumeCreate MimeJSON

-- | @application/json@
instance Produces VolumeCreate MimeJSON


-- *** volumeDelete

-- | @DELETE \/volumes\/{name}@
--
-- Remove a volume
--
-- Instruct the driver to remove the volume.
--
-- Note: Has 'Produces' instances, but no response schema
--
volumeDelete
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  Volume name or ID
  -> DockerEngineRequest VolumeDelete MimeNoContent res accept
volumeDelete  _ (Name name) =
  _mkRequest "DELETE" ["/volumes/",toPath name]

data VolumeDelete

-- | /Optional Param/ "force" - Force the removal of the volume
instance HasOptionalParam VolumeDelete Force where
  applyOptionalParam req (Force xs) =
    req `setQuery` toQuery ("force", Just xs)

-- | @application/json@
instance Consumes VolumeDelete MimeJSON
-- | @text/plain@
instance Consumes VolumeDelete MimePlainText

-- | @application/json@
instance Produces VolumeDelete MimeJSON
-- | @text/plain@
instance Produces VolumeDelete MimePlainText


-- *** volumeInspect

-- | @GET \/volumes\/{name}@
--
-- Inspect a volume
--
volumeInspect
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  Volume name or ID
  -> DockerEngineRequest VolumeInspect MimeNoContent Volume accept
volumeInspect  _ (Name name) =
  _mkRequest "GET" ["/volumes/",toPath name]

data VolumeInspect

-- | @application/json@
instance Consumes VolumeInspect MimeJSON
-- | @text/plain@
instance Consumes VolumeInspect MimePlainText

-- | @application/json@
instance Produces VolumeInspect MimeJSON


-- *** volumeList

-- | @GET \/volumes@
--
-- List volumes
--
volumeList
  :: Accept accept -- ^ request accept ('MimeType')
  -> DockerEngineRequest VolumeList MimeNoContent InlineResponse20015 accept
volumeList  _ =
  _mkRequest "GET" ["/volumes"]

data VolumeList

-- | /Optional Param/ "filters" - JSON encoded value of the filters (a `map[string][]string`) to process on the volumes list. Available filters:  - `name=<volume-name>` Matches all or part of a volume name. - `dangling=<boolean>` When set to `true` (or `1`), returns all    volumes that are not in use by a container. When set to `false`    (or `0`), only volumes that are in use by one or more    containers are returned. - `driver=<volume-driver-name>` Matches all or part of a volume   driver name.
instance HasOptionalParam VolumeList Filters where
  applyOptionalParam req (Filters xs) =
    req `setQuery` toQuery ("filters", Just xs)

-- | @application/json@
instance Consumes VolumeList MimeJSON
-- | @text/plain@
instance Consumes VolumeList MimePlainText

-- | @application/json@
instance Produces VolumeList MimeJSON


-- *** volumePrune

-- | @POST \/volumes\/prune@
--
-- Delete unused volumes
--
volumePrune
  :: Accept accept -- ^ request accept ('MimeType')
  -> DockerEngineRequest VolumePrune MimeNoContent InlineResponse20016 accept
volumePrune  _ =
  _mkRequest "POST" ["/volumes/prune"]

data VolumePrune

-- | /Optional Param/ "filters" - Filters to process on the prune list, encoded as JSON (a `map[string][]string`).  Available filters:
instance HasOptionalParam VolumePrune Filters where
  applyOptionalParam req (Filters xs) =
    req `setQuery` toQuery ("filters", Just xs)

-- | @application/json@
instance Consumes VolumePrune MimeJSON
-- | @text/plain@
instance Consumes VolumePrune MimePlainText

-- | @application/json@
instance Produces VolumePrune MimeJSON



-- * Parameter newtypes

newtype All = All { unAll :: Bool } deriving (P.Eq, P.Show)
newtype Author = Author { unAuthor :: Text } deriving (P.Eq, P.Show)
newtype Body4 = Body4 { unBody4 :: [Body] } deriving (P.Eq, P.Show, A.ToJSON)
newtype Body5 = Body5 { unBody5 :: [Text] } deriving (P.Eq, P.Show, A.ToJSON)
newtype Buildargs = Buildargs { unBuildargs :: Int } deriving (P.Eq, P.Show)
newtype Cachefrom = Cachefrom { unCachefrom :: Text } deriving (P.Eq, P.Show)
newtype Changes = Changes { unChanges :: Text } deriving (P.Eq, P.Show)
newtype Comment = Comment { unComment :: Text } deriving (P.Eq, P.Show)
newtype Container2 = Container2 { unContainer2 :: Text } deriving (P.Eq, P.Show)
newtype Cpuperiod = Cpuperiod { unCpuperiod :: Int } deriving (P.Eq, P.Show)
newtype Cpuquota = Cpuquota { unCpuquota :: Int } deriving (P.Eq, P.Show)
newtype Cpusetcpus = Cpusetcpus { unCpusetcpus :: Text } deriving (P.Eq, P.Show)
newtype Cpushares = Cpushares { unCpushares :: Int } deriving (P.Eq, P.Show)
newtype DetachKeys = DetachKeys { unDetachKeys :: Text } deriving (P.Eq, P.Show)
newtype Details = Details { unDetails :: Bool } deriving (P.Eq, P.Show)
newtype Digests = Digests { unDigests :: Bool } deriving (P.Eq, P.Show)
newtype Dockerfile = Dockerfile { unDockerfile :: Text } deriving (P.Eq, P.Show)
newtype Filters = Filters { unFilters :: Text } deriving (P.Eq, P.Show)
newtype Follow = Follow { unFollow :: Bool } deriving (P.Eq, P.Show)
newtype Force = Force { unForce :: Bool } deriving (P.Eq, P.Show)
newtype Forcerm = Forcerm { unForcerm :: Bool } deriving (P.Eq, P.Show)
newtype FromImage = FromImage { unFromImage :: Text } deriving (P.Eq, P.Show)
newtype FromSrc = FromSrc { unFromSrc :: Text } deriving (P.Eq, P.Show)
newtype H = H { unH :: Int } deriving (P.Eq, P.Show)
newtype Id = Id { unId :: Text } deriving (P.Eq, P.Show)
newtype ImagesTarball2 = ImagesTarball2 { unImagesTarball2 :: Binary } deriving (P.Eq, P.Show, A.ToJSON)
newtype InputImage2 = InputImage2 { unInputImage2 :: Text } deriving (P.Eq, P.Show, A.ToJSON)
newtype InputStream2 = InputStream2 { unInputStream2 :: Text } deriving (P.Eq, P.Show, A.ToJSON)
newtype InputStream4 = InputStream4 { unInputStream4 :: Binary } deriving (P.Eq, P.Show, A.ToJSON)
newtype Labels = Labels { unLabels :: Text } deriving (P.Eq, P.Show)
newtype Limit = Limit { unLimit :: Int } deriving (P.Eq, P.Show)
newtype Logs = Logs { unLogs :: Bool } deriving (P.Eq, P.Show)
newtype Memory = Memory { unMemory :: Int } deriving (P.Eq, P.Show)
newtype Memswap = Memswap { unMemswap :: Int } deriving (P.Eq, P.Show)
newtype Name = Name { unName :: Text } deriving (P.Eq, P.Show)
newtype Names = Names { unNames :: [Text] } deriving (P.Eq, P.Show)
newtype Networkmode = Networkmode { unNetworkmode :: Text } deriving (P.Eq, P.Show)
newtype NoOverwriteDirNonDir = NoOverwriteDirNonDir { unNoOverwriteDirNonDir :: Text } deriving (P.Eq, P.Show)
newtype Nocache = Nocache { unNocache :: Bool } deriving (P.Eq, P.Show)
newtype Noprune = Noprune { unNoprune :: Bool } deriving (P.Eq, P.Show)
newtype ParamContentType = ParamContentType { unParamContentType :: E'ContentType } deriving (P.Eq, P.Show)
newtype Path = Path { unPath :: Text } deriving (P.Eq, P.Show)
newtype Pause = Pause { unPause :: Bool } deriving (P.Eq, P.Show)
newtype PsArgs = PsArgs { unPsArgs :: Text } deriving (P.Eq, P.Show)
newtype Pull = Pull { unPull :: Text } deriving (P.Eq, P.Show)
newtype Q = Q { unQ :: Bool } deriving (P.Eq, P.Show)
newtype Quiet = Quiet { unQuiet :: Bool } deriving (P.Eq, P.Show)
newtype RegistryAuthFrom = RegistryAuthFrom { unRegistryAuthFrom :: Text } deriving (P.Eq, P.Show)
newtype Remote = Remote { unRemote :: Text } deriving (P.Eq, P.Show)
newtype Repo = Repo { unRepo :: Text } deriving (P.Eq, P.Show)
newtype Rm = Rm { unRm :: Bool } deriving (P.Eq, P.Show)
newtype RotateManagerToken = RotateManagerToken { unRotateManagerToken :: Bool } deriving (P.Eq, P.Show)
newtype RotateManagerUnlockKey = RotateManagerUnlockKey { unRotateManagerUnlockKey :: Bool } deriving (P.Eq, P.Show)
newtype RotateWorkerToken = RotateWorkerToken { unRotateWorkerToken :: Bool } deriving (P.Eq, P.Show)
newtype Shmsize = Shmsize { unShmsize :: Int } deriving (P.Eq, P.Show)
newtype Signal = Signal { unSignal :: Text } deriving (P.Eq, P.Show)
newtype Since = Since { unSince :: Int } deriving (P.Eq, P.Show)
newtype SinceText = SinceText { unSinceText :: Text } deriving (P.Eq, P.Show)
newtype Size = Size { unSize :: Bool } deriving (P.Eq, P.Show)
newtype Squash = Squash { unSquash :: Bool } deriving (P.Eq, P.Show)
newtype Stderr = Stderr { unStderr :: Bool } deriving (P.Eq, P.Show)
newtype Stdin = Stdin { unStdin :: Bool } deriving (P.Eq, P.Show)
newtype Stdout = Stdout { unStdout :: Bool } deriving (P.Eq, P.Show)
newtype Stream = Stream { unStream :: Bool } deriving (P.Eq, P.Show)
newtype T = T { unT :: Int } deriving (P.Eq, P.Show)
newtype TText = TText { unTText :: Text } deriving (P.Eq, P.Show)
newtype Tag = Tag { unTag :: Text } deriving (P.Eq, P.Show)
newtype Tail = Tail { unTail :: Text } deriving (P.Eq, P.Show)
newtype TarContext2 = TarContext2 { unTarContext2 :: Binary } deriving (P.Eq, P.Show, A.ToJSON)
newtype Term = Term { unTerm :: Text } deriving (P.Eq, P.Show)
newtype Timeout = Timeout { unTimeout :: Int } deriving (P.Eq, P.Show)
newtype Timestamps = Timestamps { unTimestamps :: Bool } deriving (P.Eq, P.Show)
newtype Until = Until { unUntil :: Text } deriving (P.Eq, P.Show)
newtype V = V { unV :: Bool } deriving (P.Eq, P.Show)
newtype Version = Version { unVersion :: Integer } deriving (P.Eq, P.Show)
newtype VersionInt = VersionInt { unVersionInt :: Int } deriving (P.Eq, P.Show)
newtype W = W { unW :: Int } deriving (P.Eq, P.Show)
newtype XRegistryAuth = XRegistryAuth { unXRegistryAuth :: Text } deriving (P.Eq, P.Show)
newtype XRegistryConfig = XRegistryConfig { unXRegistryConfig :: Text } deriving (P.Eq, P.Show)



-- * Custom Mime Types

-- ** MimeVndDockerRawStream

data MimeVndDockerRawStream = MimeVndDockerRawStream deriving (P.Typeable)

-- | @application/vnd.docker.raw-stream@
instance MimeType MimeVndDockerRawStream where
  mimeType _ = Just $ P.fromString "application/vnd.docker.raw-stream"
-- instance MimeRender MimeVndDockerRawStream T.Text where mimeRender _ = undefined
-- instance MimeUnrender MimeVndDockerRawStream T.Text where mimeUnrender _ = undefined

-- ** MimeXTar

data MimeXTar = MimeXTar deriving (P.Typeable)

-- | @application/x-tar@
instance MimeType MimeXTar where
  mimeType _ = Just $ P.fromString "application/x-tar"
-- instance MimeRender MimeXTar T.Text where mimeRender _ = undefined
-- instance MimeUnrender MimeXTar T.Text where mimeUnrender _ = undefined
